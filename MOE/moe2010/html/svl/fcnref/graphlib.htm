<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<!--
!!    MOE 2010.10 On-Line Manuals
!!    COPYRIGHT (C) 2010
!!        CHEMICAL COMPUTING GROUP INC.  ALL RIGHTS RESERVED.
!!-->

<!--	svl/fcnref/graphlib.htm
!!
!!  	06-may-2009 (ms) graph_ecutE
!!  	02-dec-2007 (ms) graph_articulator now uses the traditional definition
!!  	02-dec-2007 (ms) renamed graph_articulator to graph_blockarticulator
!!  	10-aug-2007 (ms) 3rd arg to graph_(u)neighbors; move example to <pre>
!!  	07-jun-2007 (ac) clarified graph_dfs2 use for ring blocks
!!	04-dec-2006 (ms) graph_firstpath, graph_npath, updated graph_scycle_list
!!	01-mar-2005 (ms) graph_spath2
!!	08-feb-2005 (ms) graph_cycleneighbors, graph_hyperneighbors
!!	07-feb-2005 (ms) graph_bfspath, graph_bfs
!!	21-jan-2005 (ms) graph_scycles etc.
!!	24-nov-2003 (pl) created
!!-->

<head>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<link rel="stylesheet" type="text/css"
href="../../manstyle.css" />


<meta keywords>
<meta functions graph_adjacency>
<meta functions graph_articulator>
<meta functions graph_automorphism_close>
<meta functions graph_automorphism_next>
<meta functions graph_automorphism_open>
<meta functions graph_bfs>
<meta functions graph_bfspath>
<meta functions graph_block>
<meta functions graph_block_list>
<meta functions graph_blockarticulator>
<meta functions graph_canonize_cycles>
<meta functions graph_ccomponent>
<meta functions graph_ccomponent_list>
<meta functions graph_center>
<meta functions graph_chain>
<meta functions graph_connector>
<meta functions graph_cycleneighbors>
<meta functions graph_dfs1>
<meta functions graph_dfs2>
<meta functions graph_diameter>
<meta functions graph_distance>
<meta functions graph_ear>
<meta functions graph_eblock_list>
<meta functions graph_eccentricity>
<meta functions graph_ecut>
<meta functions graph_ecutE>
<meta functions graph_edges>
<meta functions graph_expandpaths>
<meta functions graph_firstpath>
<meta functions graph_get>
<meta functions graph_hyperneighbors>
<meta functions graph_maxmatch>
<meta functions graph_mget>
<meta functions graph_neighbors>
<meta functions graph_npaths>
<meta functions graph_perimeter>
<meta functions graph_perm>
<meta functions graph_radius>
<meta functions graph_rot>
<meta functions graph_sconnector>
<meta functions graph_scycle>
<meta functions graph_scycle_list>
<meta functions graph_shortestpath>
<meta functions graph_spath>
<meta functions graph_spath2>
<meta functions graph_stretch>
<meta functions graph_tr>
<meta functions graph_triblock_list>
<meta functions graph_uedges>
<meta functions graph_uneighbors>
<meta functions graph_vcut>
<meta functions graph_walkclass>

<title>Graph Functions</title>
</head>


<body bgcolor="#ffffff">
<a href="../../index.htm"><img src="../../images/logo.gif"
alt="CCG Logo" align="right" width="174" height="55" border="0" /></a>
<h4>MOE 2010.10</h4>
<h2>Graph Functions</h2>
<hr noshade="noshade" />

<h2>Syntax</h2>

<pre>
    amatrix = <a class="fcnlink" href="#graph_adjacency">graph_adjacency</a> nbrlist
    dmatrix = <a class="fcnlink" href="#graph_distance">graph_distance</a> nbrlist

    nbrlist = <a class="fcnlink" href="#graph_neighbors">graph_neighbors</a> [xA, xB]
    nbrlist = <a class="fcnlink" href="#graph_uneighbors">graph_uneighbors</a> [xA, xB]

    nbrlist = <a class="fcnlink" href="#graph_neighbors">graph_neighbors</a> [xA, xB, n]
    nbrlist = <a class="fcnlink" href="#graph_uneighbors">graph_uneighbors</a> [xA, xB, n]

    [xA,xB] = <a class="fcnlink" href="#graph_edges">graph_edges</a> nbrlist
    [xA,xB] = <a class="fcnlink" href="#graph_uedges">graph_uedges</a> nbrlist

    ecc = <a class="fcnlink" href="#graph_eccentricity">graph_eccentricity</a> nbrlist
    rad = <a class="fcnlink" href="#graph_radius">graph_radius</a> nbrlist
    dia = <a class="fcnlink" href="#graph_diameter">graph_diameter</a> nbrlist
    cmask = <a class="fcnlink" href="#graph_center">graph_center</a> nbrlist
    pmask = <a class="fcnlink" href="#graph_perimeter">graph_perimeter</a> nbrlist

    nbrlist = <a class="fcnlink" href="#graph_tr">graph_tr</a> nbrlist
    nbrlist = <a class="fcnlink" href="#graph_rot">graph_rot</a> [nbrlist, k]

    nbrlist = <a class="fcnlink" href="#graph_mget">graph_mget</a> [nbrlist, mask]
    nbrlist = <a class="fcnlink" href="#graph_get">graph_get</a> [nbrlist, idx]
    nbrlist = <a class="fcnlink" href="#graph_stretch">graph_stretch</a> [nbrlist, seg]
    nbrlist = <a class="fcnlink" href="#graph_perm">graph_perm</a> [nbrlist, pos]

    nbrlist = <a class="fcnlink" href="#graph_vcut">graph_vcut</a> [nbrlist, idx]
    nbrlist = <a class="fcnlink" href="#graph_ecut">graph_ecut</a> [nbrlist, [idx1, idx2]]
    nbrlist = <a class="fcnlink" href="#graph_ecutE">graph_ecutE</a> [nbrlist, [idx1, idx2]]
    path = <a class="fcnlink" href="#graph_chain">graph_chain</a> [nbrlist, x]
    path = <a class="fcnlink" href="#graph_chain">graph_chain</a> [nbrlist, [x, p]]
    [pathA, pathB] = <a class="fcnlink" href="#graph_ear">graph_ear</a> [nbrlist, [a, b]]

    [dis, fin, par, low, cc] = <a class="fcnlink" href="#graph_dfs1">graph_dfs1</a> nbrlist
    [dis, fin, par, low, cc, tc, ebc, bc] = <a class="fcnlink" href="#graph_dfs2">graph_dfs2</a> nbrlist
    compnum = <a class="fcnlink" href="#graph_ccomponent">graph_ccomponent</a> nbrlist
    list = <a class="fcnlink" href="#graph_ccomponent_list">graph_ccomponent_list</a> nbrlist
    list = <a class="fcnlink" href="#graph_block">graph_block</a> nbrlist
    block = <a class="fcnlink" href="#graph_block_list">graph_block_list</a> nbrlist
    eblock = <a class="fcnlink" href="#graph_eblock_list">graph_eblock_list</a> nbrlist
    amask = <a class="fcnlink" href="#graph_articulator">graph_articulator</a> nbrlist
    amask = <a class="fcnlink" href="#graph_blockarticulator">graph_blockarticulator</a> nbrlist
    list = <a class="fcnlink" href="#graph_triblock_list">graph_triblock_list</a> nbrlist
    con = <a class="fcnlink" href="#graph_connector">graph_connector</a> [nbrlist, m]
    con = <a class="fcnlink" href="#graph_sconnector">graph_sconnector</a> [nbrlist, m]

    [dis, fin, par, depth, cc] = <a class="fcnlink" href="#graph_bfs">graph_bfs</a> nbrlist
    mpath = <a class="fcnlink" href="#graph_bfspath">graph_bfspath</a> [nbrlist, src, dst, depth]

    mpath = <a class="fcnlink" href="#graph_spath">graph_spath</a> [nbrlist, [a, b]]
    mpath = <a class="fcnlink" href="#graph_spath2">graph_spath2</a> [nbrlist, [a, b]]
    mpath = <a class="fcnlink" href="#graph_scycle">graph_scycle</a> [nbrlist, [a, b]]
    list = <a class="fcnlink" href="#graph_expandpaths">graph_expandpaths</a> [nbrlist, mpath]
    npaths = <a class="fcnlink" href="#graph_npaths">graph_npaths</a> [nbrlist, mpath]
    path = <a class="fcnlink" href="#graph_firstpath">graph_firstpath</a> [nbrlist, mpath]
    list = <a class="fcnlink" href="#graph_canonize_cycles">graph_canonize_cycles</a> list
    [list1, list2, list3] = <a class="fcnlink" href="#graph_scycle_list">graph_scycle_list</a> nbrlist
    path = <a class="fcnlink" href="#graph_shortestpath">graph_shortestpath</a> [nbrlist, src, dst]

    nbrlist = <a class="fcnlink" href="#graph_cycleneighbors">graph_cycleneighbors</a> clist
    nbrlist = <a class="fcnlink" href="#graph_hyperneighbors">graph_hyperneighbors</a> hlist

    cnum = <a class="fcnlink" href="#graph_walkclass">graph_walkclass</a> [nbrlist, label]
    mask = <a class="fcnlink" href="#graph_maxmatch">graph_maxmatch</a> [xA, xB, weight]

    autokey = <a class="fcnlink" href="#graph_automorphism_open">graph_automorphism_open</a> [nbrlist, label]
    idx = <a class="fcnlink" href="#graph_automorphism_next">graph_automorphism_next</a> autokey
    <a class="fcnlink" href="#graph_automorphism_close">graph_automorphism_close</a> autokey
</pre>

<h2>Description</h2>

<p>
SVL provides a number of functions for manipulating graphs.
A <i>graph</i>, <i>G</i>, is a pair (<i>V</i>,<i>E</i>) where <i>V</i> is a
set of <i>n</i> <i>vertices</i> and <i>E</i> a set of <i>m</i> <i>edges</i>
which are vertex pairs {(<i>a<sub>i</sub></i>,<i>b<sub>i</sub></i>)}.
A graph is <i>undirected</i> if whenever (<i>a</i>,<i>b</i>) is in <i>E</i>
then so is (<i>b</i>,<i>a</i>).  The <i>degree</i> of a vertex is the number of
edges in which it participates as the first member of the vertex pair
making up the edge.

<p>
In SVL, graphs can be represented in a number of ways.
The most common forms are as follows.

<ul>
<li>
The <i>neighbor list</i> representation of a graph encodes the edge set
<i>E</i> with a vector <tt>nbrlist</tt> of neighbor vectors.

For each vertex <tt>i</tt> in <i>V</i>, <tt>nbrlist</tt> gives the neighbors of
<tt>i</tt>.  That is, <tt>nbrlist</tt> has length <i>n</i> and
<tt>nbrlist(i)</tt> is a vector of indices of vertices that appear with vertex
<tt>i</tt> in an edge in which <tt>i</tt> is the first vertex of the vertex
pair making up the edge.

In such a representation
<span class="nobr"><i>E</i> = {(<tt>i</tt>, <tt>nbrlist(i)(j)</tt>) |
i = 1,2,...<i>n</i>}</span>
are the
edges of the graph and the degree of each vertex is given by
<tt>app&nbsp;length&nbsp;nbrlist</tt>.

<li>
The <i>edge list</i> representation of a graph encodes the edge set
explicitly.  The edge set <i>E</i> is represented as
two vectors of indices of vertices, <tt>xA</tt> and <tt>xB</tt>,
each of which has length <i>m</i>.

In this representation, (<tt>xA(i)</tt>,&nbsp;<tt>xB(i)</tt>) denotes
edge (<i>a<sub>i</sub></i>,&nbsp;<i>b<sub>i</sub></i>) and
<tt>l_length&nbsp;[xA,xB]</tt> is the number of edges in the graph.
</ul>

<p>
<p><a name="graph_distance"></a></p>
<p><a name="graph_adjacency"></a></p>
<p><hr noshade="noshade" />

<pre>amatrix = <span class="fcndef">graph_adjacency</span> nbrlist
dmatrix = <span class="fcndef">graph_distance</span> nbrlist
</pre>

<p>
Given a graph in neighbor list representation, <tt>graph_adjacency</tt>
returns <tt>amatrix</tt>, the <i>n</i> by <i>n</i> adjacency matrix of the
graph.  The return value is such that <tt>amatrix(i)(j)</tt> is one
if <tt>j</tt> is in <tt>nbrlist(i)</tt>, zero otherwise.

<p>
Given a graph in neighbor list representation, <tt>graph_distance</tt>
returns, <tt>dmatrix</tt>, the <i>n</i> by <i>n</i> distance matrix of the
graph.  The return value is such that <tt>dmatrix(i)(j)</tt> is the length
of the shortest path between vertices <tt>i</tt> and <tt>j</tt>.
If no path between the two vertices exists, their distance is
set to <i>n</i>, the number of vertices in the graph.

<!--
<p>For example,
<span class="nobr"><tt>graph_adjacency [2,3,[]]</tt></span> returns
<span class="nobr"><tt>[[0,1,0], [0,0,1], [0,0,0]]</tt></span>, while
<span class="nobr"><tt>graph_distance [2,3,[]]</tt></span> returns
!!! graph distance should report distance of a digraph
<span class="nobr"><tt>[[0,1,2], [4,0,1], [4,4,0]]</tt></span>.
-->

<p>
<p><a name="graph_uneighbors"></a></p>
<p><a name="graph_neighbors"></a></p>
<p><a name="graph_uneighbors"></a></p>
<p><a name="graph_neighbors"></a></p>
<hr noshade="noshade" />


<pre>nbrlist = <span class="fcndef">graph_neighbors</span> [xA, xB]
nbrlist = <span class="fcndef">graph_uneighbors</span> [xA, xB]

nbrlist = <span class="fcndef">graph_neighbors</span> [xA, xB, n]
nbrlist = <span class="fcndef">graph_uneighbors</span> [xA, xB, n]
</pre>

<p>
Given an edge list representation of a directed graph,
<tt>[xA,xB]</tt>, <tt>graph_neighbors</tt> returns the neighbor list
representation of the graph.

For each vertex <i>a</i>, the function reports all vertices <i>b</i>
such that, for some <i>k</i>,
<i>a</i>&nbsp;=&nbsp;<tt>xA(<i>k</i>)</tt>
and
<i>b</i>&nbsp;=&nbsp;<tt>xB(<i>k</i>)</tt>.

<p>
Given an edge list representation of an undirected graph,
<tt>[xA,xB]</tt> <tt>graph_uneighbors</tt> returns the neighbor list
representation of the graph.  If the input graph is not undirected,
the function converts it to an undirected graph by adding missing
reverse edges.

For each vertex <i>a</i>, the function reports all vertices <i>b</i>
such that, for some <i>k</i>,
<i>a</i>&nbsp;=&nbsp;<tt>xA(<i>k</i>)</tt>
and
<i>b</i>&nbsp;=&nbsp;<tt>xB(<i>k</i>)</tt>,
or
<i>a</i>&nbsp;=&nbsp;<tt>xB(<i>k</i>)</tt>
and
<i>b</i>&nbsp;=&nbsp;<tt>xA(<i>k</i>)</tt>.

For example,

<pre>
    svl&gt; graph_neighbors [[1,2],[2,3]]
    [2, 3, []]

    svl&gt; graph_uneighbors [[1,2],[2,3]]
    [2, [1,3], 2]
</pre>

<p>
If the optional third argument, <tt>n</tt>, is present, the graph
represented by the returned neighbor list will be extended or
truncated to contain exactly <tt>n</tt> vertices. For example,

<pre>
    svl&gt; graph_uneighbors [[1,2,3], [2,3,4]]
    [ 2, [1,3], [2,4], 3 ]

    svl&gt; graph_uneighbors [[1,2,3], [2,3,4], 5]
    [ 2, [1,3], [2,4], 3, [] ]

    svl&gt; graph_uneighbors [[1,2,3], [2,3,4], 3]
    [ 2, [1,3], 2 ]
</pre>

<p><a name="graph_uedges"></a></p>
<p><a name="graph_edges"></a></p>
<hr noshade="noshade" />

<pre>[xA,xB] = <span class="fcndef">graph_edges</span> nbrlist
[xA,xB] = <span class="fcndef">graph_uedges</span> nbrlist
</pre>

<p>
Given a neighbor list representation of a directed graph,
<tt>graph_edges</tt> returns the directed edge list for each vertex.

<p>
The <tt>graph_uedges</tt> function returns the undirected set of edges;
that is, <tt>xA(i)</tt>&nbsp;&lt;&nbsp;<tt>xB(i)</tt> with no duplicates.
The function reports all pairs
(<i>a</i>&nbsp;=&nbsp;<tt>xA(i)</tt>,&nbsp;<i>b</i>&nbsp;=&nbsp;<tt>xB(i)</tt>),
such that
<i>a</i>&nbsp;&le;&nbsp;<i>b</i> and
(<i>a</i>,<i>b</i>) or (<i>b</i>,<i>a</i>)
is an edge in the input graph.

For example,

<pre>
    svl&gt; graph_edges [2,3,[1,2]]
    [[1,2,3,3], [2,3,1,2]]

    svl&gt; graph_uedges [2,3,[1,2]]
    [[1,2,1], [2,3,3]]
</pre>

<!-- ==================== eccentricity etc ==================== -->

<p>
<p><a name="graph_perimeter"></a></p>
<p><a name="graph_center"></a></p>
<p><a name="graph_diameter"></a></p>
<p><a name="graph_radius"></a></p>
<p><a name="graph_eccentricity"></a></p>
<hr noshade="noshade" />

<pre>ecc = <span class="fcndef">graph_eccentricity</span> nbrlist
rad = <span class="fcndef">graph_radius</span> nbrlist
dia = <span class="fcndef">graph_diameter</span> nbrlist
cmask = <span class="fcndef">graph_center</span> nbrlist
pmask = <span class="fcndef">graph_perimeter</span> nbrlist
</pre>

<p>
The <i>eccentricity</i> of graph vertex <i>a</i> is the longest
distance between <i>a</i> and all other vertices in the graph.

<p>
Given a graph in neighbor list representation,
<tt>graph_eccentricity</tt> returns the eccentricity of each vertex.

For example,

<pre>
    svl&gt; graph_eccentricity [2,[1,3],[]]
    [2,1,3]
</pre>

<p>
Function <tt>graph_radius</tt> returns the graph <i>radius</i>, which
is the minimum eccentricity of the graph.

<p>
Function <tt>graph_diameter</tt> returns the graph <i>diameter</i>, which
is the maximum eccentricity of the graph.

<p>
Function <tt>graph_center</tt> returns the mask of the graph <i>center</i>,
which is the set of vertices of eccentricity equal to the graph radius.

<p>
Function <tt>graph_perimeter</tt> returns the mask of the graph
<i>perimeter</i>, which is the set of vertices of eccentricity
equal to the graph diameter.

<!-- =========== ccomponent, maxmatch, mget, walkclass =========== -->

<p>
<p><a name="graph_rot"></a></p>
<p><a name="graph_tr"></a></p>
<hr noshade="noshade" />

<pre>nbrlist = <span class="fcndef">graph_tr</span> nbrlist
nbrlist = <span class="fcndef">graph_rot</span> [nbrlist, k]
</pre>

<p>
Given a directed graph in neighbor list representation, <tt>graph_tr</tt>
reverses the edges of the graph and returns its neighbor list representation.

For example,

<pre>
    svl&gt; graph_tr [2,3,[]]
    [[],1,2]
</pre>

If the input graph is undirected, the function has no effect.

<p>
Given a graph in neighbor list representation and an integer <i>k</i>,
<tt>graph_rot</tt> rotates the vector of vertices by <i>k</i> positions
to the right and returns the neighbor list of the resulting graph.
Negative <i>k</i> rotates the vertices to the left.

For example,

<pre>
    svl&gt; graph_rot [[2,[],[],[]], 1]
    [[],3,[],[]]
</pre>

<p>
<p><a name="graph_perm"></a></p>
<p><a name="graph_stretch"></a></p>
<p><a name="graph_get"></a></p>
<p><a name="graph_mget"></a></p>
<hr noshade="noshade" />

<pre>nbrlist = <span class="fcndef">graph_mget</span> [nbrlist, mask]
nbrlist = <span class="fcndef">graph_get</span> [nbrlist, idx]
nbrlist = <span class="fcndef">graph_stretch</span> [nbrlist, seg]
nbrlist = <span class="fcndef">graph_perm</span> [nbrlist, pos]
</pre>

<p>
Given a graph in neighbor list representation and a length <i>n</i>
vertex mask, <tt>graph_mget</tt> returns the subgraph consisting of the
vertices <tt>i</tt> for which <tt>mask(i)</tt> is nonzero, and the edges
connecting such vertices.

<p>
Given a graph
<i>G</i>=(<i>V</i>=1..<i>n</i>,&nbsp;<i>E</i>)
in neighbor list representation, <tt>nbrlist</tt>,
and a vector of <i>m</i> vertex indices, <tt>idx</tt>,
function <tt>graph_get</tt> returns
the neighbor list representation of a graph
<i>H</i>=(<i>U</i>=1..<i>m</i>,&nbsp;F</i>),

such that (<i>a</i>,<i>b</i>) is an edge in <i>F</i> if and only if
(<tt>idx</tt>(<i>a</i>),<tt>idx</tt>(<i>b</i>)) is also an edge in <i>E</i>.

<p>
Given a vector of segment lengths, <tt>graph_stretch</tt> returns a graph
consisting of the vertices <tt>i</tt> replicated <tt>seg(i)</tt> times.

The result of <tt>graph_stretch</tt> with segments <tt>seg</tt> is identical
to the result of <tt>graph_get</tt> with indices
<tt>idx=stretch[igen&nbsp;</tt><i>n</i><tt>,seg]</tt>,
given the same neighbor list of <i>n</i> vertices.

<p>
Given a permutation vector, <tt>pos</tt>,
<tt>graph_perm</tt> returns a graph
consisting of the vertices <tt>i</tt> moved to position <tt>pos(i)</tt>.

The result of <tt>graph_perm</tt> with permutation <tt>pos</tt> is identical
to the result of <tt>graph_get</tt> with indices
<tt>idx=perm[igen&nbsp;</tt><i>n</i><tt>,pos]</tt>,
given the same neighbor list of <i>n</i> vertices.

<p>
<p><a name="graph_ecut"></a></p>
<p><a name="graph_ecutE"></a></p>
<p><a name="graph_vcut"></a></p>
<hr noshade="noshade" />

<pre>nbrlist = <span class="fcndef">graph_vcut</span> [nbrlist, idx]
nbrlist = <span class="fcndef">graph_ecut</span> [nbrlist, [idx1, idx2]]
nbrlist = <span class="fcndef">graph_ecutE</span> [nbrlist, [idx1, idx2]]
</pre>

<p>
Given a graph in neighbor list representation and a set or sets of vertices,
functions <tt>graph_vcut</tt> and <tt>graph_ecut</tt>
remove all edges incident to the given vertices and
return the resulting subgraph.

Function <tt>graph_vcut</tt> removes all
edges that start or end at a vertex from the set <tt>idx</tt>.
Function <tt>graph_ecut</tt> removes all
edges that start at a vertex from the set <tt>idx1</tt>
and end at a vertex from the set <tt>idx2</tt>.

Function <tt>graph_ecutE</tt> interprets the pair of vectors
<tt>idx1</tt> and <tt>idx2</tt> as a laminated list of edges
to be removed; <tt>idx1</tt> and <tt>idx2</tt> must unit-extend
to the same length.

<p><pre>
    svl&gt; A = [[3,4], [3,4], [1,2], [1,2]]
    svl&gt; graph_vcut [A, 1]
    [ [], [3,4], 2, 2 ]
    svl&gt; graph_ecut [A, [[1,2],[3,4]]]
    [ [], [], [], [] ]
    svl&gt; graph_ecutE [A, [[1,2],[3,4]]]
    [4,3,2,1]
</pre>

<p>
<p><a name="graph_ear"></a></p>
<p><a name="graph_chain"></a></p>
<p><a name="graph_chain"></a></p>
<hr noshade="noshade" />

<pre>path = <span class="fcndef">graph_chain</span> [nbrlist, x]
path = <span class="fcndef">graph_chain</span> [nbrlist, [x, p]]
[pathA, pathB] = <span class="fcndef">graph_ear</span> [nbrlist, [a, b]]
</pre>

<p>
Given a graph in neighbor list representation and one vertex, <tt>x</tt>,
<tt>graph_chain</tt> returns the longest <i>chain</i> that starts
at the vertex <tt>x</tt>, which is a path that is composed only
of vertices of degree 2, except for the first vertex, <tt>x</tt>,
which must be of degree 1, and the last vertex, which can be of any degree.
If the first vertex, <tt>x</tt>, is of degree other than one,
then the path will comprise only the vertex <tt>x</tt>.

<p>
Given a graph in neighbor list representation and two vertices
<tt>x</tt> and <tt>p</tt>, <tt>graph_chain</tt> first removes any
edge between the two vertices and then returns the longest chain
that starts from vertex <tt>x</tt>.

<p>
Given a graph in neighbor list representation and two vertices
<tt>a</tt> and <tt>b</tt>, <tt>graph_ear</tt> first removes any
edge between the two vertices and then returns two paths:
1) the longest chain that starts from vertex <tt>a</tt> and
2) the longest chain that starts from vertex <tt>b</tt>.
If the first path ends at vertex <tt>b</tt>, then the second
path will comprise only the vertex <tt>b</tt>.

<p>
<p><a name="graph_dfs2"></a></p>
<p><a name="graph_dfs1"></a></p>
<hr noshade="noshade" />

<pre>[dis, fin, par, low, cc] = <span class="fcndef">graph_dfs1</span> nbrlist
[dis, fin, par, low, cc, tc, ebc, bc] = <span class="fcndef">graph_dfs2</span> nbrlist
</pre>

<p>
Given a graph in neighbor list representation, functions
<tt>graph_dfs1</tt> and <tt>graph_dfs2</tt> will calculate the
vertex and edge labels associated with the <i>depth-first search</i>
of the graph.
These are utility routines that are used internally for calculating
other graph properties.

<ul>
<li><tt>dis(i)</tt>
is the DFS discovery time of vertex <tt>i</tt>.
<li><tt>fin(i)</tt>
is the DFS finishing time of vertex <tt>i</tt>.
<li><tt>par(i)</tt>
is the DFS parent vertex of vertex <tt>i</tt>.
<li><tt>low(i)</tt>
is the lowest DFS back-edge discovery time of vertex <tt>i</tt>.
<li><tt>cc(i)</tt>
is the connected component ID of vertex <tt>i</tt>.
<li><tt>tc(i)</tt>
is the tree component ID of vertex <tt>i</tt>.
<li><tt>ebc(i)</tt>
is the edge-biconnected block ID of vertex <tt>i</tt>.
<li><tt>bc(i)(k)</tt>
is the pure tree component ID or block ID of edge (<tt>i,j</tt>),
where <tt>j=nbrlist(i)(k)</tt>.
</ul>

Definitions:

<ul>

<li>A <i>connected component</i> is a maximal subgraph that has every pair of
vertices connected by some path.

<li>A <i>tree component</i> is a maximal subgraph that has every pair of
vertices connected by exactly one path.

<li>A <i>block</i> is a maximal subgraph that has every pair of vertices
connected by at least two paths.

<li>An <i>articulator</i> whose removal would disconnect the graph.

<li>A <i>block articulator</i> is a vertex that belongs to at least two different
tree components or blocks.

<li>A <i>spiro articulator</i> is a vertex that belongs to at least two
different blocks but no tree components.

<li>A <i>pure tree component</i> is a maximal subgraph that has every pair of
vertices connected by exactly one path and no path contains any block articulator,
except as its end vertices.  Spiro articulators are considered to be pure tree
components of size 1.

<li>An <i>edge-biconnected block</i> is a maximal subgraph that has every pair
of vertices connected by at least two edge-disjoint paths, i.e. paths that may
share some vertices but don't share any edges. This is equivalent to the ring
block ID for the node, which is 0 if the node is not contained within any cycle,
or &gt;&nbsp;0 if it is contained within at least one cycle. All nodes which are
in the same ring block share the same <i>edge-biconnected block</i> value.

</ul>

<p>
Block IDs are returned as positive integers,
tree component IDs as negative integers
(except for spiro articulators).
Edge-biconnected blocks are assigned the ID of the first (minimum)
block they comprise.
Tree components are assigned the ID of the first
(maximum) pure tree component they comprise.
Spiro articulators assigned the ID of their edge-biconnected block.

<p><tt>graph_dfs2</tt> can be used to obtain information about ring blocks. For
example, the following graph has two distinct edge-biconnected blocks:

<p align="center"><img src="graphlib/ringblocks.png"></p>

<p><pre>
    svl&gt; nbrlist = [
            [2,11,3], [4,1], [1,6], [2,5], [4,9,6], [3,7,5], 
            [10,8,6], [9,7], [8,5], 7, [12,1], [15,17,11], 
            [14,15], [13,16], [13,12], [14,17], [16,12]
	];
    svl&gt; rblk = (graph_dfs2 nbrlist)(7);
    svl&gt; print rblk
    [1,1,1,1,1,1,1,1,1,0,0,2,2,2,2,2,2]
</pre>

<p>
<p><a name="graph_ccomponent_list"></a></p>
<p><a name="graph_ccomponent"></a></p>
<hr noshade="noshade" />

<pre>compnum = <span class="fcndef">graph_ccomponent</span> nbrlist
list = <span class="fcndef">graph_ccomponent_list</span> nbrlist
</pre>

<p>
Given a graph in neighbor list representation,
function <tt>graph_ccomponent</tt> finds all connected components of the
graph and returns the connected component ID of each vertex.
Given a graph of <i>n</i> vertices with <i>c</i> connected components,
the function returns an <i>n</i>-vector of integers
in the range 1,2,...,<i>c</i>.
Two vertices have the same component ID if and only if there is a path
between them.

<p>
Function <tt>graph_ccomponent_list</tt>
returns the list of connected components.
Vector <tt>list(i)</tt> comprises all vertices of component <tt>i</tt>.

<p>
Each vertex is a member of only one connected component.

<p>
<p><a name="graph_blockarticulator"></a></p>
<p><a name="graph_articulator"></a></p>
<p><a name="graph_eblock_list"></a></p>
<p><a name="graph_block_list"></a></p>
<p><a name="graph_block"></a></p>
<hr noshade="noshade" />

<pre>list = <span class="fcndef">graph_block</span> nbrlist
block = <span class="fcndef">graph_block_list</span> nbrlist
eblock = <span class="fcndef">graph_eblock_list</span> nbrlist
amask = <span class="fcndef">graph_articulator</span> nbrlist
amask = <span class="fcndef">graph_blockarticulator</span> nbrlist
</pre>

<p>
Given edges of a graph in neighbor list representation,
function <tt>graph_block</tt> finds all blocks (biconnected components) of
the graph and replaces each edge in the neighbor list
with its the block or pure tree component ID
(see <tt>graph_dfs2</tt> for details).
Blocks are assigned positive IDs, tree components, negative IDs.

<p>
Function <tt>graph_block_list</tt>
returns the list of all blocks.  Vector <tt>block(i)</tt> comprises
all vertices of block <tt>i</tt>.

<p>
Function <tt>graph_eblock_list</tt>
returns the list of all edge-biconnected blocks.
Vector <tt>eblock(i)</tt> comprises all vertices of the <tt>i</tt>-th
edge-biconnected block.

<p>
Function <tt>graph_articulator</tt>
returns the mask of all articulators.

<p>
Function <tt>graph_blockarticulator</tt>
returns the mask of all block articulators.

<p>
Each vertex may be a member of more than one block.
Each vertex is a member of at most one edge-biconnected block.

<p>
<p><a name="graph_triblock_list"></a></p>
<hr noshade="noshade" />

<pre>list = <span class="fcndef">graph_triblock_list</span> nbrlist
</pre>

<p>
Given edges of a graph in neighbor list representation,
<tt>graph_triblock_list</tt> returns the list of all triconnected blocks.
Vector <tt>list(i)</tt> comprises all vertices of triblock <tt>i</tt>.

<p>
A <i>triconnected block</i> is a maximal subgraph with each pair of vertices
connected by at least three (vertex-disjoint) paths.  For example, a cube
is a triconnected graph.

<p>
<p><a name="graph_connector"></a></p>
<hr noshade="noshade" />

<pre>con = <span class="fcndef">graph_connector</span> [nbrlist, m]
</pre>

<p>
Given edges of a graph in neighbor list representation and a mask defining
a set of vertices, <tt>graph_connector</tt> finds

the <i>connecting vertices</i>:
the union of all paths connecting any two vertices from the given set.

If the given vertices belong to the same connected component,
the function returns the mask of the connecting vertices.

If the given vertices belong to several different connected components,
the function returns a vector of vertex labels, where the connecting
vertices of the same component are labeled with the same positive number
and all non-connecting vertices are labeled with zero.

<p>
<p><a name="graph_sconnector"></a></p>
<hr noshade="noshade" />

<pre>
con = <span class="fcndef">graph_sconnector</span> [nbrlist, m]
</pre>

<p>
Given edges of a graph in neighbor list representation and a mask defining a
set of vertices, <tt>graph_sconnector</tt> finds

the union of all shortest paths connecting any two vertices from the given set.

If the given vertices belong to the same connected component, the function
returns the mask of the connecting vertices.

If the given vertices belong to several different connected components, the
function returns a vector of vertex labels, where the connecting vertices of
the same component are labeled with the same positive number and all
non-connecting vertices are labeled with zero.

<p>
The function is similar to function <tt>graph_connector</tt>.  However, on
inputs that require connecting many vertices of large cycle components, it can
be significantly slower than function <tt>graph_connector</tt>.

<p>
On the connecting cycle components of the graph, function
<tt>graph_sconnector</tt> returns only those vertices that lie on a connecting
shortest path, while function <tt>graph_connector</tt> returns all vertices of
the component.

On the connecting tree components of the graph, the outputs of functions
<tt>graph_connector</tt> and <tt>graph_sconnector</tt> are identical.

<p>
<p><a name="graph_bfspath"></a></p>
<p><a name="graph_bfs"></a></p>
<hr noshade="noshade" />

<pre>
[dis, par, depth, cc] = <span class="fcndef">graph_bfs</span> nbrlist
mpath = <span class="fcndef">graph_bfspath</span> [nbrlist, src, dst, maxdepth]
</pre>

<p>
Given a graph in neighbor list representation, functions
<tt>graph_bfs</tt> and <tt>graph_bfspath</tt> will traverse
the graph using the <i>breadth-first search</i> traversal.
These are utility routines that are used internally for calculating
other graph properties.

<p>
Function <tt>graph_bfs</tt> will calculate the vertex labels
associated with the breadth-first search:

<ul>
<li><tt>dis(i)</tt>
is the BFS discovery time of vertex <tt>i</tt>.
The discovery times are consecutive integers, starting from 1.
<li><tt>par(i)</tt>
is the BFS parent vertex of vertex <tt>i</tt>.  The parent of
the root vertex is 0.
<li><tt>depth(i)</tt>
is the BFS depth vertex <tt>i</tt>.  The root vertex of each
component has depth 1.
<li><tt>cc(i)</tt>
is the connected component ID of vertex <tt>i</tt>.
The component IDs are consecutive integers, starting from 1.
</ul>

<p>
Function <tt>graph_bfspath</tt> returns the graph vertices in the
breadth-first search order, starting from the given set of vertices,
<tt>src</tt>.  The output vertices are split to lists of
vertices of the same depth.

The traversal is terminated if it reaches a destination vertex
from <tt>dst</tt> or if it reaches the maximum depth, <tt>maxdepth</tt>.
A missing <tt>maxdepth</tt> argument is equivalent to infinity.

Vector <tt>mpath</tt>(<i>k</i>) will contain all vertices
of distance <i>k</i>-1 from <tt>src</tt>.

<p>
<p><a name="graph_scycle"></a></p>
<p><a name="graph_spath2"></a></p>
<p><a name="graph_spath"></a></p>
<hr noshade="noshade" />

<pre>
mpath = <span class="fcndef">graph_spath</span> [nbrlist, [a, b]]
mpath = <span class="fcndef">graph_spath2</span> [nbrlist, [a, b]]
mpath = <span class="fcndef">graph_scycle</span> [nbrlist, [a, b]]
</pre>

<p>
Given edges of a graph in neighbor list representation and two sets of vertices
<tt>a</tt> and <tt>b</tt>, <tt>graph_spath</tt> returns vertices on all
shortest paths from <tt>a</tt> to <tt>b</tt>. Vector <tt>mpath</tt>(<i>k</i>)
will contain all vertices of distance <i>k</i>-1 from <tt>a</tt> and of
distance <i>m-k</i> from <tt>b</tt>, where
<i>m</i>=<tt>length&nbsp;mpath</tt>. Function <tt>graph_spath</tt> returns the
shortest paths between the vertices of <tt>a</tt> closest to <tt>b</tt> and the
vertices of <tt>b</tt> closest to <tt>a</tt>.  In other words, only the first
vertex of each shortest path belongs to <tt>a</tt> and only the last vertex
of each path belongs to <tt>b</tt>.  Some vertices from <tt>a</tt> or <tt>b</tt>
may not belong to any path.

<p>
Given edges of a graph in neighbor list representation and two sets of vertices
<tt>a</tt> and <tt>b</tt>, <tt>graph_spath2</tt> returns vertices on all
shortest paths from <tt>a</tt> to each element of <tt>b</tt>.  Vector
<tt>mpath</tt>(<i>k</i>) will contain all vertices of distance <i>k</i>-1 from
<tt>a</tt> and of distance <i>m-k</i> from some element of <tt>b</tt>, where
<i>m</i>=<tt>length&nbsp;mpath</tt>. Function <tt>graph_spath2</tt> returns the
shortest paths between the vertices of <tt>a</tt> closest to <tt>b</tt> and all
vertices of <tt>b</tt> regardless their distance to <tt>a</tt>.  In other
words, only the first vertex of each shortest path belongs to <tt>a</tt>
and some vertices from <tt>a</tt> may not belong to any path.  However,
each vertex from <tt>b</tt> belongs to some path, even though it may not
always be the last vertex of the path.

<p>
Given edges of a graph in neighbor list representation and an edge,
(<tt>a,b</tt>), <tt>graph_scycle</tt> returns vertices of all shortest cycles
incident to that edge. The function first removes the given edge (<tt>a,b</tt>)
from the graph and then returns all shortest paths from <tt>a</tt> to
<tt>b</tt> in the same format given by function <tt>graph_spath</tt>.

<p>
<p><a name="graph_canonize_cycles"></a></p>
<p><a name="graph_firstpath"></a></p>
<p><a name="graph_npaths"></a></p>
<p><a name="graph_expandpaths"></a></p>
<hr noshade="noshade" />

<pre>
list = <span class="fcndef">graph_expandpaths</span> [nbrlist, mpath]
npaths = <span class="fcndef">graph_npaths</span> [nbrlist, mpath]
path = <span class="fcndef">graph_firstpath</span> [nbrlist, mpath]
list = <span class="fcndef">graph_canonize_cycles</span> list
</pre>

<p>
Given the result of the previous functions, <tt>graph_expandpaths</tt> expands
the implicit paths and returns a list of explicit paths.  Given <i>m</i> lists
of vertices, <tt>mpath</tt>, the function returns the list of all paths,
<tt>list</tt>, such that vertex <tt>list(i)</tt>(<i>k</i>) belongs to
<tt>mpath</tt>(<i>k</i>), for all <i>k</i>=1,2,...<i>m</i>.

<p>
In some cases, the paths returned by function <tt>graph_expandpaths</tt>
may be too numerous and prohibitive in computer resources to calculate
explicitly.  For example, the number of shortest paths that traverse
an N-unit polysaccaride is 2<sup>N</sup>.
Functions <tt>graph_npaths</tt> and <tt>graphs_firstpath</tt>
allow the user to avoid calling the function <tt>graphs_expandpaths</tt>
in certain common cases.

<p>
Function <tt>graph_npaths</tt> returns the size of the result
of function <tt>graph_expandpaths</tt>, i.e. the number of all possible
paths, without generating the paths explicitly.  The calculation is
fast even when the number of paths is extremely large.

<p>
Function <tt>graph_firstpath</tt> returns the first path returned by
function <tt>graph_expandpaths</tt>.  The calculation is fast even when
the number of paths is extremely large.

<p>
Given a list of cycles, with each cycle represented by a list of vertices,
<tt>graph_canonize_cycles</tt> will rotate and/or reverse each cycle (list of
vertices) to its <i>canonical</i> form, defined here as the lexicographically
first of all orderings of the cycle vertices.  That is, the smallest vertex is
listed first and the smaller of its neighbors is listed second.

<p>
<p><a name="graph_scycle_list"></a></p>
<hr noshade="noshade" />

<pre>[list1, list2, list3] = <span class="fcndef">graph_scycle_list</span> nbrlist
</pre>

<p>
Given edges of a graph in neighbor list representation,
<tt>graph_scycle_list</tt> returns three lists of selected shortest cycles.  The
first list, <tt>list1</tt>, contains all cycles that are the unique shortest
cycle with respect to one of their edges.  The second list, <tt>list2</tt>,
contains all cycles that are one of exactly two shortest cycles with respect to
one of their edges and that don't already belong to <tt>list1</tt>.
The third list, <tt>list3</tt>, contains a minimal list of the remaining
shortest cycles that are needed to cover all cycle edges in the graph.

<p> For example, given the graph of the indole molecule
(<tt>"c12c([nH]cc1)cccc2"</tt>), the function returns both the
5-element pyrrole ring and the 6-element benzene ring in <tt>list1</tt>.
However, given the graph of the <tt>C<sub>60</sub></tt> fullerene, the
function returns only the 5-element rings in <tt>list1</tt>, while the
6-element rings are returned in <tt>list2</tt>.  Given the molecule
<tt>"C1COCCN2CCOCCOCCN(CCO1)CCc3ccc(CC2)cc3"</tt>, the function returns
only the 6-element benzene ring in <tt>list1</tt>, while two of the five
possible (shortest) 18-element rings are returned in <tt>list3</tt>.

<p>
<p><a name="graph_hyperneighbors"></a></p>
<p><a name="graph_cycleneighbors"></a></p>
<hr noshade="noshade" />

<pre>nbrlist = <span class="fcndef">graph_cycleneighbors</span> clist
nbrlist = <span class="fcndef">graph_hyperneighbors</span> hlist
</pre>

<p>
Given a list of <i>n</i> cycles, <tt>graph_cycleneighbors</tt>
returns the neighbor list representation of a graph

<i>G</i>=(<i>V</i>=1..<i>n</i>,&nbsp;<i>E</i>),

such that the edge (<i>u</i>,<i>v</i>) belongs to <i>E</i> if and only if
cycles

<tt>clist(</tt><i>u</i><tt>)</tt> and <tt>clist(</tt><i>v</i><tt>)</tt>

share an edge.

<p>
Given a list of <i>n</i> cycles, <tt>graph_hyperneighbors</tt>
returns the neighbor list representation of a graph

<i>G</i>=(<i>V</i>=1..<i>n</i>,&nbsp;<i>E</i>),

such that the edge (<i>u</i>,<i>v</i>) belongs to <i>E</i> if and only if
cycles

<tt>hlist(</tt><i>u</i><tt>)</tt> and <tt>hlist(</tt><i>v</i><tt>)</tt>

share a vertex.

However, <tt>graph_hyperneighbors</tt> can be given not only
a list of graph cycles, but also a list of arbitrary sets, representing
the (hyper)edges of a <i>hypergraph</i>.

<p>
In a graph, each edge is incident to exactly two vertices.
In a <i>hypergraph</i>, each <i>hyperedge</i> can be incident
to more than two vertices.

The set comprising the IDs of all hyperedges that are incident to vertex
<i>a</i> is called the <i>incidence list</i> of vertex <i>a</i>.

<p>
Given a list of <i>n</i> incidence lists (i.e. arbitrary sets),
<tt>graph_hyperneighbors</tt> returns the neighbor list
representation of a hypergraph

<i>G</i>=(<i>V</i>=1..<i>n</i>,&nbsp;<i>E</i>),

such that the hyperedge

<span class="nobr">
(<i>u</i><sub>1</sub>,
<i>u</i><sub>2</sub>,
...)
</span>

belongs to <i>E</i> if and only if the incidence lists (sets)

<span class="nobr">
{<tt>hlist(</tt><i>u</i><sub>1</sub><tt>)</tt>,
<tt>hlist(</tt><i>u</i><sub>2</sub><tt>)</tt>,
...}
</span>

intersect.

<p>
<p><a name="graph_walkclass"></a></p>
<hr noshade="noshade" />

<pre>cnum = <span class="fcndef">graph_walkclass</span> [nbrlist, label]
</pre>

<p>
Given an undirected graph in neighbor list representation and a label for
each vertex, <tt>graph_walkclass</tt> returns an integer for each vertex
such that two vertices have the same returned integer if and only if
the set of all walks emanating from one vertex is identical to the other.
In other words, <tt>graph_walkclass</tt> determines walk-symmetric vertices.
Note: <tt>graph_walkclass</tt> detects isomorphic vertices only with
respect to walks; there are graphs for which vertices are walk-isomorphic
but not generally isomorphic.

<p>
<p><a name="graph_shortestpath"></a></p>
<hr noshade="noshade" />

<pre>path = <span class="fcndef">graph_shortestpath</span> [nbrlist, src, dst]
</pre>

<p>
Given an undirected graph in neighbor list representation and a label for
each vertex, <tt>graph_shortestpath</tt> returns an ordered list of vertex
numbers detailing the shortest path from the <tt>src</tt> vertex to the
<tt>dst</tt> vertex.  The first element of the returned path is <tt>src</tt>
and the last is <tt>dst</tt>.  Null is returned if there is no path from
<tt>src</tt> to <tt>dst</tt>.

<p>
<p><a name="graph_maxmatch"></a></p>
<hr noshade="noshade" />

<pre>mask = <span class="fcndef">graph_maxmatch</span> [xA, xB, weight]
</pre>

<p>
Given an edge list representation <tt>[xA,xB]</tt> of an undirected graph
and a set of non-negative numeric weights such that <tt>weight(i)</tt> is
the weight of edge (<tt>xA(i)</tt>,<tt>xB(i)</tt>), <tt>graph_maxmatch</tt>
returns a mask such that <tt>mask(i)</tt> is one if edge <tt>i</tt> is
in the matching of maximum weight and zero otherwise.

A <i>matching</i> is a subset of non-adjacent edges and a maximal matching
is a matching in which all unmatched edges are adjacent to a matched edge.
The return matching is such that <span class="nobr"><tt>add (weight|mask)</tt></span>
is maximized.

Note: the calculation is performed with 30 bits of precision for the weight.

<!-- =========== automorphism =========== -->

<p>
<p><a name="graph_automorphism_close"></a></p>
<p><a name="graph_automorphism_next"></a></p>
<p><a name="graph_automorphism_open"></a></p>
<hr noshade="noshade" />

<pre>autokey = <span class="fcndef">graph_automorphism_open</span> [nbrlist, label]
idx = <span class="fcndef">graph_automorphism_next</span> autokey
<span class="fcndef">graph_automorphism_close</span> autokey
</pre>

<p>
The <tt>graph_automorphism</tt> functions are used in tandem to calculate
all of the automorphisms of a labeled graph.  A graph automorphism is
a permutation of the vertex labels that preserves edge connectivity.  The
three functions are typically used as follows:
<pre>    local key = graph_automorphism_open [nbrlist, label]
    local idx;

    while length (idx = graph_automorphism_next key) loop
        // each vertices[idx] is an edge conserving vertex permutation
    endloop

    graph_automorphism_close key;
</pre>

<p>
Note that the SVL <tt>dmatch</tt> functions are used calculate the
automorphisms; therefore, the given graph should not be very large otherwise
prohibitively large resources may be required.

<h2>See Also</h2>

<a href="dmatch.htm">Distance Geometry Matching Functions</a><br />
<a href="../../moe/fcnref/bondlist.html">Atom Functions</a>


<p><a href="../../index.htm">MOE Table of Contents</a>&nbsp;&nbsp;<a href="../../fcnindex.html">SVL Function Index</a></p>
<hr noshade="noshade" />
<a href="http://www.chemcomp.com"><img src="../../images/flogo.gif"
alt="CCG Logo"
align="left" width="30" height="30" border="1" hspace="5" vspace="3" /></a>
<font size="2">
<a href="../../legal.html">Copyright</a> &copy; 1997-2010
<a href="http://www.chemcomp.com">Chemical Computing Group Inc.</a><br />
<a href="mailto:info@chemcomp.com"><i>info@chemcomp.com</i></a>
</font>
</body>
</html>
