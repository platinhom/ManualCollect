<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<!--
!!    MOE 2010.10 On-Line Manuals
!!    COPYRIGHT (C) 2010
!!        CHEMICAL COMPUTING GROUP INC.  ALL RIGHTS RESERVED.
!!-->

<head>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<link rel="stylesheet" type="text/css"
href="../manstyle.css" />


<title>SVL Tutorial</title>
</head>

<body bgcolor="#ffffff">
<a href="../index.htm"><img src="../images/logo.gif"
alt="CCG Logo" align="right" width="174" height="55" border="0" /></a>
<h4>MOE 2010.10</h4>
<h2>SVL Tutorial</h2>
<hr noshade="noshade" />

<ul>
  <li><a href="#RunningSVLInteractively">Getting Started</a></li>
  <li><a href="#UsingSVLasaGlorifiedCalculator">Using SVL as a Glorified Calculator</a></li>
  <li><a href="#IntroductiontoVectors">Introduction to Vectors</a></li>
  <li><a href="#SVLDataTypes">SVL Data Types</a></li>
  <li><a href="#RearrangingVectorElements">Rearranging Vector Elements</a></li>
  <li><a href="#AccessingVectorElements">Accessing Vector Elements</a><ul>
      <li><a href="#MaskingvsIndexing">Masking vs. Indexing</a></li>
      <li><a href="#ValueExtractionFunctions">Value Extraction Functions</a></li>
      <li><a href="#TaggedVectors">Tagged Vectors</a></li>
    </ul>
  </li>
  <li><a href="#InputandOutput">Input and Output</a></li>
  <li><a href="#UsingFunctions">Using Functions,
    Conditional Execution and Flow Control</a><ul>
      <li><a href="#AdvancedExample">Advanced Example</a></li>
      <li><a href="#Scripts">Scripts</a></li>
      <li><a href="#ExecutablePrograms">Executable Programs</a></li>
      <li><a href="#ErrorsandDebugging">Errors and Debugging</a></li>
    </ul>
  </li>
  <li><a href="#RecordingYourSVLSession">Recording Your SVL Session</a></li>
  <li><a href="#TokenPatternMatching">Token Pattern Matching</a></li>
  <li><a href="#PublicSymbolsManagement">Public Symbols Management</a></li>
  <li><a href="#ShellCommands">Shell Commands</a></li>
</ul>

<h3><a name="RunningSVLInteractively">Getting Started</a></h3>


<p>In this tour, we encourage you to type in all the examples and use them
as models for your own exploratory trials. Comments, which are denoted by
the <tt>//</tt> comment delimiter, are not required.  When entering each
line, remember that you should not type <tt>svl&gt;</tt>. The notation of
this prompt has been included as an indicator of which line is the input
line. Terminate each line by pressing <tt>Enter</tt>.</p>

<p><b>Note:</b> If you make a mistake typing, SVL may display an error box.
To remove the error box, press the OK button or the
<tt>Enter</tt> or <tt>Esc</tt> key anywhere within one of the
MOE windows.</p>

<p>To begin this SVL tutorial, open the 
<a href="../moe/gui/svlcommands.html">SVL Commands window</a> 
by choosing Window&nbsp;|&nbsp;Commands
in the MOE Window.
</p>
<h3>
<a name="UsingSVLasaGlorifiedCalculator">Using SVL as a Glorified Calculator</a>
</h3>

<p>SVL can be thought of as a powerful calculator. It performs basic
arithmetic: </p>

<pre>
    svl&gt; 1 + 3
    4 

    svl&gt; 13 / 4
    3.25

    svl&gt; sqrt (sqr 3 + sqr 4)
    5 
</pre>

<p>and also evaluates trigonometric and exponential expressions: </p>

<pre>
    svl&gt; cos 0
    1 

    svl&gt; exp 1
    2.71828

    svl&gt; log2 8
    3

    svl&gt; atan 1
    0.785398 
</pre>

<p><a href="../svl/manual/data.html">SVL operators</a>
can be written in two ways: infix notation, in which symbols such as
<tt>+</tt> and <tt>*</tt> are positioned between operands and their
equivalent prefix notation, which uses longhand SVL function names that
precede their operands. Infix notation is shorthand, and only exists for
certain functions. The following are equivalent: </p>

<pre>
    svl&gt; 1 + 2
    3 

    svl&gt; add [1,2]
    3
</pre>

<p>SVL also provides <a href="../svl/fcnref/constants.html">built-in
constants</a>.  For example, the mathematical constant <em>pi</em> is
given by the SVL built-in constant <tt>PI</tt>. </p>

<pre>
    svl&gt; PI
    3.14159
</pre>

<p>Numbers are by default treated as floating-point (real numbers) for
calculations.  However, integer operations such as <tt>odd</tt> and
<tt>even</tt> expect integers, and their behavior is not well-defined for
real numbers.</p>

<p>Bitwise operations also expect integers: </p>

<pre>
    svl&gt; bitand [5,6] // binary 101 AND 110
    4
</pre>

<p>In addition to arithmetic operations, SVL can be used to evaluate
logical and relational expressions. False expressions evaluate to
<tt>0</tt>, true expressions to <tt>1</tt>.  </p>

<pre>
    svl&gt; 1 &gt; 2
    0 

    svl&gt; 2 * 3 == 6
    1 

    svl&gt; cbrt 8 &lt;&gt; 2 // cube root
    0 

    svl&gt; [1,0,1] and [-1,2,0]
    [1,0,0] 
</pre>

<p>Data can be manipulated as variables. Variables need to be assigned
values before they can be used. </p>

<pre>
    svl&gt; a = 10 
    svl&gt; a = b // Error! b undefined
    svl&gt; b = a + 5
    svl&gt; b
    15 
</pre>

<p><b>Note:</b> In this example, we need to query for <tt>b</tt>
separately because the value of an assignment is not displayed at the
command line.</p>

<p>More than one statement can be put on the same line. Statements are
terminated by semi-colons. A terminating semi-colon at the end of a line is
optional. In general, the value of the last expression is printed out unless
the expression was an assignment, the expression was terminated by a
semi-colon (unless it included a call to a printing function such as
<tt>print</tt> or <tt>pr</tt>), or the value of the expression was null.
</p>

<pre>
    svl&gt; c = a * b; c; a; // nothing prints out
    svl&gt; c = a * b; c; a  // a is printed
    150 
</pre>

<p>Values can be explicitly printed using <tt>print</tt> and <tt>pr</tt>: </p>

<pre>
    svl&gt; c = a * b; print c; a; // only c is printed
    150
    svl&gt; print [a,b,c];
    [10,15,150]
    svl&gt; print c = a * b;       // prints and assigns a*b
    150
    svl&gt; c = a * pr b;          // prints b; assigns a*b
    15
    svl&gt; c = pr (a * b)         // prints and assigns a*b
    150 
</pre>

<h3><a name="IntroductiontoVectors">Introduction to Vectors</a></h3>

<p>The real power of SVL lies in its ability to manipulate data as vectors.
This means that, instead of operating on single numbers, SVL can operate on
whole data sets in a single statement.</p>

<p>A vector is denoted using square brackets <tt>[]</tt> and its elements
are separated by commas. Vectors can be nested, i.e.
contain other vectors. Its elements may be expressions. </p>

<pre>
    svl&gt; [2,3,4]         // a vector of three elements
    [2,3,4] 

    svl&gt; [ [1,2], 3, 4 ] // a nested vector
    [ [1,2], 3, 4 ] 

    svl&gt; [ 1+2, cbrt 8 ] // a vector containing SVL expressions
    [3,2] 
</pre>

<p>The function <tt>igen</tt> generates a vector containing a sequence of
consecutive integers, beginning with <tt>1</tt>. </p>

<pre>
    svl&gt; igen 5
    [1,2,3,4,5]
</pre>

<p>Vectors can be assigned to 
<a href="../svl/manual/funcs.html">variables</a>, and numeric
vectors can be operated upon in much the same way as ordinary numbers. SVL
<a href="../svl/manual/funcs.html">variable names</a> must
begin with a letter (<tt>a-z</tt>, <tt>A-Z</tt>) or an underscore
(<tt>_</tt>). The body of a name can be any combination of letters,
digits, and the underscore character.  The name should not be longer than
78 characters.  </p>

<pre>
    svl&gt; b = [1,4,9]     // assign a vector to b
    svl&gt; sqrt b
    [1,2,3]

    svl&gt; a = sqrt b
    svl&gt; a + a
    [2,4,6] 

    svl&gt; add [ a, [1,2,3] ]
    [2,4,6]

    svl&gt; c = [2,3,4] 
    svl&gt; add (a*c)       // dot product
    20 

    svl&gt; sqrt add sqr c  // Euclidean-norm
    5.38516
</pre>

<p>Observe how natural the construction of the Euclidean-norm calculation is. It
practically reads as &quot;the square root of the sum of the squares&quot;.
Note that the SVL function <tt>norm</tt> achieves the same result.
</p>
<p>The <i>shape</i> of a vector refers to its length and depth of nesting.
In general, vectors must be of the same shape to be operated upon
together; the resulting vectors are also of the same shape as the source
vectors. </p>

<pre>
    svl&gt; b = [2,3,4,5]; c = [1,2,3] 
    svl&gt; length b
    4

    svl&gt; length c
    3 

    svl&gt; b + c // Error!
</pre>

<p>It would be useful, however, if we could write: </p>

<pre>
    svl&gt; b + 2 
</pre>

<p>and obtain: </p>

<pre>
    [4,5,6,7] 
</pre>

<p>This is, in fact, what we get. The mechanism that allows us to combine
vectors with single numeric values is called <i>unit extension</i>. Unit
extension causes a &quot;unit,&quot; in this case a single number, to take on
the shape of the vector with which it is being combined. The results of unit
extension can be tricky to predict.  Consider the following examples. In all
cases, the <tt>1</tt> in the second term unit-extends. </p>

<pre>
    svl&gt; [1,2] + 1
    [2,3] 

    svl&gt; [ [1,2], 3 ] + 1
    [ [2,3], 4 ]

    svl&gt; [ [1,2], 3 ] + [1,2] // [ [1,2]+1, 3+2 ]
    [ [2,3], 5 ] 

    svl&gt; [ [ 1, [2,3] ], 4 ] + [1,2]
    [ [ 2, [3,4] ], 6 ] 
</pre>

<p>Unit extension is not limited to &quot;atomic&quot; units (e.g.
single numbers). For example, when calculating an outer product: </p>

<pre>
    svl&gt; [1,2,3] * [ [4,5,6] ]
    [ [4,5,6], [8,10,12], [12,15,18] ] 
</pre>

<p>the right-hand vector is the unit, which extends to each of the
elements in the left-hand vector. </p>

<p><b>Note:</b> <a href="../svl/manual/svlfund.html">Unit
extension</a> is both an extremely important concept and a very powerful
property. Please take some time now to experiment, and ensure that you
understand when unit extension takes place.</p>

<p>Only <i>unit vectors</i> unit-extend. Unit vectors are single-element
vectors. Here are a few examples: </p>

<pre>
    [ [2,3] ] 
    [ &quot;ab&quot; ] 
    [ [ [2,3], &quot;ab&quot; ] ]
</pre>

<p><a href="../svl/manual/svlfund.html"><i>Scalars</i></a> are a
special class of unit vectors.  They can be written with or without
enclosing brackets. Here are some scalars: </p>

<pre>
    3.4 
    [3.4]
    &quot;a&quot; 
    [&quot;a&quot;] 
    'token' 
    ['token'] 
</pre>

<p>One conspicuous exception to the general rule stipulating that vectors
must have the same shape in order to be operated upon together is the
group of logical and relational operators that operate
<i>lexicographically</i>.</p>

<p>Relational and logical operators can be applied both element-wise as well
as lexicographically. Lexicographic operators, unlike element-wise operators,
perform comparisons between top-level vector elements only. Vector operations
that operate at the leaf-level require that their source vectors have the
same shape and are referred to as <i>element-wise</i> operations. They
operate on the single, atomic elements of their operands even when the
elements are deeply nested. (For more information, please refer to
<a href="../svl/manual/svlfund.html">lexicographic and element-wise operators</a>
and
<a href="../svl/manual/svlfund.html">nesting</a>.)</p>

<p>Relational operators perform equality and dictionary-order comparisons
between vectors, and logical operators perform logical operations on vectors.
<i>False</i> has value zero. <i>True</i> is any non-zero integer, either
positive or negative. (Floating point numbers will be rounded, so 0.3 evaluates
to  false, while 0.7 evaluates to true.) The element-wise operators are
indicated by the suffix <tt>E</tt>, and the lexicographic ones by the suffix
<tt>L</tt>.  Observe how the behavior of element-wise and lexicographic
operators differs in the following examples:</p>

<pre>
    svl&gt; a = [1,2,3] 
    svl&gt; b = [1,2,3,4] 
    svl&gt; a === b      // shorthand for eqL [a,b]
    0

    svl&gt; a == b       // shorthand for eqE [a,b]. error! 
	<em>error</em>

    svl&gt; b = [5,2,-4] 
    svl&gt; a == b
    [0,1,0] 

    svl&gt; ltL [a,b]   // a is lexicographically smaller than b
    1 

    svl&gt; leE [a,b]   // [a1&lt;=b1, a2&lt;=b2, a3&lt;=b3]
    [1,1,0] 

    svl&gt; minL [a,b]  // result is a
    [1,2,3] 

    svl&gt; minE [a,b]  // result is [a1, a2, b3]
    [1,2,-4] 

    svl&gt; minL [&quot;acd&quot;, &quot;bbe&quot;] // strings are vectors too 
    &quot;acd&quot; 

    svl&gt; minE [&quot;acd&quot;, &quot;bbe&quot;] 
    &quot;abd&quot;
</pre>

<h3><a name="SVLDataTypes">SVL Data Types</a></h3>

<p>All data at the leaf level of any SVL vector are scalars.  There are
three kinds of SVL scalars: numbers, characters and tokens.  Tokens are
strings of characters treated as a unit.  However, we reserve the word
"string" for a sequence of characters stored in a flat vector of non-unit
(&gt;1) length.</p>

<p>SVL syntax allows you to directly specify the sequence of characters
that form a
<a class="svl" href="../svl/manual/svlfund.html">token</a> or a
<a class="svl" href="../svl/manual/svlfund.html">string</a> with
single-quote or double-quote delimiters, respectively.</p>

<pre>
    "a"    // a character
    'abc'  // a token 
    "abc"  // a string 
    ["a","b","c"]  // the same string 

    svl&gt; length 'abc'
    1 
    svl&gt; length &quot;abc&quot;
    3 
</pre>

<p>A single-quote or a double-quote character may be included
in a token or a string if preceded by a backslash (<tt>\</tt>):</p>

<pre>
    'Single quote (\') in a token'
    "Double quote (\") in a string"
</pre>

<p>Vectors are not restricted to one single data type; you can put any
kind of data into a vector. The following are legal vectors:</p>

<pre>
    svl&gt; &quot;a2 .&quot;                         // character
    &quot;a2 .&quot; 

    svl&gt; [0, -1, 0.3, 1.0e10, -2E-3]    // numeric
    [0,-1,0.3,1e+10,-0.002] 

    svl&gt; ['a2 .','012345dot!@* --']     // token
    ['a2 .','012345abc!@* --'] 

    svl&gt; [ &quot;abc&quot;, 'abc', 0.2, [1,&quot;a&quot;] ] // heterogeneous
    [ &quot;abc&quot;, 'abc', 0.2, [ 1, &quot;a&quot; ] ]
</pre>

<p><b>Note:</b> Decimal numbers cannot begin with a decimal point. Thus
<tt>0.3</tt> is accepted, but <tt>.3</tt> generates an error. </p>

<h3><a name="RearrangingVectorElements">Rearranging Vector Elements</a></h3>

<p>It is often necessary to rearrange vector elements. There are
several ways in which to do this, including <i>sorting</i>,
<i>shifting</i>, <i>rotation</i>, <i>reversal</i>, and
<i>transposition</i>. Random re-ordering and arbitrary orderings are also
possible.</p>

<p>For example, <tt>sort</tt> rearranges vector elements into 
<a href="../svl/manual/svlfund.html">dictionary order</a>.  
Punctuation precedes digits, digits
precede letters, and uppercase letters precede lowercase ones.  </p>

<pre>
    svl&gt; sort &quot;science&quot;
    &quot;cceeins&quot; 

    svl&gt; sort ['cat','bat','at']
    ['at','bat','cat'] 

    svl&gt; sort [5,2,3]
    [2,3,5]

    svl&gt; sort [ &quot;fed&quot;, [4,3,2,1], &quot;cba&quot; ]
    [ [4,3,2,1], &quot;cba&quot;, &quot;fed&quot; ] 
</pre>

<p>Notice how <tt>sort</tt> operates at the top level of a vector. To
apply such a function to each of the top-level elements themselves, you
can use the operator 

<a href="../svl/manual/svlfund.html"><tt>app</tt></a>.

This is called <i>function extension</i> or <i>apply-to-each</i>.</p>

<pre>
    svl&gt; app sort [ &quot;fed&quot;, [4,3,2,1], &quot;cba&quot; ]
    [ &quot;def&quot;, [1,2,3,4], &quot;abc&quot; ] 
</pre>

<p>Observe that the following is illegal: </p>

<pre>
    svl&gt; app app sort [ [ &quot;fed&quot;, [4,3,2,1] ], &quot;cba&quot;]
	<em>error</em>
</pre>

<p><b>Note:</b> Function extension, like unit extension, is a fundamental SVL
concept. </p>

<p>Here are some examples of SVL functions that rearrange vector
elements. Notice the difference between shifting and rotating: </p>

<pre>
    svl&gt; b = [1,2,3] 
    svl&gt; rotl b                     // rotate left
    [2,3,1] 

    svl&gt; shiftl b                   // shift left
    [2,3,3]

    svl&gt; reverse b
    [3,2,1] 

    svl&gt; a = [4,5,6] 
    svl&gt; rotl a * rotr b - rotl b * rotr a // cross product
    [3,-6,3]
</pre>

<p>We can once again use <tt>app</tt> to work on each top-level element in
turn: </p>

<pre>
    svl&gt; a = [ [1,2,3], &quot;abcd&quot; ]
    svl&gt; app rotl a
    [ [2,3,1], &quot;bcda&quot; ]

    svl&gt; app shiftl a
    [ [2,3,3], &quot;bcdd&quot; ]

    svl&gt; app reverse a
    [ [3,2,1], &quot;dcba&quot; ]
</pre>

<p>The transpose operator <tt>tr</tt> is used primarily to collate
function arguments from vectors of individual arguments. <tt>tr</tt>
performs matrix transposition, that is, it makes rows into columns. Thus:
</p>

<pre>
    1 2 3
    4 5 6
</pre>

<p>becomes: </p>

<pre>
    1 4
    2 5
    3 6
</pre>

<p>Try the following examples at the command line: </p>

<pre>    
    svl&gt; tr [ [1,2,3], [4,5,6] ]
    [ [1,4], [2,5], [3,6] ] 

    svl&gt; tr [ 1, [1,2,3] ]            // 1 unit-extends!
    [ [1,1], [1,2], [1,3] ] 

    svl&gt; add [ [1,2,3], [4,5,6] ]
    [5,7,9] 

    svl&gt; add tr [ [1,2,3], [4,5,6] ]  // [1,4]+[2,5]+[3,6]
    [6,15] 

    svl&gt; app add [ [1,2,3], [4,5,6] ] // [[1+2+3], [4+5+6]]
    [6,15] 

    svl&gt; app add tr [[1,2,3],[4,5,6]] // [[1+4],[2+5],[3+6]]
    [5,7,9] 
</pre>

<h3><a name="AccessingVectorElements">Accessing Vector Elements</a></h3>

<p>Vector elements are <i>ordered</i> (except in <i>tagged</i> vectors,
which are unordered), and can be accessed for reading or for modification
by their <i>indices</i> (or <i>subscripts</i>). 
<a href="../svl/manual/svlfund.html">Vector indices</a> are
consecutive integers, starting with <tt>1</tt>. They can be generated for
a given vector using <tt>x_id</tt>. The length of a vector, 
found using <tt>length</tt>, is the same as the value of the largest
vector element index.</p>

<pre>
    svl&gt; a = [2,3,4]
    svl&gt; x_id a
    [1,2,3]
    svl&gt; length a
    3

    svl&gt; b = [ [1,2], 3, 4 ] 
    svl&gt; x_id b
    [1,2,3] 
    svl&gt; length b
    3
</pre>

<p>Observe that <tt>x_id</tt> returns only the subscripts of the top-level
elements.</p>

<p>Parentheses <tt>()</tt> and brackets <tt>[]</tt> are used to extract and
replace elements, given the element indices as arguments. Their behaviors are
different, except when treating scalar elements. </p>

<pre>
    svl&gt; a = [2,3,4] 
    svl&gt; a(2)
    3 
    svl&gt; a[2]                // same result as a(2)
    3 

    svl&gt; a(2) = 99; a
    [2,99,4] 
    svl&gt; a(2) = [1,2]; a
    [ 2, [1,2], 4 ] 
    svl&gt; a[2] = 100; a
    [2,100,4] 
    svl&gt; a[2] = [1,2]; a     // error! 
	<em>error</em>
    svl&gt; a[2] = [[1,2]]; a
    [ 2, [1,2], 4 ] 
    svl&gt; a(2) = [[1,2]]; a   // compare
    [2, [ [1,2] ], 4]

    svl&gt; b = [[1,2], [3,4]]; 
    svl&gt; c = d = e = b;      // initialize some variables to b 
    svl&gt; b(2)                // returns the second element
    [3,4] 
    svl&gt; b[2]                // vector containing 2nd element
    [ [3,4] ]
    svl&gt; b(2) = [5,6]; b     // replace element #2
    [ [1,2], [5,6] ] 
    svl&gt; c[2] = [[5,6]]; c   // replace element #2
    [ [1,2], [5,6] ] 
    svl&gt; d([2,1]) = [5,6]; d // replace 1st element of...
                             // ...the 2nd element of d 
    [ [1,2], [ [5,6], 4] ] 
    svl&gt; e[[2,1]] = [5,6]; e // replace elements #2 and #1
    [6,5] 
</pre>

<p><tt>[]</tt> is shorthand notation for the SVL functions <tt>get</tt>
and <tt>put</tt>.  Similarly, <tt>()</tt> is shorthand for <tt>peek</tt> and
<tt>poke</tt>. Shorthand notations for <tt>put</tt> and <tt>poke</tt>
further include assignment, which is indicated by the assignment symbol
<tt>=</tt>. Thus, <tt>[]=</tt> and <tt>()=</tt> differ from their
longhand <tt>put</tt> and <tt>poke</tt> forms, which do not
perform assignment.</p>

<p><tt>get</tt> is used to extract all or part of a vector, using a list of
indices to select which elements to <tt>get</tt>. <tt>peek</tt> is also used
for extraction but behaves differently. In both cases, their argument is an
index list, which is a vector.</p>

<ul>
  <li><tt>get</tt> can extract multiple elements and return them in the
form of a vector. In other words, it adds a set of brackets around the
returned elements; <tt>peek</tt> returns a single element without
additional brackets.</li>

  <li>the indices in the index list for <tt>get</tt> correspond to
elements at the top level of the vector to access; for <tt>peek</tt>,
however, the first index refers to a top-level element, the next index to
an object within that top-level element, and so forth.</li>

</ul>

<p><tt>put</tt> and <tt>poke</tt> have a similar association.</p>

<p>For more information, see 
<a href="../svl/manual/svlfund.html">primary data access functions</a>.</p>

<p>Elements cannot be accessed with index values less than <tt>1</tt>. </p>

<pre>
    svl&gt; a = igen 5; a
    [1,2,3,4,5] 

    svl&gt; a(0)         // Error!
	<em>error</em>
</pre>

<p>If you try to access values beyond the end of the vector,
i.e. with indices greater than the length of the vector,
no error will be signaled. The returned value is the
<i>null</i> (or <i>empty</i>) vector.  When the null vector is the return
value of an operation, it is not echoed to the screen. </p>

<pre>
    svl&gt; a = igen 5
    svl&gt; a(6)         // returns null
</pre>

<p>The null vector has length <tt>0</tt>. It can be denoted in two ways:
<tt>[]</tt> and <tt>""</tt>. </p>

<p><b>Note:</b> <tt>[[]]</tt> and <tt>" "</tt> (space) are not null vectors,
nor is <tt>''</tt>.  The latter is called <i>null token</i> and is a
scalar.</p>

<h3><a name="MaskingvsIndexing">Masking vs. Indexing</a></h3>

<p>As we have seen, vector elements can be accessed by their indices.
Another way to use an element's position to access the element is to
create a <i>mask</i>. A mask is a vector whose elements have a one-to-one
correspondence with the elements in another vector. A non-zero mask value
marks the corresponding vector element as selected, while a zero marks it
as unselected. Note that, whereas an index list may be of arbitrary length,
a mask must be of the same length as the vector to which it is to be
applied.</p>

<p>The <tt>put</tt> and <tt>get</tt> functions have forms that use masks.
In the following, an error occurs when the number of values to insert is
greater than the number of non-zeros in the mask. </p>

<pre>
    svl&gt; b = [2,3,4] 
    svl&gt; mget [ b, [0,1,1] ]       // get last two elements
    [3,4] 

    svl&gt; b | [0,1,1]               // | is shorthand for mget
    [3,4] 

    svl&gt; mput [ b, [0,1,1], 5 ]    // 5 unit-extends
    [2,5,5] 

    svl&gt; b                         // mput does not alter source
    [2,3,4] 

    svl&gt; b | [0,1,1] = [6,7]; b    // |= is mput with assignment
    [2,6,7] 

    svl&gt; mput [ b, [0,1,1], [8,9,10] ] // error! 
</pre>

<p>There is an SVL naming convention to explicitly distinguish functions that
return masks, and functions that return indices: the <tt>x_</tt> prefix is
short for inde<b>x</b>, and <tt>m_</tt> prefix is short for <b>m</b>ask. In
general, both the returned index lists and masks apply to elements of the
source vector.</p>

<p>For more information, see 
<a href="../svl/manual/svlfund.html">indexing</a>
and 
<a href="../svl/manual/svlfund.html">mask functions</a>
</p>

<h3><a name="ValueExtractionFunctions">Value Extraction Functions</a></h3>

<p>Data from a vector can be extracted based on element values rather than
positions. For instance, the presence of elements in a second vector can be
used to determine which data are extracted from a given vector.</p>

<p>The function <tt>uniq</tt> returns the unique elements of a given vector. </p>

<pre>
    svl&gt; a = &quot;bookkeeper&quot;
    svl&gt; uniq a
    &quot;bokepr&quot; 

    svl&gt; x_uniq a     // indices of 1st occurrence of unique elements
    [1,2,4,6,8,10] 

    svl&gt; m_uniq a     // mask of 1st occurrence of unique elements
    [1,1,0,1,0,1,0,1,0,1] 

    svl&gt; get [a, x_uniq a] // extract using indices
    &quot;bokepr&quot; 

    svl&gt; a | m_uniq a // extract using mask and mget
    &quot;bokepr&quot; 
</pre>

<p><tt>diff</tt> and <tt>join</tt> each take two source vectors <tt>a</tt>
and <tt>b</tt> as arguments. <tt>diff[a,b]</tt> returns elements in
<tt>a</tt> <i>not</i> in <tt>b</tt>, while <tt>join[a,b]</tt> returns
elements in <tt>a</tt> that <i>are</i> in <tt>b</tt>.  Both preserve the
order of elements as they appear in <tt>a</tt>, both retain duplicate
elements, and in both cases, the returned index list or mask refers to
<tt>a</tt>.  Furthermore, both <tt>diff</tt> and <tt>join</tt> have
<tt>m_</tt> and <tt>x_</tt> forms. </p>

<pre>
    svl&gt; a = &quot;aafyz&quot; 
    svl&gt; b = &quot;yaggy&quot; 
    svl&gt; diff [a,b]
    &quot;fz&quot; 

    svl&gt; diff [b,a]
    &quot;gg&quot; 

    svl&gt; x_diff [a,b]
    [3,5] 

    svl&gt; m_diff [a,b]
    [0,0,1,0,1] 

    svl&gt; diff [a,a]         // returns null (not displayed) 
    svl&gt; join [a,b]
    &quot;aay&quot; 

    svl&gt; join [b,a]
    &quot;yay&quot; 

    svl&gt; x_join [a,b]
    [1,2,4] 

    svl&gt; m_join [a,b]       // === not m_diff [a,b]
    [1,1,0,1,0]
</pre>

<h3><a name="TaggedVectors">Tagged Vectors</a></h3>

<p>Unlike ordered vectors, the elements of 
<a href="../svl/manual/svlfund.html">tagged vectors</a> cannot be
accessed by masking or indexing. Instead, each element has an associated
<i>tag </i>which, when used in conjunction with the <i>dot operator</i>,
allows reading from or writing to the element. </p>

<pre>
    svl&gt; v = [ a:10, b:'fg', c:&quot;xyz&quot; ]  // a tagged vector 
    svl&gt; v.a
    10 

    svl&gt; v.a = [1,2]; v
    [ a:[1,2], b:'fg', c:&quot;xyz&quot; ] 

    svl&gt; v.d = 5; v                     // add a new element
    [ a:[1,2], b:'fg', c:&quot;xyz&quot;, d:5 ] 
</pre>

<p>A tagged vector can be created from two vectors, one containing tags
and the other containing values. The reverse operation is also possible:
a tagged vector can be broken down into its constituent tag and 
value vectors.  Tags are specified as tokens.  </p>

<pre>
    svl&gt; untag v                // return tags and values separated
    [ ['a','b','c','d'], [ [1,2], 'fg', &quot;xyz&quot;, 5 ] ] 

    svl&gt; tag [ ['j','k','l'], [1,2,3] ]
    [ j:1, k:2, l:3 ]
</pre>

<h3><a name="InputandOutput">Input and Output</a></h3>

<p>In this section, we will examine simple input and output (I/O)
operations. Generally, I/O calls are made from within functions, and not
from the command line.</p>

<p>The string read function, <tt>sread</tt>, converts the characters in
its argument string <tt>string_data</tt> according to the format
instructions in the <tt>format</tt> argument. </p>

<pre>
    [v,c,f] = sread [ &quot;string_data&quot;, 'format' ] 
</pre>

<p>The return values <tt>[v,c,f]</tt> are: the converted values, the
number of characters read, and the number of fields read respectively.
<tt>format</tt> is a token composed of format fields (delimited by braces
<tt>{}</tt>) and plain characters.  Format fields include type specifiers
indicating how the input data is to be interpreted. These specifiers are:
<tt>n:</tt> for numbers, <tt>t:</tt> for tokens, <tt>c:</tt> for
characters, and <tt>v:</tt> for syntactically correct vectors. Plain
characters are sequences of characters that must be matched exactly by
data in the input stream.  Non-matching characters are discarded.</p>

<p>Here are some examples: </p>

<pre>
    svl&gt; sread [&quot;2.37 -4.51 K 6e-3&quot;, '{n:3} {n:4} K {n:}']
    [ [2.3,-4.5,0.006], 17, 3 ] 

    svl&gt; sread [&quot;hi there&quot;, '{c:*2} {t:}']
    [ [ &quot;hi&quot;, 'there' ], 8, 2 ] 
</pre>

<p>The syntax of the output commands is similar. <tt>swrite </tt>writes to
a string, which is returned, and <tt>write</tt> writes to the standard
output device, i.e. the display. </p>

<pre>
    s = swrite [ 'format', argument_list ]
    write [ 'format', argument_list ] 
</pre>

<p><tt>argument_list</tt> is <tt>arg1, arg2, ....</tt> There is one format
field per argument. If there are insufficient arguments, the shortfall is
made up using nulls.</p>

<p>Plain characters in the format string are copied verbatim
to the output.  If one entire argument is to be copied verbatim to the
output, the type specifier in the format field is not necessary. </p>

<pre>
    svl&gt; write ['Today is {} {n:2}, {}.\n','May',102,2001]
    Today is May 10, 2001. 

    svl&gt; swrite ['{n:.3e} furlong / {} fortnight',-0.032,0.4]
    &quot;-3.200e-02 furlong / 0.4 fortnight&quot; 
</pre>

<p>For more information, see <a href="../svl/manual/io.html">SVL input/output formats</a>.</p>

<h3>
<a name="UsingFunctions">Using Functions, Conditional Execution and Flow Control</a>
</h3>

<p>Any significant amount of computation should be encapsulated in a
<a href="../svl/manual/funcs.html">function</a>. In this section, you will
discover how to write, load and call functions, and how to pass them
arguments.</p>

<p>A function stored in file <tt>'filename'</tt> is loaded with: </p>

<pre>
    svl&gt; load 'filename'
</pre>

<p>where <tt>'filename'</tt> is the name, enclosed in single quotes, of
the file in which the function is stored. A loaded file is referred to as
a <i>module</i>.</p>

<p><b>Note:</b> File and function names need not be the same. Functions
are not permitted to share the same name. SVL will complain if you attempt
to load a function with the same name as an already-loaded function. The
exception is if you re-load a file. In this case, the functions from the
previous loading of that file will be replaced.</p>

<p>Using your favorite editor, create a new file called <tt>mean.svl</tt>.
As the first line of the file type:</p>
<pre>
    #svl
</pre>

<p>The <tt>#svl</tt> directive should be included in every file containing
svl code.</p>

<p>Now type the following code into your file: </p>

<pre>
    global function mean x     // x is the function argument
        local len, sum;        // declare two local variables
        print x;               // print argument
        len = length x;        // number of elements in x

        if len &lt;= 0 then       // check for degenerate case 
	    print 'zero length vector'; 
	    return 0; 
	endif 

	sum = add x;           // compute sum of all elements 

	return sum / len;      // return the mean 
    endfunction 
</pre>

<p>Here are a few remarks about this piece of code: </p>

<ul>
  <li>The <tt>function</tt> keyword must always be paired with an
  <tt>endfunction</tt> keyword for a multi-line function (below, we will
see a compact function definition for a one-line function).</li>

  <li>The argument of an SVL function is always a <i>single vector</i>.
Thus, multiple function arguments must be packaged together into one
vector.</li>

  <li>The <tt>print</tt> function echoes the value of its argument back to
the SVL Commands window. </li>

  <li>The <a href="../svl/manual/control.html">
if statement</a> is always started with an <tt>if-then</tt>
statement and ended with an <tt>endif</tt> keyword.  Optional
<tt>elseif</tt> and <tt>else</tt> branches are allowed.</li>

</ul>

<p><b>Note:</b> Unlike at the command line, a semi-colon (<tt>;</tt>)
<b>must</b> appear at the end of every line <b>except</b> if the line ends
with an SVL reserved word such as <tt>then</tt>, <tt>endif</tt> or
<tt>endfunction</tt>, in which case it may be safely omitted. When in doubt,
use a semi-colon.  A missing semi-colon will result in an error.</p>

<p>Now, load and run the function: </p>

<pre>
    svl&gt; load 'mean.svl'    // load the function
    svl&gt; mean igen 10       // function argument is igen 10
    [1,2,3,4,5,6,7,8,9,10]
    5.5

    svl&gt; mean []            // function argument is []
    []
    'zero length vector'
    0 

    svl&gt; mean [[1,2,3], [4,5,6]]  // ([1,2,3]+[4,5,6]) / 2
    [ [1,2,3], [4,5,6] ]
    [2.5,3.5,4.5]
</pre>

<p>Congratulations! You have successfully created and executed your first SVL
function.</p>

<p>The function <tt>mean</tt> can also be defined as a one-liner (we have
omitted the check for zero-length argument): </p>

<pre>
    global function mean x = add x / length x; 
</pre>

<p>This function can be loaded and run in the same way as the longer version
above. Note that the <tt>endfunction</tt> is <b>not</b> required when a
function is wholly contained on one line and is assigned a return value
through the <tt>=</tt> operator. </p>

<p>Now we will go on to a slightly more complicated example. </p>

<h3><a name="AdvancedExample">Advanced Example</a></h3>

<p>Our next example demonstrates the use of an SVL loop. Loops are
necessary when sequential iteration is required. There is one emphatic
<i>caveat</i> when deciding whether to use a loop: loops should never be
used to access the elements of a vector one-by-one in sequence. (There are
exceptions to this rule: loops are warranted when the operations being
performed on each element are of high complexity.) In non-vector
languages, this is generally the purpose to which loops are most commonly
employed. For example, calculating the sum of elements of each row in an
array would normally require a nested loop like this: </p>

<pre>
    for( j=0; j&lt;NUM_ROWS; j++ ) {       /* C code */
        for( i=0; i&lt;NUM_COLS; i++ ) {
            array_row_sum[j] += A[j][i];
	}
    }
</pre>

<p>This kind of programming should be avoided in SVL.
Instead, use the 
<a href="../svl/manual/svlfund.html"><tt>app</tt></a>
function or, better, avoid loops altogether by working on flat
vectors. For instance, the above C code can be replaced by the following
single line of SVL: </p>

<pre>
    svl&gt; app add A
</pre>

<p>for <tt>A</tt> of the form <tt>[ [row 1] [row 2] ... [row N] ]</tt>.</p>

<p>The next example represents an implementation of the secant method of
root-finding in one dimension. This is an iterative method with the
following iteration rule: </p>

<ul><li><span class="nobr">
    <i>x</i><sub><i>i</i>+1</sub> =
    <i>x</i><sub><i>i</i></sub> -
    <i>y</i><sub><i>i</i></sub> &middot;
    (<i>x</i><sub><i>i</i></sub> - <i>x</i><sub><i>i</i>-1</sub>) /
    (<i>y</i><sub><i>i</i></sub> - <i>y</i><sub><i>i</i>-1</sub>)
</span></li></ul>

<p>where <i>y<sub>i</sub></i> = <i>f(x<sub>i</sub>)</i>, and <i>f</i> is
the function whose roots are sought. The iterations are continued either
until <i>y<sub>i</sub></i> is zero, or within some epsilon of zero, in
which case the root has been reached, or until the second term, the
correction to the latest guess <i>x<sub>i</sub></i>, is smaller than some
epsilon.</p>

<p>Our implementation finds only one root at a time, in other words,
it is a <i>scalar</i> implementation.</p>

<p>In the following, <tt>x1</tt> and <tt>x2</tt> are arguments to the
algorithm.  We take <tt>x1</tt> to be the latest guess, i.e.
<i>x<sub>i</sub></i> in the iteration formula given above and <tt>x2</tt> to
be <i>x</i><sub><i>i</i>-1</sub>.</p>

<p>Create a new file <tt>rtsec.svl</tt> containing the following code.
Starred numbers, e.g. <tt>*1*</tt>, refer to annotations which
follow.</p>

<pre>
    // f	... name of the function whose root is sought
    // x1	... estimate close to the root
    // x2	... second-best estimate
    // del_x .. correction term y_i * dx / dy

    global function rootsec [f, x1, x2]
	const BIG_NUMBER = 1000; 
	const MAX_ITERATIONS = 100; 
	const EPSILON = 1e-10; 

	    // declare local variables 

	local y1, y2, dx,dy, del_x=BIG_NUMBER; 
	local i;    // evaluate starting values of y_i, y_i-1

	[y1,y2]= app call [ [f,x1], [f,x2] ];	// <b>*1*</b> 

	for i in igen MAX_ITERATIONS		// <b>*2*</b> 
	while andE (abs[y1,del_x] > EPSILON) loop	// <b>*3*</b> 
	    [dx,dy] = [ x1 - x2, y1 - y2 ]; 
	    [x2,y2] = [x1,y1]; // update x_i-1, y_i-1

		// EPS_M is machine epsilon 
		// to avoid divide-by-zero,
		// if abs dy &lt; EPS_M, stop

	    if abs dy &lt; EPS_M then 
		write 'Error'; 
		return; 
	    endif 

	    del_x = y1  * dx / dy;  // new del_x 
	    x1 = x1  - del_x;       // new x_i 
	    y1 = call [f,x1];       // new y_i 
	endloop

	fwrite[0,' of iterations: {n:}\n',i];	// <b>*4*</b> 
	write[' root: {n:.10}\n f(x) :{n:.10}\n',x1,y1]; 
    endfunction
</pre>

<p><strong>Annotations: </strong></p>

<ol>
<li><tt>app call [ [f,x1], [f,x2] ]</tt> makes two calls to function
<tt>f</tt>, which was passed as an argument to <tt>rootsec</tt>.</li>

<li>The loop construct used here is a special case of the general 
<a href="../svl/manual/control.html">SVL loop</a>
structure. Here, we used a <tt>for-in-while</tt> loop.
</li>

<li>This is the termination condition. Parentheses <tt>()</tt> are used
here for explicitly establishing 
<a href="../svl/manual/data.html">precedence</a>.</li>

<li>File number <tt>0</tt> is the standard output device, i.e. the
display. When <tt>fwrite</tt> is called with file number <tt>0</tt>, it
behaves essentially the same way as <tt>write</tt>.

</li>
</ol>

<p>To illustrate the operation of <tt>rootsec</tt>, we need to define a
function whose roots are to be found. Append the following code to your file: </p>

<pre>
    global function myfunc x = sin x - x / 2; 
</pre>

<p>If you are running SVL in the SVL Commands window, you can view
<tt>myfunc</tt> using the plot functions. Enter the following at the SVL
command line (use the up arrow key to retrieve a command from
the command history list): </p>

<pre>
    svl&gt; load 'rtsec.svl' 
    svl&gt; x = 0.025 * (igen 1001 - 501) 
    svl&gt; wkey = PlotS [ [x, myfunc x]];
    svl&gt; PlotSet [wkey,  [plotTitle : 'sin x - x/2'] ] ;

    svl&gt; x = 0.005 * (igen 1001 - 501) 
    svl&gt; PlotS [ [x, myfunc x]];
    svl&gt; PlotSet [wkey,  [plotTitle : 'sin x - x/2'] ] 
</pre>

<p>The first line creates the domain <tt>x</tt> over which to evaluate the
function. <tt>PlotS</tt> plots the function along the ordinate axis, and
places x on the abscissa. We make two plots, the first to <tt>get</tt> a
&quot;big picture&quot; view, which shows us that the function has only 3
roots. From the second finer-resolution plot we can obtain brackets for
each of the roots.</p>

<p>Now run <tt>rootsec</tt>, passing the function <tt>myfunc</tt> as an
argument (note that <tt>rtsec.svl</tt> is already loaded): </p>

<pre>
    svl&gt; rootsec [ 'myfunc', -0.5, 0.5 ] 
    # of iterations: 2 
    root: 0 
    f(x1): 0 

    svl&gt; rootsec [ 'myfunc', 2, 1.5 ] 
    # of iterations: 6 
    root(s): 1.895494267 
    f(x) : 4.130029652e-13
</pre>

<p>There is a slightly more elegant way to implement the algorithm above:</p>

<pre>
    global function rootsec2 [f, x, dx]
	const MAX_ITERATIONS = 100;
	local y = call[f,x], dy = y - call[f,x-dx];

	for MAX_ITERATIONS
	while andE (abs [dx,y] > EPS_M) loop
	    [x, dx] = [x,0] - [y * dx / dy] ;
	    [y, dy] = [call[f,x]] - [0,y];
	endloop

	return x;
    endfunction
</pre>

<p>Function <tt>rootsec2</tt> is identical (in functionality)
to function <tt>rootsec</tt>, except for a few minor differences:
</p>
<center>
<table border="1" cellpadding="3">
    <tr>
	<th>item</th>
	<th>rootsec</th>
	<th>rootsec2</th>
    </tr>
    <tr>
	<td>function arguments</td>
	<td><tt>x1</tt>, <tt>x2</tt></td>
	<td><tt>x=x1</tt>, <tt>dx=x2-x1</tt></td>
    </tr>
    <tr>
	<td>use of constants</td>
	<td><tt>EPSILON</tt> and <tt>EPS_M</tt></td>
	<td>only <tt>EPS_M</tt></td>
    </tr>
    <tr>
	<td>iteration control</td>
	<td>loop index <tt>i</tt></td>
	<td>no loop index</td>
    </tr>
    <tr>
	<td>reporting result</td>
	<td>print out</td>
	<td>return</td>
    </tr>
</table>
</center>
<p>Both functions <tt>rootsec</tt> and <tt>rootsec2</tt> are scalar
functions:  they are capable of finding only one root at a time.  Function
<tt>rootsec3</tt> below, however, is not limited to scalar arguments: given a
vector of values for <tt>x</tt> and <tt>dx</tt>, it returns a vector of
corresponding results.</p>

<p>When examining <tt>rootsec3</tt>, you may notice that much of the code
has not changed; the vector nature of SVL operators often allows us to use
the same expressions regardless of the size and shape of the operands.
</p>
<p>There is, however, one significant difference between <tt>rootsec2</tt>
and <tt>rootsec3</tt>.  Since <tt>rootsec2</tt> handles only scalar
values, the iteration condition is a straightforward scalar expression.
<tt>rootsec3</tt>, on the other hand, iterates on a vector of values.
Values in the vector may satisfy looping termination conditions at
different times, therefore additional variables are needed to determine
which values should continue in the interaction:
</p>

<ul>
<li><tt>res</tt> stores the final result of the calculation</li>
<li><tt>idx</tt> stores the indices of the result that are not yet finished</li>
<li><tt>m</tt> stores the mask of values that are finished</li>
</ul>

<p>At the beginning of each iteration we test for values <i>x<sub>i</sub></i>
that should not continue in the iteration process and exclude them from
subsequent calculations.  Only values that are not yet finished
continue in the loop.  When all values are finished, the loop terminates.
</p>
<p>Function <tt>f</tt> must also be a vector function, i.e. be
able to accept a whole vector as its argument.  Function <tt>myfunc</tt> 
from above is such a function.
</p>
<pre>
    global function rootsec3 [f, x, dx]
	const MAX_ITERATIONS = 100;
	local y = call[f,x], dy = y - call[f,x-dx];
	local idx = x_id dy, res = x, m;

	for MAX_ITERATIONS
	while orE (m = andE (abs [dx,y] > EPS_M)) loop
	    res[idx] = x;
	    [idx,x,dx,y,dy] = [idx,x,dx,y,dy] || [m];
	    [x, dx] = [x,0] - [y * dx / dy] ;
	    [y, dy] = [call[f,x]] - [0,y];
	endloop

	return res;
    endfunction
</pre>


<p>The function can calculate multiple roots at once.
For example:</p>

<pre>
    svl> rootsec3 ['myfunc', igen 5 - 3, rep [1,5]]
    [-1.89549,-1.89549,0,0,1.89549]
</pre>

The function arguments, <tt>x</tt> and <tt>dx</tt>, unit-extend.  Instead
of explicitly replicating <tt>1</tt> five times in the argument of the
function, we can supply just <tt>1</tt>.  The function will
unit-extend the <tt>dx</tt> argument to the shape of the <tt>x</tt>
argument:

<pre>
    svl> rootsec3 ['myfunc', igen 5 - 3, 1]
    [-1.89549,-1.89549,0,0,1.89549]
</pre>

Although visually identical (when printed in the default precision), the
approximate roots found are not exactly the same:

<pre>
    svl> v = rootsec3 ['myfunc', igen 5 - 3, 1]
    svl> uniq v
    [-1.89549,-1.89549,0,1.89549]
</pre>

To find which of the solutions are the same within a given precision, we must
round the numbers to that precision:

<pre>
    svl> uniq round (v/1e-10) * 1e-10
    [-1.89549,0,1.89549]
</pre>


<h3><a name="Scripts">Scripts</a></h3>

<p>A <a href="../svl/manual/funcs.html">script</a> is a sequence
of commands not packaged as a function. When a script is loaded at the
command line (using the <tt>script</tt> command), the commands in the
script are executed as though the user had entered them at the command
line one-by-one. Create a file <tt>myscript.svl</tt> containing the
following script: </p>

<pre>
    rootsec ['myfunc', -0.5, 0.5];
    rootsec ['myfunc', 2, 1.5];
</pre>

<p>and then run it by typing at the SVL command line: </p>

<pre>
    svl&gt; script 'myscript.svl' 
</pre>

<p>You need to have the function <tt>rootsec</tt> already loaded (see
preceding section).  You should obtain the same output as that produced in the
previous section when you typed in the commands manually.</p>

<h3><a name="ExecutablePrograms">Executable Programs</a></h3>

<p>If a file contains a function called <tt>main</tt>, a program can be
executed without first loading the file in which it is found. As an example
of this, append the following line to your file <tt>mean.svl</tt>: </p>

<pre>
    local function main x = mean x;
</pre>

<p>At the SVL command line, type: </p>

<pre>
    svl&gt; run ['mean.svl', igen 5]
</pre>

You will obtain the same results as before when executing:

<pre>
    svl&gt; mean igen 5
</pre>

As an alternative, you can also include the following line in the file
(usually on the top of the file):

<pre>
    #set main 'mean'
</pre>

Note that the hash character (<tt>#</tt>) must be the first character
on the line.

<h3><a name="ErrorsandDebugging">Errors and Debugging</a></h3>

<p>SVL will flag all syntax errors both in expressions typed at
the command line and in functions when they are loaded and run.</p>

<p>For debugging code, we suggest typing at the command line as much as
possible to debug individual statements. When developing a function, use
the <tt>print</tt> and <tt>pr</tt> statements to monitor intermediate
results. Have every line perform one simple computation. Only after
thorough testing should you begin any attempt to make the code more
compact.</p>

<p>If you are running in a windows environment, the 
<a href="../moe/gui/modtasks.html">Crash History</a>
shows you exactly where errors have occurred in your
program. The command <tt>where</tt> furnishes the same information. </p>

<pre>
    svl&gt; where [] 
</pre>

<h3><a name="RecordingYourSVLSession">Recording Your SVL Session</a></h3>

<p>You can record your SVL session and save it to a file with the
following command: </p>

<pre>
    svl&gt; logfile 'logfilename' 
</pre>

<p>where <tt>'logfilename'</tt> is the name of your logfile, enclosed by
single quotes. To end the recording, type: </p>

<pre>
    svl&gt; logfile []
</pre>

<p><b>Note:</b> Any already existent file with the name <tt>logfilename</tt> will be
overwritten.</p>

<h3><a name="TokenPatternMatching">Token Pattern Matching</a></h3>

<p>The <tt>findmatch</tt> function performs token pattern matching.
The match syntax includes wildcards and simple set operations:</p>

<ul>
    <li><tt>*</tt> matches any number of characters</li>
    <li><tt>?</tt> matches exactly one character</li>
    <li><tt>@</tt> matches any character in <tt>[a..z,A..Z,_]</tt></li>
    <li><tt>#</tt> matches any digit</li>
    <li><tt>[<em>characters</em>]</tt>
	matches any of the <tt><em>characters</em></tt></li>
    <li><tt>[<em>^characters</em>]</tt> matches any character not in
        <tt><em>characters</em></tt></li>
    <li>any other character matches itself</li>
</ul>

<p>For example:</p>

<pre>
    svl&gt; findmatch [ '*', ['a','ab','abc'] ]
    ['a','ab','abc'] 

    svl&gt; findmatch ['a*', 'abc' ]
    'abc' 

    svl&gt; findmatch [ '*a', 'abc' ]             // returns [] 

    svl&gt; findmatch [ ['a*','*2'], 'abc' ]
    'abc' 

    svl&gt; findmatch [ ['a*','*2'], ['abc','12'] ]
    ['abc','12']

    svl&gt; findmatch [ ['a*','*2'], ['abc','12','a2','2a'] ]
    ['abc','12','a2'] 

    svl&gt; findmatch [ '?', ['a','2','xx'] ]
    ['a','2'] 

    svl&gt; findmatch [ '@#', ['a2','2a','aa','22'] ] 
    'a2'
</pre>

<p>The set operations allow specification of a set of characters, one of
which must be matched or none of which may be matched. </p>

<pre>
    svl&gt; findmatch [ 'x[123]', ['x','x1','x12','x4'] ]
    'x1' 

    svl&gt; findmatch ['x[a-c][1-4]', ['xb3','x3b'] ]
    'xb3' 

    svl&gt; findmatch [ 'x[^123]', ['x','x1','x12','x4'] ]
    'x4' 
</pre>

<h3><a name="PublicSymbolsManagement">Public Symbols Management</a></h3>

<p>Public symbols are the names of global functions, global variables, global
constants, and built-in SVL functions. You can query for the names of these
symbols or you can use SVL's cross-referencing tools to find out, for
instance, which variables are used in a file or which file contains a given
function declaration. </p>

<pre>
    svl&gt; sym_file 'main' // file containing function main
    'test.svl' 

    svl&gt; mod_exports ['test.svl','mypanel.svl']
    [['main','test'], 'mypanel'] // defined global functions
</pre>

<p>For more information, see 
<a class="svl" href="../svl/fcnref/symbol.htm">symbol</a> and 
<a class="svl" href="../svl/fcnref/symbol.htm">module</a> cross-referencing
functions.</p>

<h3><a name="ShellCommands">Shell Commands</a></h3>

<p>A limited set of shell-type commands are accessible from within SVL.
These include <tt>flist</tt>, which returns a list of files in the
current directory, and <tt>cd</tt>. </p>

<pre>
    svl&gt; flist []
    ['mean.svl','rtsec.svl'] 

    svl&gt; cd []   // inquire current directory
    /usr/mydir 

    svl&gt; cd '..' // change current directory
    svl&gt; cd [] 
    /usr
</pre>

<h3>See Also</h3>

<p><a href="../fcnindex.html">SVL Function Index</a><br />
<a href="../svl/manual/index.html">SVL Manual</a></p>

<p><a href="../index.htm">MOE Table of Contents</a></p>
<hr noshade="noshade" />
<a href="http://www.chemcomp.com"><img src="../images/flogo.gif"
alt="CCG Logo"
align="left" width="30" height="30" border="1" hspace="5" vspace="3" /></a>
<font size="2">
<a href="../legal.html">Copyright</a> &copy; 1997-2010
<a href="http://www.chemcomp.com">Chemical Computing Group Inc.</a><br />
<a href="mailto:info@chemcomp.com"><i>info@chemcomp.com</i></a>
</font>
</body>
</html>
