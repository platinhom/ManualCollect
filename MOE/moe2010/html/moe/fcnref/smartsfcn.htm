<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<!--
!!    MOE 2010.10 On-Line Manuals
!!    COPYRIGHT (C) 2010
!!        CHEMICAL COMPUTING GROUP INC.  ALL RIGHTS RESERVED.
!!-->

<!--
!!	smartsfcn.htm			SMARTS functions
!!
!!	07-oct-2008 (kk) minor edits
!!	12-jan-2008 (pl) created
!!
!! delete: introsm.html, sm_dict.html, sm_syntax.html
!! eliminated function: sm_StringRoot
!!
!!-->

<head>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<link rel="stylesheet" type="text/css"
href="../../manstyle.css" />


<meta keywords>
<meta functions sm_Indexof, sm_Match, sm_MatchAtoms, sm_MatchAll>
<meta functions sm_MatchSyntax, sm_MatchSyntaxError, sm_MatchAtomCount>
<meta functions SMARTS, SMARTS_TABLE>

<meta obsolete sm_Create, sm_Destroy, sm_Define, sm_Undefine>

<style type="text/css">
blockquote.metasyntax {
   text-indent: 5em;
   font-family: monospace
}
</style>


<title>SMARTS Functions</title>
</head>

<body bgcolor="#ffffff">
<a href="../../index.htm"><img src="../../images/logo.gif"
alt="CCG Logo" align="right" width="174" height="55" border="0" /></a>
<h4>MOE 2010.10</h4>
<h2>SMARTS Functions</h2>
<hr noshade="noshade" />

<h2>Syntax</h2>

<pre>
    indices = <a class="fcnlink" href="#sm_Indexof">sm_Indexof</a> [ atomkeys, smarts_tables, dictlist ]
    numbers = <a class="fcnlink" href="#sm_Match">sm_Match</a>   [ smarts_table , atomkeys, dictlist ]

    dictlist = [ dict, ... ]
    dict = [ dname : smarts_table, ...  ]
</pre>

<blockquote class="metasyntax">
<table>
<tr>
<td valign="baseline"><i>smarts_table</i>
</td>
<td valign="baseline">:&nbsp;
</td>
<td valign="baseline"><tt><b>[</b></tt>
    <i>item</i> <tt><b>,</b></tt> ...  <tt><b>]</b></tt>
</td>
</tr>
<tr>
    <td valign="baseline"><i>item</i></td><td valign="baseline">:</td>
    <td valign="baseline"><i>number</i>
    &nbsp;|&nbsp;
    <tt><b>'</b></tt> <i>smarts</i> <tt><b>'</b></tt>
    &nbsp;|&nbsp;
    <tt><b>[</b></tt>
	<tt><b>'</b></tt> <i>smarts</i> <tt><b>'</b></tt>
	<tt><b>,</b></tt> <i>smarts_table</i>
    <tt><b>]</b></tt></td>
</tr>
</table>
</blockquote>

<pre>
    atomkey_lists = <a class="fcnlink" href="#sm_MatchAtoms">sm_MatchAtoms</a> [ smarts_token, atomkeys, dictlist ]
    atomkey_lists = <a class="fcnlink" href="#sm_MatchAll">sm_MatchAll</a>   [ smarts_token, atomkeys, dictlist ]

    smarts_tokens = <a class="fcnlink" href="#SMARTS">SMARTS</a> smarts_tokens
    smarts_table  = <a class="fcnlink" href="#SMARTS_TABLE">SMARTS_TABLE</a> smarts_table

    numbers       = <a class="fcnlink" href="#sm_MatchAtomCount">sm_MatchAtomCount</a> smarts_tokens
    flags         = <a class="fcnlink" href="#sm_MatchSyntax">sm_MatchSyntax</a> smarts_tokens
    err_tokens    = <a class="fcnlink" href="#sm_MatchSyntaxError">sm_MatchSyntaxError</a> smarts_tokens
</pre>

<blockquote class="metasyntax"><table>

<tr>
    <td valign="baseline"><i>smarts</i></td>
    <td valign="baseline">:&nbsp;</td>
    <td valign="baseline"><i>atom</i> <i>sub</i>*
    </td>
</tr>
<tr>
    <td valign="baseline"><i>sub</i></td>
    <td valign="baseline">:&nbsp;</td>
    <td valign="baseline"><i>bond</i>* <i>atom</i>
    &nbsp;|&nbsp; <i>bond</i>* <i>label</i>
    &nbsp;|&nbsp; <tt><b>(</b></tt> <i>sub sub</i>* <tt><b>)</b></tt>
    </td>
</tr>
<tr>
    <td valign="baseline"><i>bond</i></td>
    <td valign="baseline">:&nbsp;</td>
    <td valign="baseline"><tt><b>!</b></tt>* [<tt><b>-=#$:@/\~</b></tt>]
    </td>
</tr>
<tr>
    <td valign="baseline"><i>label</i></td>
    <td valign="baseline">:</td>
    <td valign="baseline"><i>digit</i> &nbsp;|&nbsp; <tt><b>%</b></tt> <i>digit digit</i>
    </td>
</tr>
<tr>
    <td valign="baseline"><i>atom</i></td>
    <td valign="baseline">:&nbsp;</td>
    <td valign="baseline"><i>orgsym</i>
    &nbsp;|&nbsp; <tt><b>*</b></tt>
    &nbsp;|&nbsp; <tt><b>a</b></tt>
    &nbsp;|&nbsp; <tt><b>A</b></tt>
    &nbsp;|&nbsp; <tt><b>[</b></tt> <i>expr</i> <tt><b>]</b></tt>
    </td>
</tr>
<tr>
    <td valign="baseline"><i>orgsym</i></td>
    <td valign="baseline">:</td>
    <td valign="baseline">
		      <tt><b>C</b></tt>
	&nbsp;|&nbsp; <tt><b>N</b></tt>
	&nbsp;|&nbsp; <tt><b>O</b></tt>
	&nbsp;|&nbsp; <tt><b>F</b></tt>
	&nbsp;|&nbsp; <tt><b>P</b></tt>
	&nbsp;|&nbsp; <tt><b>S</b></tt>
	&nbsp;|&nbsp; <tt><b>Cl</b></tt>
	&nbsp;|&nbsp; <tt><b>Br</b></tt>
	&nbsp;|&nbsp; <tt><b>I</b></tt>
    </td>
</tr>
<tr>
    <td valign="baseline">&nbsp;</td>
    <td valign="baseline">:</td>
    <td valign="baseline">
		      <tt><b>c</b></tt>
	&nbsp;|&nbsp; <tt><b>n</b></tt>
	&nbsp;|&nbsp; <tt><b>o</b></tt>
	&nbsp;|&nbsp; <tt><b>f</b></tt>
	&nbsp;|&nbsp; <tt><b>p</b></tt>
	&nbsp;|&nbsp; <tt><b>s</b></tt>
	&nbsp;|&nbsp; <tt><b>cl</b></tt>
	&nbsp;|&nbsp; <tt><b>br</b></tt>
	&nbsp;|&nbsp; <tt><b>i</b></tt>
    </td>
</tr>
<tr>
    <td valign="baseline"><i>expr</i></td><td valign="baseline">:&nbsp;</td>
    <td valign="baseline"><i>term</i> ... <i>term</i>
    &nbsp;|&nbsp; <i>expr</i> <tt><b>;</b></tt> <i>expr</i>
    &nbsp;|&nbsp; <i>expr</i> <tt><b>,</b></tt> <i>expr</i>
    &nbsp;|&nbsp; <i>expr</i> <tt><b>&amp;</b></tt> <i>expr</i>
    </td>
</tr>
<tr>
    <td valign="baseline"><i>term</i></td>
    <td valign="baseline">:&nbsp;</td>
    <td valign="baseline"><tt><b>!</b></tt> <i>term</i>
</tr>
<tr>
    <td valign="baseline">&nbsp;</td><td valign="baseline">:&nbsp;</td>
    <td valign="baseline">	  <tt><b>He</b></tt>
    &nbsp;|&nbsp; <tt><b>Li</b></tt>
    &nbsp;|&nbsp; <tt><b>Be</b></tt>
    &nbsp;|&nbsp; <tt><b>B</b></tt>
    &nbsp;|&nbsp; <tt><b>C</b></tt>
    &nbsp;|&nbsp; <tt><b>N</b></tt>
    &nbsp;|&nbsp; ...
    &nbsp;|&nbsp; <tt><b>b</b></tt>
    &nbsp;|&nbsp; <tt><b>c</b></tt>
    &nbsp;|&nbsp; <tt><b>n</b></tt>
    &nbsp;|&nbsp; ...
    &nbsp;|&nbsp; <tt><b>*</b></tt>
    &nbsp;|&nbsp; <tt><b>a</b></tt>
    &nbsp;|&nbsp; <tt><b>A</b></tt>
    </td>
</tr>
<tr>
    <td valign="baseline">&nbsp;</td><td valign="baseline">:&nbsp;</td>
    <td valign="baseline">
    		  <tt><b>#</b></tt> <i>integer</i>
    &nbsp;|&nbsp; <tt><b>#</b></tt> [<tt><b>GMNOQRSTX</b></tt>]
    &nbsp;|&nbsp; <tt><b>#</b></tt> [<tt><b>GMORST</b></tt>] <i>digits</i>
    </td>
</tr>
<tr>
    <td valign="baseline">&nbsp;</td><td valign="baseline">:&nbsp;</td>
    <td valign="baseline">
    <tt><b>+</b></tt>
    &nbsp;|&nbsp;
    <tt><b>++</b></tt>
    &nbsp;|&nbsp;
    <tt><b>+++</b></tt>
    &nbsp;|&nbsp;
    ...
    &nbsp;|&nbsp;
    <tt><b>+*</b></tt>
    &nbsp;|&nbsp;
    <tt><b>+</b></tt> <i>digits</i>
    </td>
</tr>
<tr>
    <td valign="baseline">&nbsp;</td><td valign="baseline">:&nbsp;</td>
    <td valign="baseline">
    <tt><b>-</b></tt>
    &nbsp;|&nbsp;
    <tt><b>--</b></tt>
    &nbsp;|&nbsp;
    <tt><b>---</b></tt>
    &nbsp;|&nbsp;
    ...
    &nbsp;|&nbsp;
    <tt><b>-*</b></tt>
    &nbsp;|&nbsp;
    <tt><b>-</b></tt> <i>digits</i>
    </td>
</tr>
<tr>
    <td valign="baseline">&nbsp;</td><td valign="baseline">:&nbsp;</td>
    <td valign="baseline">
    [<tt><b>DHLQXhrvix</b></tt>] <i>digits</i>
    &nbsp;|&nbsp;
    [<tt><b>DHLQXhrvix</b></tt>]
    </td>
</tr>
<tr>
    <td valign="baseline">&nbsp;</td><td valign="baseline">:&nbsp;</td>
    <td valign="baseline">
    <tt><b>$(</b></tt> <i>smarts</i> <tt><b>)</b></tt>
    &nbsp;|&nbsp;
    <tt><b>$</b></tt> <i>dname</i>
    </td>
</tr>
<tr>
    <td valign="baseline"><i>dname</i></td>
    <td valign="baseline">:</td>
    <td valign="baseline">[<tt><b>A-Za-z_</b></tt>] [<tt><b>A-Za-z_0-9</b></tt>]<sup>*</sup>
    </td>
</tr>

</table></blockquote>

<h3 class="obsolete">Obsolete</h3>

<pre>
    dictkey       = <a class="fcnlink" href="#sm_Create">sm_Create</a> dict
    old_dict      = <a class="fcnlink" href="#sm_Define">sm_Define</a> [dictkey, dict]
    old_dict      = <a class="fcnlink" href="#sm_Undefine">sm_Undefine</a> [dictkey, dname_tokens]
    <a class="fcnlink" href="#sm_Destroy">sm_Destroy</a> dictkeys
</pre>

<p>These functions are obsolete now that
<tt>sm_Match</tt>, <tt>sm_MatchAtoms</tt> and <tt>sm_MatchAll</tt>
accept a tagged-vector dictionary directly in their
argument lists.
</p>


<h2>Description</h2>

<p>
The SMARTS pattern language is a variation of SMILES [Weininger&nbsp;1988] and
is used to search the current molecular system in MOE.
SMARTS patterns are strings of characters that encode specific atomic and
connectivity properties.
The results of the search can be either integer values (for use in atom
typing applications) or the specific atoms that match the substructure
specified by the SMARTS pattern.  We describe the syntax and semantics
of the SMARTS patterns first.
</p>

<p>
<span class="tip"><b>Note!</b></span>
The space and tab characters are not permitted in SMARTS
patterns; thus, any spaces that appear in the syntax descriptions are
for exposition purposes and are not part of the SMARTS pattern itself.
</p>

<p>
<b>Atom Patterns</b>.
Fundamentally, a SMARTS string encodes a molecular substructure each atom
of which satisfies certain properties specified in the SMARTS string.  
Properties not specified in the string are not checked and are treated
as &quot;don't care.&quot; For instance, if the number of attached hydrogens
is not specified, a matching atom is permitted any number of attached hydrogens.

An atom is specified with one of the following:
<blockquote>
<table class="titlebar" border="1" cellpadding="3">
<tr>
<th>SMARTS</th>
<th>Description</th>
</tr>
<tr>
<td valign="baseline"><tt><b>*</b></tt></td>
<td valign="baseline">Matches any atom in the molecular system &mdash; this is the
&quot;wildcard&quot; symbol.</td>
</tr>
<tr>
<td valign="baseline"><tt><b>a</b></tt></td>
<td valign="baseline">Matches any aromatic atom in the molecular system.  The aromaticity
definition is not the same as the Daylight definition.  The <tt><b>a</b></tt>
symbol matches any atom for which <tt>aInHRing</tt> returns true.
For example, <tt><b>a</tt></b> will match carbon in benzene but not in
a vinyl group.
</tr>
<tr>
<td valign="baseline"><tt><b>A</b></tt></td>
<td valign="baseline">Matches any non-aromatic atom in the molecular system.  The aromaticity
definition is not the same as the Daylight definition.  The <tt><b>A</b></tt>
symbol matches any atom for which <tt>aInHRing</tt> returns false.
For example, <tt><b>A</tt></b> will match carbon in vinyl but not in
benzene.
</tr>
<tr>
<td valign="baseline"><i>orgsym</i>
<td valign="baseline">One of {C,N,O,F,P,S,Cl,Br,I},
either upper or lower case, to match
against the element property of the atom.
If the first character of <i>orgsym</i> is in lower case then only
aromatic atoms will match (as with <tt><b>a</b></tt>, above).
If the first character <i>orgsym</i> is in upper case then only
non-aromatic atoms will match (as with <tt><b>A</b></tt>, above).
The second letter of the element symbol, if any, must be in lower case.
For example,
<tt><b>C</tt></b> will match carbon in vinyl but not in benzene and
<tt><b>c</tt></b> will match carbon in benzene but not in vinyl.
</tr>
<tr>
<td valign="baseline"><tt><b>[</b></tt> <i>expr</i> <b>]</b></tt></td>
<td valign="baseline">Matches a single atom that satisfies the properties specified by the
boolean expression <i>expr</i>.
The <i>expr</i> encodes a boolean expression using:
<i>expr</i>&nbsp;<tt><b>;</b></tt>&nbsp;<i>expr</i> (semicolon) and
<i>expr</i>&nbsp;<tt><b>&amp;</b></tt>&nbsp;<i>expr</i> (ampersand)
for logical AND, and
<i>expr</i>&nbsp;<tt><b>,</b></tt>&nbsp;<i>expr</i> (comma) for logical OR.
The semicolon has lowest precedence and the ampersand has highest precedence;
thus, the &quot;<tt>[C;N,O&amp;*</tt>]&quot; has the implied
parentheses &quot;(C AND (N OR (O AND *)))&quot;.
Also, any <i>expr</i> in the boolean expression may be a concatenation of
atom properties <i>term</i> ... <i>term</i> (described below) interpreted
as a sequence of high precedence (ampersand) AND operations.  Each
individual <i>term</i> may be preceded by the <tt><b>!</b></tt> character,
interpreted as logical NOT.
</td>
</table></blockquote>

<p>
The individual <i>term</i> items in bracketed atom specifications are
used to specify values of atom properties:
<blockquote>
<table class="titlebar" border="1" cellpadding="3">
<tr>
<th><i>term</i></th>
<th>Description</th>
</tr>
<tr>
<td valign="baseline"><tt><b>*<br />a<br>A</b></tt><br><i>element</i></td>
<td valign="baseline">One or two character periodic table element symbol except H and Lp.
Uppercase and lowercase encode aromaticity as in the unbracketed case
(see above).</td>
</tr>

<tr>
<td valign="baseline"><tt><b>#</b></tt>&nbsp;<i>digits</i>
<td valign="baseline">An atom will match if its atomic number is that specified by <i>digits</i>.
Lone pairs have atomic number zero.</td>
</tr>
</tr>
<tr>
<td valign="baseline"><tt><b>#G</b></tt>&nbsp;<i>digit</i><br /><tt><b>#G</b></tt>
<td valign="baseline">Matches an atom if it is in group IA, IIA, ..., VIIIA
as specified by <i>digit</i> (i.e. not including transition metals).
The <i>digit</i> may be omitted in which case
all non-transition elements are specified.
</tr>
<tr>
<td valign="baseline"><tt><b>#M</b></tt>&nbsp;<i>digit</i><tt><br /><b>#M</b></tt>
<td valign="baseline">Matches an atom if it is a metal and in
group I, II, ..., VIII as specified by <i>digit</i>.  The
<i>digit</i> may be omitted in which case any metal will match.
Transition metals are considered to be in group II.</td>
</tr>
<tr>
<td valign="baseline"><tt><b>#N</b></tt>
<td valign="baseline">Matches an electronegative element {O, N, F, Cl, Br}, aromatic or not.</td>
</tr>
<tr>
<td valign="baseline"><tt><b>#O</b></tt>&nbsp;<i>digit</i><tt><br /><b>#O</b></tt>
<td valign="baseline">Matches an atom if it is organic and in
group I, II, ..., VIII as specified by <i>digit</i>.  The
<i>digit</i> may be omitted in which case any organic atom will match.</td>
</tr>
<tr>
<td valign="baseline"><tt><b>#Q</b></tt>
<td valign="baseline">An atom will match if its atomic number is greater than 1, aromatic or not.
</td>
</tr>
<tr>
<td valign="baseline"><tt><b>#R</b></tt>&nbsp;<i>digit</i><br />
<td valign="baseline">Matches an atom if it is in the periodic table row
(starting with 1) specified by <i>digit</i>.
</tr>
<tr>
<td valign="baseline"><tt><b>#S</b></tt>&nbsp;<i>digit</i><tt><br /><b>#S</b></tt>
<td valign="baseline">Matches an atom if it is a semi-metal and in
group I, II, ..., VIII as specified by <i>digit</i>.  The
<i>digit</i> may be omitted in which case any semi-metal will match.</td>
</tr>
<tr>
<td valign="baseline"><tt><b>#T</b></tt>&nbsp;<i>digit</i><tt><br /><b>#T</b></tt>
<td valign="baseline">Matches an atom if it is a transition metal and in
group IB, IIB, ..., VIIIB as specified by <i>digit</i>.  The
<i>digit</i> may be omitted in which case any transition metal will match.</td>
</tr>
<tr>
<td valign="baseline"><tt><b>#X</b></tt>
<td valign="baseline">Matches non-carbon non-hydrogen atoms (including lone pairs),
aromatic or not.</td>
</tr>
<tr>
<td valign="baseline"><tt><b>D</b></tt>&nbsp;<i>digit</i><tt><br /><b>D</b></tt>
<td valign="baseline">Explicit Degree &mdash;
matches an atom provided that the number of explicit atoms bonded to it
equals the number specified by <i>digit</i>.
If <i>digit</i> is omitted, then one is taken as the default.
Implicit hydrogens and lone pairs are ignored.</td>
</tr>
<tr>
<td valign="baseline"><tt><b>H</b></tt>&nbsp;<i>digit</i><tt><br /><b>H</b></tt>
<td valign="baseline">
Hydrogen Count &mdash;
matches an atom provided that its number of attached hydrogens
(both explicit and implicit) equals the value specified by <i>digit</i>.
If <i>digit</i> is omitted, then one is taken as the default.</td>
</tr>
<tr>
<td valign="baseline"><tt><b>h</b></tt>&nbsp;<i>digit</i><tt><br /><b>h</b></tt>
<td valign="baseline">
Implicit Hydrogen Count &mdash;
matches an atom provided that its implicit hydrogen count equals the value
specified by <i>digit</i>.  If <i>digit</i> is omitted, then one is
taken as the default.</td>
</tr>
<tr>
<td valign="baseline"><tt><b>i</b></tt></td>
<td valign="baseline">
&pi; Bonding &mdash;
matches an atom provided that it is participating in a &pi; bond (non-single).
</td>
</tr>
<tr>
<td valign="baseline"><tt><b>i</b></tt>&nbsp;<i>digit</i>
<td valign="baseline">
Aromatic &pi; Electrons &mdash;
matches an atom provided that it is aromatic (matches <tt>a</tt>) and
donates <i>digit</i> electrons to the &pi; system.  Pyrrole N matches
<tt>i2</tt> and pyridine N matches <tt>i1</tt>.</td>
</tr>
<tr>
<td valign="baseline"><tt><b>L</b></tt>&nbsp;<i>digit</i><tt><br /><b>L</b></tt>
<td valign="baseline">
Lone Pair Count &mdash;
matches an atom provided that its &sigma; lone pair count (both
explicit and implicit) equals the number specified by <i>digit</i>.
If <i>digit</i> is omitted, then one is taken as the default.</td>
</tr>
<tr>
<td valign="baseline"><tt><b>Q</b></tt>&nbsp;<i>digit</i><tt><br /><b>Q</b></tt>
<td valign="baseline">
Heavy Atom Connectivity &mdash;
matches an atom provided that the number of atoms with atomic number
greater that 1 bonded to it equals the number specified by <i>digit</i>.
If <i>digit</i> is omitted, then one is taken as the default.  </td>
</tr>
<tr>
<td valign="baseline"><tt><b>q</b></tt>&nbsp;<i>digit</i><tt><br /><b>q</b></tt>
<td valign="baseline">
Ring Degree &mdash;
matches an atom provided that the number of its bonds that are in rings
equals the number specified by <i>digit</i>.
If <i>digit</i> is omitted, then one is taken as the default.  </td>
</tr>
<tr>
<td valign="baseline"><tt><b>r</b></tt>&nbsp;<i>digit</i><tt><br /><b>r</b></tt>
<td valign="baseline">
Ring Size Membership &mdash;
matches an atom provided that it is a member of a ring of size
specified by <i>digit</i>.
If <i>digit</i> is omitted then an atom will match if it is in a ring
of any size.</td>
</tr>
<tr>
<td valign="baseline"><tt><b>v</b></tt>&nbsp;<i>digit</i><tt><br /><b>v</b></tt>
<td valign="baseline">
Sum of Bond Orders &mdash;
matches an atom provided that the sum of the orders of its bonds is
equal to the number specified by <i>digit</i>.
If <i>digit</i> is omitted then one is taken as the default.
Implicit hydrogens are taken into account and all lone pairs are ignored.
Charge-separated notation is locally converted to extended valence notation
so that in nitro groups, N matches <tt>v5</tt> and both O atoms match
<tt>v2</tt> even if the underlying representation is <tt>N(=O)[O-]</tt>.</td>
</tr>
<tr>
<td valign="baseline"><tt><b>X</b></tt>&nbsp;<i>digit</i><tt><br /><b>X</b></tt>
<td valign="baseline">
Connectivity &mdash;
matches an atom provided that the number of atoms bonded to it
&mdash; including implicit hydrogens and ignoring all lone pairs &mdash;
equals the number specified by <i>digit</i>.
If <i>digit</i> is omitted, then one is taken as the default.  </td>
</tr>
<tr>
<td valign="baseline"><tt><b>-*</b></tt></td>
<td valign="baseline">
Negative &mdash;
matches an atom provided that its formal charge (as returned by
<tt>aFCharge</tt>) is less than zero.
</tr>
<tr>
<td valign="baseline"><tt><b>-</b></tt>&nbsp;<i>digit</i>
<br /><tt><b>-</b></tt>&nbsp;&nbsp;<tt><b>--</b></tt>
<td valign="baseline">
Negative Charge &mdash;
matches an atom provided that its negative formal charge equals the number
specified by <i>digit</i>; the <tt>-</tt>, <tt>--</tt> variants are
shorthands for <tt>-1</tt>, <tt>-2</tt>, etc.  </td>
</tr>
<tr>
<td valign="baseline"><tt><b>+*</b></tt></td>
<td valign="baseline">
Positive &mdash;
matches an atom provided that its formal charge (as returned by
<tt>aFCharge</tt>) is greater than zero.
</tr>
<tr>
<td valign="baseline"><tt><b>+</b></tt>&nbsp;<i>digit</i>
<br /><tt><b>+</b></tt>&nbsp;&nbsp;<tt><b>++</b></tt>
<td valign="baseline">
Positive Charge &mdash;
matches an atom provided that its formal charge equals the number
specified by <i>digit</i>; the <tt>+</tt>, <tt>++</tt> variants are
shorthands for <tt>+1</tt>, <tt>+2</tt>, etc.  </td>
</tr>
<tr>
<td valign="baseline"><tt><b>$(</b></tt>&nbsp;<i>smarts</i>&nbsp;<tt><b>)</b></tt>
<td valign="baseline">
Recursive SMARTS &mdash;
matches an atom provided that the atom would also be the first atom
in a successful independent match of the given <i>smarts</i> pattern.
</tr>
<tr>
<td valign="baseline"><tt><b>$</b></tt>&nbsp;<i>dname</i>
<td valign="baseline">
Dictionary SMARTS &mdash;
matches an atom provided that the atom would also return a non-zero value
from an independent <tt>sm_Match</tt> against the match vector associated
with <i>dname</i> in a dictionary.  If <i>dname</i> is not in the
dictionary then the atom is deemed not to match.
</tr>
</table></blockquote>

<p>
If a two character element symbol starts a <i>term</i> then the element
interpretation takes precedence over other interpretations; for example,
<tt>[Ar]</tt> matches argon and not an aliphatic ring atom which should
be matched with <tt>[A&amp;r]</tt>.  One letter element symbol conflicts
resolve in favor of the property test and not the element; thus,
aromatic iodine cannot be matched with <tt>[i]</tt> but with <tt>[a#53]</tt>.
Examples of SMARTS patterns and the atoms they match are
<blockquote>
<table cellpadding="3" border="0">
<tr>
<td valign="baseline"><tt>[#6]</tt>
<td valign="baseline">matches any carbon
</tr>
<tr>
<td valign="baseline"><tt>[#1]</tt>
<td valign="baseline">matches any hydrogen
</tr>
<tr>
<td valign="baseline"><tt>[H]</tt>
<td valign="baseline">matches any atom with one attached hydrogen (implicit or explicit)
</tr>
<tr>
<td valign="baseline"><tt>[CX4H3]</tt>
<td valign="baseline">matches any methyl carbon (implicit or explicit hydrogens)
</tr>
<tr>
<td valign="baseline"><tt>[n]</tt>
<td valign="baseline">matches any aromatic nitrogen.
</tr>
<tr>
<td valign="baseline"><tt>[n;i2]</tt>
<td valign="baseline">matches any aromatic pyrrole type nitrogen &mdash; <tt>[ni2]</tt> would
start with nickel.
</tr>
<tr>
<td valign="baseline"><tt>[N!i]</tt>
<td valign="baseline">matches nitrogen not &pi; bonded.
</tr>
<tr>
<td valign="baseline"><tt>[!#X]</tt>
<td valign="baseline">matches any non-{C,H} atom, including lone pairs.
</tr>
<tr>
<td valign="baseline"><tt>[Ov2X1]</tt>
<td valign="baseline">matches oxygen in sulfones, nitroxides, carbonyl, nitros, etc.
</tr>
<tr>
<td valign="baseline"><tt>[q3+0]</tt>
<td valign="baseline">matches neutral atom participating in 3 ring bonds.
</tr>
<tr>
<td valign="baseline"><span class="nobr"><tt>[NQ4+!$([Nv5])]</tt></span>
<td valign="baseline">matches quaternary nitrogen but not in nitroxide.
</tr>
<tr>
<td valign="baseline"><tt>[N,O,S;-]</tt>
<td valign="baseline">matches -1 formal charged non-aromatic nitrogen, oxygen or sulfur.
</tr>
</table></blockquote>

<p>
Atom patterns can become quite complex; the order of the individual terms
can determine the matching performance.  The recursive matches starting
with <tt><b>$</b></tt> are the most time consuming and, for maximum
performance, care should be taken to perform these after other tests.
For example, a pattern of the form <tt>[</tt><i>AB</i><tt>]</tt> is such
that if <i>A</i> is false then the value of <i>B</i> will not affect
the outcome; thus, better performance can be achieved if <i>A</i> is a
simpler term than <i>B</i>.

<p>
<b>Bond Patterns</b>.
Bonds are matched between adjacent atoms in a SMARTS string and two atoms
will match a pattern if and only if both atom specifications match and
the bond connecting them satisfies the bond pattern.  A bond expression
can appear prior to any atom expression (except the first atom) or prior
to a ring closure label (see below).  The following symbols are used
to encode bond orders:

<blockquote>
<table class="titlebar" border="1" cellpadding="3">
<tr>
<th><i>bond</i></th>
<th>Description</th>
</tr>
<tr>
<td valign="baseline"><tt><b>-</b></tt></td>
<td valign="baseline">Non-aromatic single bond</td>
<tr>
<td valign="baseline"><tt><b>=</b></tt></td>
<td valign="baseline">Non-aromatic double bond</td>
<tr>
<td valign="baseline"><tt><b>#</b></tt></td>
<td valign="baseline">Non-aromatic triple bond</td>
<tr>
<td valign="baseline"><tt><b>$</b></tt></td>
<td valign="baseline">Non-aromatic quadruple bond</td>
<tr>
<td valign="baseline"><tt><b>:</b></tt></td>
<td valign="baseline">Aromatic bond</td>
<tr>
<td valign="baseline"><tt><b>@</b></tt></td>
<td valign="baseline">Ring bond, any bond order</td>
<tr>
<td valign="baseline"><tt><b>~</b></tt></td>
<td valign="baseline">Any bond order &mdash; matches any bond</td>
</table></blockquote>

<p>
Any of the above bond orders may be preceded by any number of logical NOT
operators designated by the <tt>!</tt> character; an odd number of such
negations will invert the sense of the bond order.  For example,
<tt>!-</tt> means &quot;any bond except non-aromatic single&quot; and
<tt>!@</tt> means &quot;any non-ring bond&quot;.
<p>
A bond pattern is a concatenation of any number of the above (possibly
negated) <i>bond</i> symbols and all of the implied tests must be satisfied
in order for a bond to match.  For example, <tt>!-!#</tt> means
&quot;non-single non-triple&quot; and would match aromatic, double, and
quadruple bonds and <tt>!~</tt> won't match any bond.
If no bond symbols are specified (an empty bond pattern) then the implied
bond test is &quot;non-aromatic single bond or aromatic bond&quot;
(<tt>-</tt> or <tt>:</tt>).
Examples of SMARTS patterns with bond expressions are
<blockquote>
<table cellpadding="3" border="0">
<tr>
<td valign="baseline"><tt>CC</tt>
<td valign="baseline">matches any two aliphatic carbons singly bonded to each other
</tr>
<tr>
<td valign="baseline"><tt>cc</tt>
<td valign="baseline">matches any two connected aromatic carbons bonded with a single
bond (as in biphenyl) or an aromatic bond (as in benzene)
</tr>
<tr>
<td valign="baseline"><tt>C=O</tt>
<td valign="baseline">matches any carbonyl carbon
</tr>
<tr>
<td valign="baseline"><span class="nobr"><tt>[#6]!-[#7]</tt></span>
<td valign="baseline">matches any carbon &pi; bonded to a nitrogen (aromatic or not)
</tr>
<tr>
<td valign="baseline"><tt>[#6]@[#7]</tt>
<td valign="baseline">matches any carbon bonded in a ring to a nitrogen with any bond order
</tr>
<tr>
<td valign="baseline"><tt>C!-!@C</tt>
<td valign="baseline">matches any carbon &pi; bonded, not in a ring, to another carbon
</tr>
<tr>
<td valign="baseline"><tt>NC=O</tt>
<td valign="baseline">matches any nitrogen singly bonded to carbonyl group
</tr>
<tr>
<td valign="baseline"><span class="nobr"><tt>[NX2]#[CX1]</tt></span>
<td valign="baseline">matches an isonitrile group
</tr>
</table></blockquote>

<p>
<b>Branches and Rings</b>.
Atoms and bonds belonging to a branch are enclosed in parentheses. The last
branch attached to an atom, however, need not be thus enclosed.  A branch
may not appear at the start of a SMARTS string.  Branches can appear
inside other branches.  For example,

<blockquote><table cellpadding="3">
<tr>
<td valign="baseline"><tt>CC(=O)O</tt>
<td valign="baseline">matches an acetic acid substructure (ionized or neutral)
</tr>
<tr>
<td valign="baseline"><tt>C(F)(F)F</tt>
<td valign="baseline">matches a trifluoromethyl CF<sub>3</sub> group
</tr>
<tr>
<td valign="baseline"><tt>[Nv3](CC)(CC)CC</tt>
<td valign="baseline">matches a triethyl amine group
</tr>
<tr>
<td valign="baseline"><tt>[Sv6X4](~[OX1])([~OX1])</tt>
<td valign="baseline">matches a sulfone group
</tr>
<tr>
<td valign="baseline"><tt>N(C(C)=O)[Sv6X4](~[OX1])(~[OX1])C</tt>
<td valign="baseline">matches an acyl sulfonamide group
</tr>
</table></blockquote>

<p>
Rings are encoded using a combination of branches and ring closure labels.
A label is a number specified with either a single digit or two digits
preceded by the <tt><b>%</b></tt> symbol.  A label is used to specify
a bond between non-adjacent atoms in the branching structure of the
SMARTS string (in cyclic structures or cross-branch connections).
Syntactically, a label takes the place of an atom substituent and bond
expressions may precede the label; labels need not be adjacent to their
atoms and more than one label can be attached to a single atom.
For example,

<blockquote><table cellpadding="3">
<tr>
<td valign="baseline"><tt>C1CCCCC1</tt>
<td valign="baseline">matches a cyclohexane substructure
</tr>
<tr>
<td valign="baseline"><tt>[n;i2]1c[n;i1]cc1</tt>
<td valign="baseline">matches an imidazole substructure
</tr>
<tr>
<td valign="baseline"><tt>[n;i2;!$(n1cncc1)]</tt>
<td valign="baseline">matches an aromatic nitrogen not in an imidazole group
</tr>
<tr>
<td valign="baseline"><tt>c12c(cccc1)cccc2</tt>
<td valign="baseline">matches a naphthalene substructure
</tr>
<tr>
<td valign="baseline"><tt>c1ccccc1c%12ccccc%12</tt>
<td valign="baseline">matches a biphenyl substructure
</tr>
<tr>
<td valign="baseline"><tt>C=1([OH])CCCCC=1</tt>
<td valign="baseline">matches a cyclohexenol substructure
</tr>
</table></blockquote>

<p>
Labels appear in pairs in SMARTS strings (once for each atom involved in the
bond) and consequently, their preceding bond expressions must both match a
substructure.  The same label number can be used for more than one bond.
Note that while the labels are syntactically similar to atoms, they do not
correspond to atoms themselves, only the bond connecting other atoms in
the branch structure of the SMARTS string.

<p><a name="SMARTS"></a></p><p><hr noshade="noshade" /></p>
<pre>smarts_tokens = <span class="fcndef">SMARTS</span> smarts_tokens
</pre>
<p>
The <tt>SMARTS</tt> function returns its argument provided that it contains
solely syntactically correct SMARTS tokens (possibly nested) and generates
an error otherwise.  The <tt>SMARTS</tt> function is most useful to ensure
that SVL programs contain legal smarts patterns.  For example,
<blockquote><pre>
flags = sm_MatchAtoms [SMARTS 'NC=X', atoms]
</pre></blockquote>
<p>
would generate a compile-time error since <tt>SMARTS 'NC=X'</tt> would be
calculated at compile-time.  Similarly, a construct such as
<blockquote><pre>
const TABLE = tr [
    [1, 'NC=O' ],
    [1, 'N[i]' ],
    [0, '*'    ]
];
const TABLE_VERIFY = null SMARTS peek [TABLE,2];
</pre></blockquote>
<p>
can be used to ensure that all tokens in <tt>TABLE(2)</tt> are legal
SMARTS strings.  Note that when applied to a constant argument, the
<tt>SMARTS</tt> function is evaluated at compile-time without any
adverse run-time performance penalty.

<p><a name="SMARTS_TABLE"></a></p>
<p><a name="sm_Match"></a></p>
<p><a name="sm_Indexof"></a></p>
<p><hr noshade="noshade" /></p>
<pre>indices = <span class="fcndef">sm_Indexof</span> [ atomkeys, smarts_tables, dict ]
numbers = <span class="fcndef">sm_Match</span> [ smarts_table, atomkeys, dict ]
smarts_table = <span class="fcndef">SMARTS_TABLE</span> smarts_table
</pre>

<p>
The <tt>sm_Indexof</tt> function returns, for each atom in <tt>atomkeys</tt>,
the first index <tt>j</tt> into <tt>smarts_tables</tt> that assigns a non-zero
value to the atom (see below).
The optional <tt>dict</tt> is a vector of dictionaries that define the
symbolic associations in the SMARTS strings of <tt>smarts_table(j)</tt>.
The <tt>sm_Indexof</tt> function is formally equivalent to

<blockquote><pre>
function sm_Indexof [atomkeys, smarts_tables, dict]
    local i, j;
    local idx = zero atomkeys;           // result

    for i = 1, length atomkeys loop
        for j = 1, length smarts_tables loop
            if sm_Match [smarts_tables(j), atomkeys(i), dict] then
                idx(i) = j;
                break;
            endif
        endloop
    endloop

    return idx;
endfunction
</pre></blockquote>

<p>
In most cases, the elements of <tt>smarts_tables</tt> will be single
SMARTS tokens; for example, to detect conjugated nitrogens, one could use

<blockquote><pre>
    const PLANAR_N = [
        '[N;i]',             // pi bonded N
        '[N!r3][i]',         // non-3-ring pi adjacent
        '[N!r3][+*]~[-*]'    // non-3-ring charge separated adjacent
    ];
    local idx = sm_Indexof [atomkeys, PLANAR_N];    // index or 0
</pre></blockquote>

<p>
The <tt>sm_Match</tt> function assigns an integer code to each atom
in the <tt>atomkeys</tt> vector determined by the <tt>smarts_table</tt>
argument.  The optional <tt>dict</tt> is a tagged-vector dictionary
that defines the symbolic associations in the SMARTS strings of
<tt>smarts_table</tt>.
Each atom in <tt>atomkeys</tt> is processed
separately according to the following algorithm.

<p>
At the outset, the default <tt>matchvalue</tt> is set to 1.
The elements of <tt>smarts_table</tt> are then processed in
order of
<tt>smarts_table(1)</tt>,
<tt>smarts_table(2)</tt>, etc.
Each element <tt>smarts_table(i)</tt> is interpreted as follows:

<blockquote><dl>
<dt><i>number</i>
<dd>
If <tt>smarts_table(i)</tt> is a <i>number</i> then 
a)&nbsp;if <tt>i</tt> is less than the length of <tt>smarts_table</tt>
then <tt>matchvalue</tt> is replaced with <i>number</i> rounded to the
nearest integer;
or
b)&nbsp;if <tt>i</tt> is equal to the length of <tt>smarts_table</tt>
then the value assigned to the atom is <i>number</i> rounded
to the nearest integer (and the algorithm terminates for the atom).
<p>
<dt><tt><b>'</b></tt> <i>smarts</i> <tt><b>'</b></tt>
<dd>
If <tt>smarts_table(i)</tt> is a token and
if the atom appears as the first atom in a substructure specified by the
<i>smarts</i> pattern then
the value assigned to the atom is the current value of
<tt>matchvalue</tt>
(and the algorithm terminates for the atom).
If the atom does match then the algorithm proceeds to the next
element of <tt>smarts_table</tt>.
<p>
<dt><tt><b>[</b></tt> <tt><b>'</b></tt> <i>smarts</i> <tt><b>'</b></tt>
		<tt><b>,</b></tt> <i>smarts_subtable</i> <tt><b>]</b></tt>
<dd>
If the atom appears as the first atom in a substructure specified by the
<i>smarts</i> pattern then the value assigned to the atom will be that
returned by a recursive call to <tt>sm_Match</tt> in which the specified
<tt>smarts_subtable</tt> is applied to the atom; however, the default
<tt>matchvalue</tt> is the current <tt>matchvalue</tt>.
</dl></blockquote>

<p>
If, after processing the <tt>smarts_table</tt> vector, an atom has not been
assigned a value, then it is assigned a value of 0.
A few examples will make this algorithm clearer:

<blockquote>
<table class="titlebar" cellpadding="3" border="1">
<tr>
<th><tt>smarts_table</tt></th>
<th>Result</th>
</tr>
<tr>
<td valign="baseline"><tt>'NC=O'</tt>
<td valign="baseline">
Returns the default <tt>matchvalue</tt> of 1 for each atom that is a
nitrogen adjacent to a carbonyl carbon and 0 otherwise.
<tr>
<td valign="baseline">
<pre>['NC=O','N[Sv6]~[OX1]']</pre>
<td valign="baseline">
Returns the default <tt>matchvalue</tt> of 1 for each atom that is a
nitrogen adjacent to either a carbonyl carbon or sulfonamide sulfur and 0
otherwise.
<tr>
<td valign="baseline">
<pre>[
  0, '[r3,r4]',
  1, 'NC=O', 'N[Sv6]~[OX1]',
  0
]</pre>
<td valign="baseline">
Returns 0 for any atom that is in a 3-ring or 4-ring (since the default
<tt>matchvalue</tt> has been replaced with 0 and 3-ring and 4-ring atoms
will match the <tt>[r3,r4]</tt> pattern).
Otherwise, 1 for each atom that is a nitrogen adjacent to either
a carbonyl carbon or sulfonamide sulfur since the default <tt>matchvalue</tt>
is assigned to 1 and such atom will match either
<tt>NC=O</tt> or <tt>N[Sv6]~[OX1]</tt>.
Atoms that do not match the previous patterns will be assigned a value
of 0 since the last element in the <tt>smarts_table</tt> vector is 0.
<tr>
<td valign="baseline">
<pre>[
  0, '[X0]',
  [ '[i]', [ 1, '*#*', '*(=*)=*', 2 ] ],
  3, '[!X3!X2!X1]',
  2, '*[i]', '*[+*]~-[-*]',
  3
]</pre>
<td valign="baseline">
Returns a hybridization code for each atom: 0 is returned for isolated
atoms (taking implicit hydrogens into account) by the <tt>[X0]</tt> pattern.
Atoms with a &pi; bond are given a code of 1 if they are involved in
a triple bond or two double bonds and 2 otherwise.  This assignment is
achieved with the recursive table that is applied to the atoms that
match the <tt>[i]</tt> pattern; these atoms are assigned a value using
<tt>[1,'*#*','*(=*)=*',2]</tt> for the <tt>smarts_table</tt>.  (The value
of 1 must be specified since in this nested table the default
<tt>matchvalue</tt> will be 0.) 
Remaining atoms with 4 or more bonds are assigned a code of 3 using
the <tt>[!X3!X2!X1]</tt> pattern.
Remaining atoms adjacent to a &pi; bonded atom or a charge-separated
atom pair (conjugated atoms) are assigned a code of 2.
Finally, a code of 3 is assigned to any atom that failed to match any of
the preceding patterns.
</table></blockquote>

<p>
The <tt>SMARTS_TABLE</tt> function returns its argument if it is a
syntactically correct <tt>smarts_table</tt> argument to <tt>sm_Match</tt>
in which all contained SMARTS patterns are syntactically correct
SMARTS patterns.  An error is generated otherwise.  This function is most
useful to check the validity of <tt>smarts_table</tt> arguments at
compile time (without a run-time performance penalty).
For example, the following code fragment could be included in an SVL
program to detect hydrogen bond acceptors:

<blockquote><pre>
const ACCEPTOR = SMARTS_TABLE [      // return 1 for Acc and 0 otherwise
    0, '[!#7!#8!#16]',               // allow {N,O,S} only

    [ '[i]', [                       // sub-table for pi bonded atoms
       0, '[X2]#*',                  // eliminate 2-coord sp
          '[X2](=*)=*',              // eliminate 2-coord sp
          '[X3]',                    // eliminate 3-coord sp2
       1, 'O',                       // non-aro oxygen is Acc
          '[#7]',                    // nitrogen with LP is Acc
	  '[SX1]~[C+0]',             // non-aro terminal S on neutral C
       0
    ]],

    [ '[NX3][i]', [1, '[r3]', 0] ],  // sub-table for conjugated N

    1, '[O;!+*]',                    // non-positive oxygen
    0, '[SX1][C+0]',                 // terminal anionic S on neutral C
    1, '[N;!+*]',                    // non-positive nitrogen
    0                                // all others
];

function IsAcceptor atomkeys
    return sm_Match [ACCEPTOR, atomkeys];
endfunction
</pre></blockquote>

<p>
The <tt>sm_Match</tt> and <tt>sm_Indexof</tt> functions are commonly used
for applications related to atom typing or atomic property calculation.
Where speed is an issue, care should be taken to put the patterns that
are most likely to match the most atoms close to the beginning of the
table (since tables are processed from lower indices to higher indices).

<p><a name="sm_MatchAtomCount"></a></p>
<p><a name="sm_MatchAll"></a></p>
<p><a name="sm_MatchAtoms"></a></p>
<p><hr noshade="noshade" /></p>

<pre>
atomkey_lists = <span class="fcndef">sm_MatchAtoms</span> [ smarts_token, atomkeys, dict ]
atomkey_lists = <span class="fcndef">sm_MatchAll</span>   [ smarts_token, atomkeys, dict ]
numbers       = <span class="fcndef">sm_MatchAtomCount</span> smarts_tokens
</pre>

<p>
The <tt>sm_MatchAtoms</tt> and <tt>sm_MatchAll</tt> functions return
complete substructures that match the <tt>smarts_token</tt> argument
and that start with an atom in the <tt>atomkeys</tt> argument.
The optional <tt>dict</tt> is a tagged-vector dictionary that defines the
symbolic associations in the SMARTS strings of <tt>smarts_token</tt>.

<p>
For each atom in <tt>atomkeys</tt> that is the start of a substructure
matching all of the atoms in <tt>smarts_token</tt>, <tt>sm_MatchAtoms</tt>
will return a list of atom keys (one for each atom in the SMARTS pattern
and in the order of the pattern).
If more than one list of atom keys match the SMARTS pattern then only one
of them will be returned.  If an atom in <tt>atomkeys</tt> is not the first
atom of a matching substructure then the empty vector will be returned for
that atom.  Thus, the returned vector of <tt>sm_MatchAtoms</tt> will have the
same length as <tt>atomkeys</tt> with each element either being the
empty vector (for atoms that are not the first atom of a matching
substructure) or an atom key list of length
<tt>sm_MatchAtomCount&nbsp;smarts_token</tt> (for atoms that are first
in a substructure matching <tt>smarts_token</tt>).  For example,

<blockquote><pre>
local alist = sm_MatchAtoms ['[NX3!i!$(*1~*~*1)]C=O', atomkeys];
</pre></blockquote>

<p>
sets <tt>alist</tt> to contain a vector of length equal to
<tt>length&nbsp;atomkeys</tt> with <tt>length&nbsp;atomkeys(i)</tt> either
3 (for non-3-ring amide nitrogens) or 0 for all other atoms in
<tt>atomkeys</tt>.  Each length 3 element of <tt>alist</tt> will
be of the form <tt>[N_key,C_key,O_key]</tt> each of which is an atom
key (not necessarily in the <tt>atomkeys</tt> vector) of the corresponding
nitrogen, carbon and oxygen atoms matching the SMARTS pattern.

<p>
The <tt>sm_MatchAll</tt> function is similar to <tt>sm_MatchAtoms</tt>
except that all matching substructures in the current molecular system
are returned.  Each such matching substructure will have its first atom
in the <tt>atomkeys</tt> list and all substructures associated with an
atom in <tt>atomkeys</tt> will be grouped together.
Thus, the following SVL code

<blockquote><pre>
local alist = sm_MatchAll ['[NX3!i!$(*1~*~*1)]C=O', atomkeys];
local [N,C,O] = tr alist;
</pre></blockquote>

<p>
will cause <tt>alist</tt> to contain all non-3-ring amide substructures
with the nitrogen in <tt>atomkeys</tt> even if a particular nitrogen
is involved in more than one such substructure (e.g. in urea groups).
The <tt>N</tt>, <tt>C</tt> and <tt>O</tt> variables will contain the
atom keys of the matching amide nitrogen, carbonyl carbon and carbonyl oxygen
atoms.  If <tt>atomkeys</tt> contains all of the atoms in the current
molecular system, then <tt>alist</tt> will contain all of the
non-3-ring amide substructures in the current molecular system.

<p>
The <tt>sm_MatchAtomCount</tt> function returns the number of atoms
specified by the SMARTS string in each of the given tokens of the
(possibly nested) <tt>smarts_tokens</tt> argument; -1 is returned for each
syntactically incorrect SMARTS string.

<p><a name="sm_MatchSyntaxError"></a></p>
<p><a name="sm_MatchSyntax"></a></p>
<p><hr noshade="noshade" /></p>
<pre>
flags      = <span class="fcndef">sm_MatchSyntax</span> smarts_tokens
err_tokens = <span class="fcndef">sm_MatchSyntaxError</span> smarts_tokens
</pre>
<p>

The <tt>sm_MatchSyntax</tt> function returns 1 for each syntactically
correct SMARTS token given in the <tt>smarts_tokens</tt> argument (which may
be a nested vector of tokens) and 0 otherwise.
The <tt>sm_MatchSyntaxError</tt> function returns the empty token for each
syntactically correct SMARTS token given in the <tt>smarts_tokens</tt>
argument (which may be a nested vector of tokens) and a non-empty token
containing an error message otherwise.

<p><a name="sm_Destroy"></a></p><p><a name="sm_Undefine"></a></p><p><a name="sm_Define"></a></p><p><a name="sm_Create"></a></p><p><hr noshade="noshade" /></p>
<h4 class="obsolete">Obsolete</h4>

<pre>
dictkey  = <span class="obsfcndef">sm_Create</span> dict
old_dict = <span class="obsfcndef">sm_Define</span> [dictkey, dict]
old_dict = <span class="obsfcndef">sm_Undefine</span> [dictkey, dname_tokens]
<span class="obsfcndef">sm_Destroy</span> dictkeys
</pre>

<p>
The SMARTS dictionary functions manage associations between symbolic names
and <tt>sm_Match</tt> match vectors.  The symbolic names may be referenced
in recursive bracketed atoms; for example, a dictionary may define the
symbolic name <tt>COO</tt> which may be referenced with <tt>[$COO]</tt>
in a SMARTS pattern. 
The <tt>sm_Destroy</tt> function destroys previously created dictionaries.
The argument is a vector of keys returned by <tt>sm_Create</tt>.
A <tt>dictkey</tt> can be specified as the <tt>dict</tt> argument to
the preceding match functions.
<p>
<b>Note!</b> These functions are obsolete since a tagged vector can
be directly specified to <tt>sm_Match</tt>, <tt>sm_MatchAtoms</tt> etc.


<h2>See Also</h2>
<p>
<a href="atom.htm">Atom Fundamental Properties</a><br />
<a href="sm_build.html">SMILES Functions</a><br />
<a href="../molsystems/smiles.html">Molecule Input Language</a>

<h2>References</h2>
<p>
<table border="0" cellpadding="5">
<tr>
<td valign="baseline">[Weininger&nbsp;1988]</td>
<td valign="baseline">Weininger, D.; SMILES 1. Introduction and Encoding Rules;
<i>J. Chem. Inf. Comput. Sci. 28</i> (<b>1988</b>) 31&ndash;36.
</td>
</tr>
</table>

<p><a href="../../index.htm">MOE Table of Contents</a>&nbsp;&nbsp;<a href="../../fcnindex.html">SVL Function Index</a></p>
<hr noshade="noshade" />
<a href="http://www.chemcomp.com"><img src="../../images/flogo.gif"
alt="CCG Logo"
align="left" width="30" height="30" border="1" hspace="5" vspace="3" /></a>
<font size="2">
<a href="../../legal.html">Copyright</a> &copy; 1997-2010
<a href="http://www.chemcomp.com">Chemical Computing Group Inc.</a><br />
<a href="mailto:info@chemcomp.com"><i>info@chemcomp.com</i></a>
</font>
</body>
</html>
