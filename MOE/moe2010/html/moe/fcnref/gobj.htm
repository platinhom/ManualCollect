<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<!--
!!    MOE 2010.10 On-Line Manuals
!!    COPYRIGHT (C) 2010
!!        CHEMICAL COMPUTING GROUP INC.  ALL RIGHTS RESERVED.
!!-->

<!--	gobj.htm	Graphics objects
!!
!!	11-oct-2010 (mk)	update for 2010
!!	08-jun-2010 (mk)	GOpen,GClose,GClass, ...
!!	26-feb-2010 (mk)	unsupported _GRibbonVertexData
!!	04-jul-2006 (ms)	unsupported GVar,GSetVar
!!	25-jun-2006 (ms)	GCreateUnique
!!	02-jun-2006 (ms)	added GTransparency,GMaterial,GSetTitle...
!!-->

<head>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<link rel="stylesheet" type="text/css"
href="../../manstyle.css" />


<meta keywords>
<meta functions GCreate, GCreateUnique, GDestroy>
<meta functions GOpen, GClose>
<meta functions GKeyListSys, GSystemList>
<meta functions GKeyListState, GState, GDataState>
<meta functions GTitle, GSetTitle>
<meta functions GClass, GSetClass>

<meta functions GVertex, GText>
<meta functions GLine, GPoint>
<meta functions GTranslate>
<meta functions GVertexData, GTextData>
<meta functions GClearVertexData, GClearTextData>

<meta functions GVisible, GSetVisible>
<meta functions GClippable, GSetClippable>
<meta functions GTransparency, GSetTransparency>
<meta functions GMaterial, GSetMaterial>

<meta obsolete GShow, GList>


<title>Graphics Object Functions: GCreate...</title>
</head>

<body bgcolor="#ffffff">
<a href="../../index.htm"><img src="../../images/logo.gif"
alt="CCG Logo" align="right" width="174" height="55" border="0" /></a>
<h4>MOE 2010.10</h4>
<h2>Graphics Object Functions</h2>
<hr noshade="noshade" />

<h2>Syntax</h2>

<b>Object Management</b>
<pre>
    obj_key = <a class="fcnlink" href="#GCreate">GCreate</a> []
    obj_key = <a class="fcnlink" href="#GCreate">GCreate</a> 'title'
    obj_key = <a class="fcnlink" href="#GCreateUnique">GCreateUnique</a> 'title'
    obj_key = <a class="fcnlink" href="#GCreateUnique">GCreateUnique</a> obj_key

    <a class="fcnlink" href="#GDestroy">GDestroy</a> obj_keys
    <a class="fcnlink" href="#GDestroy">GDestroy</a> 'titles'

    obj_key = <a class="fcnlink" href="#GOpen">GOpen</a> []
    obj_key = <a class="fcnlink" href="#GOpen">GOpen</a> obj_key
    obj_key = <a class="fcnlink" href="#GOpen">GOpen</a> [ obj_key, sys_key ]

    <a class="fcnlink" href="#GClose">GClose</a> obj_keys

    obj_keys = <a class="fcnlink" href="#GKey">GKey</a> obj_keys
    obj_keys = <a class="fcnlink" href="#GKeyList">GKeyList</a> []
    obj_keys = <a class="fcnlink" href="#GKeyList">GKeyList</a> 'class pattern'

    state = <a class="fcnlink" href="#GKeyListState">GKeyListState</a> []
    state = <a class="fcnlink" href="#GState">GState</a> obj_key
    state = <a class="fcnlink" href="#GDataState">GDataState</a> obj_key

    title = <a class="fcnlink" href="#GTitle">GTitle</a> obj_key
    <a class="fcnlink" href="#GSetTitle">GSetTitle</a> [ obj_key, title ]

    class = <a class="fcnlink" href="#GClass">GClass</a> obj_key
    <a class="fcnlink" href="#GSetClass">GSetClass</a> [ obj_key, class ]
</pre>

<b>Rendering Objects</b>
<pre>
    <a class="fcnlink" href="#GVertex">GVertex</a> [ obj_key, seg, idx, colors, [x,y,z] ]
    <a class="fcnlink" href="#GVertex">GVertex</a> [ obj_key, seg, idx, colors, [x,y,z], [nx,ny,nz] ]

    <a class="fcnlink" href="#GText">GText</a> [ obj_key, color, x, y, z, 'text' ]
    <a class="fcnlink" href="#GPoint">GPoint</a> [ obj_key, colors, x,y,z ]
    <a class="fcnlink" href="#GLine">GLine</a> [ obj_key, colors, x1,y1,z1, x2,y2,z2 ]

    <a class="fcnlink" href="#GTranslate">GTranslate</a> [ obj_key, dx, dy, dz ]

    data = <a class="fcnlink" href="#GVertexData">GVertexData</a> obj_key
    data = <a class="fcnlink" href="#GTextData">GTextData</a> obj_key

    data = <a class="fcnlink" href="#GClearVertexData">GClearVertexData</a> obj_key
    data = <a class="fcnlink" href="#GClearTextData">GClearTextData</a> obj_key
</pre>

<b>Visual Attributes</b>
<pre>
    val = <a class="fcnlink" href="#GVisible">GVisible</a> obj_key
    <a class="fcnlink" href="#GSetVisible">GSetVisible</a> [obj_key, val]

    val = <a class="fcnlink" href="#GClippable">GClippable</a> obj_key
    <a class="fcnlink" href="#GSetClippable">GSetClippable</a> [obj_key, val]

    [trans_front, trans_back] = <a class="fcnlink" href="#GTransparency">GTransparency</a> obj_key
    <a class="fcnlink" href="#GSetTransparency">GSetTransparency</a> [ obj_key, [trans_front, trans_back] ]
    <a class="fcnlink" href="#GSetTransparency">GSetTransparency</a> [ obj_key, [trans_both] ]

    [material_front, material_back] = <a class="fcnlink" href="#GMaterial">GMaterial</a> obj_key
    <a class="fcnlink" href="#GSetMaterial">GSetMaterial</a> [ obj_key, [material_front, material_back] ]
    <a class="fcnlink" href="#GSetMaterial">GSetMaterial</a> [ obj_key, [mat_both] ]
</pre>

<h3 class="obsolete">Obsolete</h3>
<pre>
    old_title = <a class="fcnlink" href="#obsGTitle">GTitle</a> [obj_key, 'title']

    show_flag = <a class="fcnlink" href="#GShow">GShow</a> obj_key
    old_show_flag = <a class="fcnlink" href="#GShow">GShow</a> [ obj_key, show_flag ]

    obj_keys = <a class="fcnlink" href="#GList">GList</a> []
    [obj_keys, show_flags, titles] = <a class="fcnlink" href="#GList">GList</a> 0
</pre>



<p><a name="GCreate"></a></p><h2>Description</h2>

<p>These functions allow the creation and manipulation of 3D graphics objects
in the MOE Window.
A graphics object is a container for graphical primitives
which can be added to that object at any time.
Each graphics object has an associated unique key which is used
to identify the object in the various rendering functions.
Individual graphics objects can be independently rendered,
shown/hidden, manipulated, and destroyed.
Before rendering can be performed, a graphics object must
be created with <tt>GCreate</tt> or <tt>GOpen</tt>.
On creation, graphics objects are linked by default to the current system,
and made visible together with that system.

</p>

<h4>Object Management</h4>

<pre>
obj_key = <span class="fcndef">GCreate</span> []
obj_key = <span class="fcndef">GCreate</span> 'title'
</pre>

<p>Creates a new (empty) global graphics object with the optional title 
specified by <tt>'title'</tt>, links it to the current molecular system, 
and returns the object's unique key.  The title is the string
that will appear in the Graphics Objects Manager.  For example:</p>

<pre>
    svl&gt; obj_key = GCreate 'Cube'
</pre>

<p>The following code is equivalent and preferred.</p>

<pre>
    svl&gt; obj_key = GCreate []
    svl&gt; GSetTitle [ obj_key, 'Cube' ]
</pre>

<p>
Global graphic objects created with <tt>GCreate</tt> need to be destroyed
after use with the function <tt>GDestroy</tt>.
</p>

<p><a name="GCreateUnique"></a></p><hr noshade="noshade" />

<pre>obj_key = <span class="fcndef">GCreateUnique</span> 'title'
obj_key = <span class="fcndef">GCreateUnique</span> obj_key
</pre>

<p>Returns an empty graphics object of a unique title, specified
by the argument.  All other graphics objects of the same title are destroyed.

<p><a name="GDestroy"></a></p><hr noshade="noshade" />
<pre>
<span class="fcndef">GDestroy</span> obj_keys
<span class="fcndef">GDestroy</span> 'title'
</pre>

<p>Destroys each global graphical object (created by <tt>GCreate</tt>)
specified by a key in <tt>obj_keys</tt> or a title name specified
as a token.  When a graphics object is destroyed, all rendering
primitives that it contains are also destroyed.  Attempting to
destroy a non-graphical object has no effect.  Note that objects such
as atoms, bonds and backbone ribbons are not considered to be graphical
objects, and hence are not subject to <tt>GDestroy</tt> commands.</p>

<pre>
    svl&gt; obj_key = GCreate []
    svl&gt; GSetTitle [ obj_key, 'Cube' ]    
    svl&gt; GVertex cat [obj_key, G_Box [icolor 'red', [-1,-1,-1], [1,1,1]]]
    svl&gt; GDestroy obj_key
</pre>

<p>If a graphics object created with <tt>GCreate</tt> is opened in a task
using <tt>GOpen obj_key</tt>, the final destruction of the object after a
<tt>GDestroy</tt> is delayed until it is closed with <tt>GClose</tt>
in all tasks in which it was opened.

<p><a name="GOpen"></a></p><hr noshade="noshade" />

<pre>obj_key = <span class="fcndef">GOpen</span> []</pre>

<p>Creates a new (empty) graphics object, links it to the current molecular
system and opens it in the current task.  Opening a graphics object in a
task creates an association between the task and the object:
A reference to the task is added to the graphics object.  The task
reference controls the lifetime of the graphics object.  A non-global 
graphics object is automatically destroyed once all its task references
are removed.  A task reference is removed with the function <tt>GClose</tt>
or automatically if the referenced task is destroyed.  To close the
graphics object, <tt>GClose</tt> must be given the key, which was returned
by the corresponding <tt>GOpen</tt> call.
</p>

<p>
The <tt>GOpen</tt> function is useful for limiting the lifetime of a
graphics object to the duration of a particular task, e.g. for
handling a dialog panel.  It can be also used for ensuring the lifetime
of a global graphics object (created with <tt>GCreate</tt>) during a task;
the final destruction of a global graphics object with <tt>GDestroy</tt>
is delayed until all task references are removed with <tt>GClose</tt>.
</p>

<pre>
obj_key = <span class="fcndef">GOpen</span> obj_key
obj_key = <span class="fcndef">GOpen</span> [ obj_key, sys_key ]
</pre>

<p>Reopens an existing graphics object in the current task, i.e. adds a
task reference.  The graphic object is linked to the current molecular
system, unless a specific system key is given.  The special value <tt>-1</tt>
specifies the current system and zero no system, i.e. with a system key of
zero no link is created. Without any links a graphics object
will be invisible. 

<p>The following example shows a function which creates a graphics object
and opens it in the current task. The graphics object will be automatically
destroyed together with the task, which called the function (in the example
after 10 seconds).</p>

<pre>
    function draw_task_cube []
	local key = GOpen [];
	GSetTitle [ key, 'Task Cube' ];
	GVertex cat [key, G_Box [icolor 'blue', [-2,-2,-2], [2,2,2]]];
    endfunction

    svl&gt; draw_task_cube []; sleep 10
</pre>

<p><a name="GClose"></a></p><hr noshade="noshade" />

<pre><span class="fcndef">GClose</span> obj_keys</pre>

Closes the specified graphics objects in the current task,
i.e. removes an existing task reference from each of the specified objects.
If any non-global graphics object has no more task references, it is destroyed.
To close the graphics object, <tt>GClose</tt> must be given the key, which
was returned by the corresponding <tt>GOpen</tt> call.

<p>The function accepts arbitrarily nested vectors.</p>

<p><a name="GKey"></a></p><hr noshade="noshade" />

<pre>
obj_keys = <span class="fcndef">GKey</span> obj_keys
</pre>

<p>Replaces all invalid graphics object keys in its argument with zeros.</p>

<p>The function accepts arbitrarily nested vectors.</p>

<p><a name="GKeyList"></a></p><hr noshade="noshade" />
<pre>
obj_keys = <span class="fcndef">GKeyList</span> []
obj_keys = <span class="fcndef">GKeyList</a> 'class pattern'
</pre>

<p>Returns a vector of keys of currently existing graphics objects.
If an empty vector <tt>[]</tt> is passed as the argument, all non-private
graphics objects are returned. A graphics object is deemed private if
its class name (set with <tt>GSetClass</tt>) starts with a <tt>"."</tt>,
e.g. <tt>'.private'</tt>.
If a class pattern is given, the keys of all graphics object matching
that class are returned.  The dot <tt>"."</tt> of a private class name
cannot be matched by a wildcard character and must be specified explicitly.
</p>

<p><a name="GKeyListState"></a></p><hr noshade="noshade" />

<pre>
state = <span class="fcndef">GKeyListState</span> []
</pre>

<p>Returns the <i>state</i> of the graphics object key list
(see <tt>GKeyList</tt>).
The state is a positive number that is increased with every
change to the list, i.e. every time a graphics object is created or
deleted.
</p>

<p><a name="GState"></a></p><p><a name="GState"></a></p><p><a name="GState"></a></p><hr noshade="noshade" />

<pre>
state = <span class="fcndef">GState</span> 0
state = <span class="fcndef">GState</span> obj_key
state = max <span class="fcndef">GState</span> [obj_key1, obj_key2, ...]
</pre>

<p>Returns the <i>state</i> of the specified graphics objects.
The state is a positive number that is increased with every change
in data or attributes of a graphics object.
If the argument is 0, the function returns the state of the most recently
modified graphics object.
</p>

<p>The function accepts arbitrarily nested vectors.</p>

<p><a name="GDataState"></a></p><hr noshade="noshade" />

<pre>
state = <span class="fcndef">GDataState</span> 0
state = <span class="fcndef">GDataState</span> obj_key
state = max <span class="fcndef">GDataState</span> [obj_key1, obj_key2, ...]
</pre>

<p>Returns the <i>data state</i> of the specified graphics objects.
The data state is a
positive number that is increased with every change in the vertex or
text data of a graphics object.
If the argument is 0, the function
returns the data state of the most recently modified graphics object.
</p>

<p>The function accepts arbitrarily nested vectors.</p>

<p><a name="GTitle"></a></p><hr noshade="noshade" />

<pre>
title = <span class="fcndef">GTitle</span> obj_key
</pre>

<p>For each key in the vector <tt>obj_key</tt>, the function
returns the title of the graphics object.
For example:
</p>

<pre>
    svl&gt; obj_key = GCreate []
    svl&gt; GSetTitle [obj_key, 'Cube']
    svl&gt; GTitle obj_key
    'Cube'
</pre>

<p>
If the key is zero, the function returns an empty token.
If the key is invalid, the function generates an error.
</p>

<p>The function accepts arbitrarily nested vectors.</p>

<h4><span class="obsolete">Obsolete Syntax</span></h4>

<p>Function <tt>GTitle</tt> also supports its old syntax:</p>
<pre>
    old_title = GTitle [obj_key, 'title']
</pre>

<p>which is now obsolete. To change a title, use <tt>GSetTitle</tt> instead.</p>

<p><a name="GSetTitle"></a></p><hr noshade="noshade" />

<pre>
<span class="fcndef">GSetTitle</span> [obj_key, title]
</pre>

<p>For each key in <tt>obj_key</tt> and each corresponding
(token) title in <tt>title</tt>, the function resets the title
of the graphics object to the specified value.
Zero keys are ignored.  Invalid keys generate an error.</p>

<pre>
    svl&gt; GSetTitle [obj_key, 'Cube Example']
    svl&gt; GTitle obj_key
    'Cube Example'
</pre>

<p>The function accepts arbitrarily nested vectors.</p>


<p><a name="GClass"></a></p><hr noshade="noshade" />

<pre>class = <span class="fcndef">GClass</span> obj_key</pre>

<p>For each key in the vector <tt>obj_key</tt>, the function
returns the class token of the graphics object.
If the key is zero, the function returns an empty token.
If the key is invalid, the function generates an error.

<p><a name="GSetClass"></a></p><hr noshade="noshade" />

<pre>
<span class="fcndef">GSetClass</span> [obj_key, class]
</pre>

<p>For each key in <tt>obj_key</tt> and each corresponding
(token) class in <tt>class</tt>, the function resets the class
of the graphics object to the specified value.
Zero keys are ignored.  Invalid keys generate an error.</p>
If the class name starts with a <tt>"."</tt> (e.g. <tt>'.private'</tt>),
the graphics object is deemed private and will not be listed either with
<tt>GKeyList []</tt> or in the Graphics Object Manager.

<pre>
    svl&gt; GSetClass [obj_key, 'Molecular Surface']
    svl&gt; GClass obj_key
    'Molecular Surface'
</pre>

<p>The function accepts arbitrarily nested vectors.</p>

<hr noshade="noshade" />

<h4>Rendering</h4>  

<p>Once a graphics object has been created, it is possible to render graphics
primitives into the object by specifying its key.  The following functions
allow rendering into graphics objects.  There are three important concepts for
rendering primitives:</p>

<ol>
<li><p>

<!--
<i>Colors</i>.  Colors are specified with a single integer value that
encodes Red, Green and Blue color channel intensities (RGB colors).  An RGB
color with intensities (<i>r</i>,<i>g</i>,<i>b</i>) where each of <i>r</i>,
<i>g</i> and <i>b</i> are between 0 and 1 is encoded as an integer in the
following way:</p>

<center>
<i>rgb_color</i> = 256<sup>2</sup><i>r</i> + 256<i>g</i> + <i>b</i>
</center>
-->

<i>Colors</i>. Color is specified
using a single integer that stores red, green, and blue (RGB)
intensities in 3 channels (bytes),
each in the range [0..255]:
</p>

<pre>
    [red, green, blue] = byteunpack3 rgb_color;
    rgb_color = bytepack3 [red, green, blue];
</pre>

<p>This encoding can equivalently be expressed in hexadecimal
as <tt>0xRRGGBB</tt>, where <tt>RR</tt>
is the red intensity, <tt>GG</tt> is the green intensity and <tt>BB</tt>
is the blue intensity.  
</p></li>

<li><p>
<i>Coordinates</i>.  Coordinates are three-dimensional <i>xyz</i>
cartesian coordinates specified as a 3-vector <tt>[x,y,z]</tt> where each
of <tt>x</tt>, <tt>y</tt> and <tt>z</tt> are of length <i>n</i> and where
<i>n</i> is the number of points.  For example, the <tt>aPos</tt> function
that returns atomic coordinates returns the coordinate data in this format.
</p></li>

<li><p><i>Normals</i>.  Surface normals are required for the shading model of
most 3D graphics libraries.  If surface normals are not used, graphics
primitives will use the specified color directly.  If surface normals are
used, then primitive vertices will be shaded.  Normals are specified with
a 3-vector <tt>[nx,ny,nz]</tt> in which each of <tt>nx</tt>, <tt>ny</tt>,
and <tt>nz</tt> have length <i>n</i> where <i>n</i> is the number of points.
This is the same format as for coordinates.
</p></li>
</ol>

<p><a name="GVertex"></a></p><p><a name="GVertex"></a></p><hr noshade="noshade" />

<pre>
<span class="fcndef">GVertex</span> [ obj_key, seg, idx, colors, [x,y,z] ]
<span class="fcndef">GVertex</span> [ obj_key, seg, idx, colors, [x,y,z], [nx,ny,nz] ]
</pre>

<tt>GVertex</tt> is the fundamental rendering function for points, lines and
triangles.  Its calling sequence is:

<pre>
    GVertex [ obj_key, seg, idx, color, coord, normal ]
</pre>

<p>
where:
</p>

<p><dl>
<dt><tt>obj_key</tt> 
<dd>Graphics object key.

<p><dt><tt>seg</tt> 
<dd>Segment vector used to split the <tt>idx</tt> vector into
subvectors of length 1, 2 or 3.  In other words, the format of this integer
segment vector is such that it contains only
the values 1, 2 or 3 and that a call to
the function <tt>split[idx,seg]</tt> would succeed.

<p><dt><tt>idx</tt> 
<dd>Vector of integer indices each in the range [1,<i>n</i>].
These indices refer to vertices specified by <tt>color</tt>, <tt>coord</tt>
and possibly <tt>normal</tt>.

<p><dt><tt>colors</tt> 
<dd>Integer vector of length <i>n</i> specifying vertex
colors (as described above).

<p><dt><tt>coord</tt> 
<dd>3-vector specifying the coordinates of <i>n</i> points
(as described above).

<p><dt><tt>normal</tt> 
<dd>Either <tt>[]</tt> or a 3-vector specifying <i>n</i>
surface normals (as described above).  If <tt>normal</tt> is <tt>[]</tt>, or
not given, then surface normals are not used (no shading).

</dl>

<p>
The splitting of the <tt>idx</tt> vector by <tt>seg</tt> defines what kinds
of objects are drawn.  The split operation produces a vector of index vectors
each of which are of length 1, 2 or 3.  A length 1 vector defines a point;
a length 2 vector defines a line; and a length 3 vector defines a triangle.
The color, coordinates and normal of the point, line or triangle are
obtained by indexing the <tt>color</tt>, <tt>coord</tt> and <tt>normal</tt>
vectors.  For example:
</p>

<pre>
    svl&gt; GVertex [obj_key, 1, 1, 0xFFFFFF, [3,4,5]]
</pre>

<p>
draws a white point at the coordinates (3,4,5) with no shading (since no normal
vectors were specified).  The following call:
</p>

<pre>
    svl&gt; pt = [ [10,20], [30,40], [50,60] ]
    svl&gt; GVertex [obj_key, 2, [1,2], 0xFF0000, pt ]
</pre>

<p>
will draw a red line between the points (10,30,50) and (20,40,60) with no
shading.  The following call:
</p>

<pre>
    svl&gt; pt = [ [10,50,30], [40,50,60], [70,80,90] ]
    svl&gt; GVertex [obj_key, 3, [1,2,3], 0x00FF00, pt ]
</pre>

<p>
will draw a green triangle with vertices (10,40,70), (50,50,80) and (30,60,90).
For triangles, the order of the vertices is important.  The front face of the
triangle is determined assuming that the vertices are given in
counter-clockwise order, using a "right-handed" rule.  The same
triangle can be rendered with opposite orientation by modifying the <tt>idx</tt>
vector as follows:
</p>

<pre>
    svl&gt; pt = [ [10,50,30], [40,50,60], [70,80,90] ]
    svl&gt; GVertex [obj_key, 3, [3,2,1], 0x00FF00, pt ]
</pre>

<p>
A more complicated example draws both a point and a line:
</p>

<pre>
    svl&gt; pt = [ [10,20,30], [40,50,60], [70,80,90] ]
    svl&gt; GVertex [obj_key, [1,2], [1,2,3], 0x0000FF, pt ]
</pre>

<p>
This call will draw a blue point at (10,40,70) and a blue line between
(20,50,80) and (30,60,90).
</p>

<p><a name="GText"></a></p><hr noshade="noshade" />
<pre><span class="fcndef">GText</span> [obj_key, color, x, y, z, 'text']</pre>
    
<p>Writes a text string <tt>text</tt> into the object specified
by <tt>obj_key</tt> at the coordinates (<tt>x</tt>,<tt>y</tt>,<tt>z</tt>) with
the color specified by <tt>color</tt>.
<tt>color</tt> and coordinate types are as described above.
</p>

<p><a name="GPoint"></a></p><hr noshade="noshade" />
<pre><span class="fcndef">GPoint</span> [obj_key, colors, x,y,z ]</pre>

<p>Writes a point into each object specified by a key in
<tt>obj_keys</tt> at the corresponding coordinates (as described above)
(<tt>x</tt>,<tt>y</tt>,<tt>z</tt>), with the corresponding color specified
in <tt>colors</tt> (as described above). Unit extension applies.
<b>Note:</b> <tt>GPoint</tt> calls <tt>GVertex</tt> to effect rendering.
Normals cannot be specified.
</p>

<p><a name="GLine"></a></p><hr noshade="noshade" />
<pre><span class="fcndef">GLine</span> [obj_key, colors, x1,y1,z1, x2,y2,z2]</pre>

<p>
Writes a line segment into each object specified by a key in
<tt>obj_keys</tt>.  Each line segment is colored according to the
corresponding value specified in <tt>colors</tt> (as described above), 
and connects the two
corresponding points (<tt>x1</tt>,<tt>y1</tt>,<tt>z1</tt>) and
(<tt>x2</tt>,<tt>y2</tt>,<tt>z2</tt>) (as described above).  
Unit extension applies, and each
of <tt>x1</tt>, <tt>y1</tt>, <tt>z1</tt>, <tt>x2</tt>, <tt>y2</tt> and
<tt>z2</tt> can be vectors.  <b>Note:</b> <tt>GLine</tt> calls
<tt>GVertex</tt> to effect the rendering.  Normals cannot be specified.
</p>

<p>The following is an example of a function for drawing a multi-colored cube
in the MOE graphical window. To hide or delete the object, the
Graphics Object Manager or the functions <tt>GSetVisible</tt> and
<tt>GUnlink</tt> can be used.
</p>

<pre>
    function draw_cube []
	ViewReset[];
	local key = GCreate [];
     
        local red     = 0xFF0000;
        local magenta = 0xFF00FF;
        local cyan    = 0x00FFFF;
        local yellow  = 0xFFFF00;
     
	local D = 3;		 // size

	GSetTitle [key, 'Cube'];
     
	GLine [key, red,     0,0,0, D,0,0];
	GLine [key, magenta, 0,0,0, 0,D,0];
	GLine [key, cyan,    0,0,0, 0,0,D];
     
	GLine [key, red,     D,D,D, 0,D,D];
	GLine [key, magenta, D,D,D, D,0,D];
	GLine [key, cyan,    D,D,D, D,D,0];
     
	GLine [key, red,     D,0,0, D,0,D];
	GLine [key, yellow,  D,0,0, D,D,0];
     
	GLine [key, red,     0,D,0, D,D,0];
	GLine [key, yellow,  0,D,0, 0,D,D];
 
	GLine [key, red,     0,0,D, D,0,D];
	GLine [key, yellow,  0,0,D, 0,D,D];
    endfunction
</pre>

<p><a name="GTranslate"></a></p><hr noshade="noshade" />

<pre>
<span class="fcndef">GTranslate</span> [obj_key, dx, dy, dz]
</pre>

<p>Translates all rendered primitives in a graphics
object by the specified <i>x</i>, <i>y</i>, and <i>z</i>
translation vectors.</p>

<p><a name="GTextData"></a></p><p><a name="GVertexData"></a></p><hr noshade="noshade" />

<pre>
vdata = <span class="fcndef">GVertexData</span> obj_key
tdata = <span class="fcndef">GTextData</span> obj_key
</pre>

<p>Returns the vertices or text stored in the graphics object
<tt>obj_key</tt>.  The surface can be recreated in a new graphics object
by using the returned values <tt>vdata</tt> and <tt>tdata</tt> in the
argument of functions <tt>GVertex</tt> and <tt>GText</tt>,
respectively:</p>

<pre>
    app GVertex apt cat [new_key, vdata];
    app GText apt cat [new_key, tdata];
</pre>

<p><a name="GClearTextData"></a></p><p><a name="GClearVertexData"></a></p><hr noshade="noshade" />

<pre>
data = <span class="fcndef">GClearVertexData</span> obj_key
data = <span class="fcndef">GClearTextData</span> obj_key
</pre>

<p>Deletes the vertices and text stored in the graphics object
<tt>obj_key</tt>.</p>

<hr noshade="noshade" />

<h4>Visual Attributes</h4>

<p> The visual appearance of graphics objects is determined in part by the
individual vertices and text comprising the objects and in part by the
transparency and material parameters that are set for the entire object.
Transparency determines how much we can see through the surface, while
material parameters determine how light reflects from the surface.  Each
surface has two sides, the <i>Front</i> face and the <i>Back</i> face.
The transparency and material parameters can be set for each face
separately.  </p>

<p> The Front and the Back faces are defined by the orientation of the
surface normals.  A surface normal enters the surface through
the back face and exits the surface through the front face.  Molecular
surfaces and other closed surfaces are usually generated with the front
face on the exterior and the back face on the interior. </p>

<p><a name="GVisible"></a></p><hr noshade="noshade" />

<pre>
val = <span class="fcndef">GVisible</span> obj_key
</pre>

<p>For each key in the vector <tt>obj_key</tt>, the function returns 1
if the corresponding graphics object is visible and 0 if it is hidden.
If the key is zero, the function returns 0.  If the key is invalid,
the function generates an error.
</p>

<p>The function accepts arbitrarily nested vectors.</p>

<p><a name="GSetVisible"></a></p><hr noshade="noshade" />

<pre>
<span class="fcndef">GSetVisible</span> [obj_key, val]
</pre>

<p>For each key in <tt>obj_key</tt>,
the function sets the visibility of the given
graphics object to the
corresponding value in <tt>val</tt>.
A value of zero means that the
object is hidden, non-zero means visible.  Zero keys are ignored.
Invalid keys generate an error.</p>

<p>The function accepts arbitrarily nested vectors.</p>


<p><a name="GClippable"></a></p><hr noshade="noshade" />

<pre>
val = <span class="fcndef">GClippable</span> obj_key
</pre>

<p>For each key in the vector <tt>obj_key</tt>, the function returns 1
if the corresponding graphics object has clipping by the
surface Z-clipping planes enabled and 0 if not
(see <a class="svl" href="view.html">ViewZSFront</a>,
<a class="svl" href="view.html">ViewZSWidth</a>).
The surface Z-clipping planes are independent of the system clipping
planes
(see <a class="svl" href="view.html">ViewZFront</a>,
<a class="svl" href="view.html">ViewZWidth</a>),
and apply to graphics objects only.
Note that graphics objects are always subject to the
system clipping planes.
By default, graphics objects have surface Z-clipping enabled.
If the key is zero, the function returns 0.  If the key is invalid,
the function generates an error.
</p>

<p>The function accepts arbitrarily nested vectors.</p>

<p><a name="GSetClippable"></a></p><hr noshade="noshade" />

<pre>
<span class="fcndef">GSetClippable</span> [obj_key, val]
</pre>

<p>For each key in <tt>obj_key</tt>, disables surface Z-clipping
if the corresponding value in <tt>val</tt> is 0, otherwise
enables it.
Zero keys are ignored.
Invalid keys generate an error.
For more information on surface Z-clipping, see <tt>GClippable</tt>.
</p>

<p>The function accepts arbitrarily nested vectors.</p>


<p><a name="GTransparency"></a></p><hr noshade="noshade" />

<pre>
[trans_front, trans_back] = <span class="fcndef">GTransparency</span> obj_key
</pre>

<p>For each key in the vector <tt>obj_key</tt>, the function returns
the transparency modification values, <tt>trans_front</tt>,
<tt>trans_back</tt>, of the front and back faces of the graphics
object, respectively, as set by <tt>GSetTransparency</tt>.
These values modify the transparency rendering of the graphics
object: they are
added to the transparency values that are stored with the
color data of each vertex of the graphics object (and the
resulting sum clipped to the range [0..255]).
Positive values correspond to greater
transparency, with a maximum value of <tt>0xff</tt> causing the
surface to be completely transparent (invisible).
Negative values correspond
to greater opacity, with a minimum value of <tt>-0xff</tt> causing
the surface to be completely opaque.
If the key is zero, the function returns 0.  If
the key is invalid, the function generates an error.</p>

<p>The function accepts arbitrarily nested vectors.</p>

<p><a name="GSetTransparency"></a></p><p><a name="GSetTransparency"></a></p><hr noshade="noshade" />

<pre>
<span class="fcndef">GSetTransparency</span> [obj_key, [trans_front, trans_back]]
<span class="fcndef">GSetTransparency</span> [obj_key, [trans_both]]
</pre>

<p>For each key in <tt>obj_key</tt>, the function changes the transparency
rendering of the graphics object by adding a transparency modification value
to the transparency
value stored in each vertex of the object.  If both 
<tt>trans_front</tt> and of <tt>trans_back</tt> are specified, then
the front and back faces of the graphics object are modified separately.
If only one value, <tt>trans_both</tt>, is specified, it
is applied to both front and back faces.
Zero keys are ignored.
Invalid keys generate an error.
</p>

<p>The transparency modification
value is added to the transparency channel of each
vertex color and must fall within the range
<tt>[-0xff,&nbsp;+0xff]</tt> (the resulting sum is clipped to the
range [0..255]).  Positive values increase overall
transparency, making it easier to see through surfaces.  Value
<tt>0xff</tt> makes the surface perfectly transparent, i.e. invisible.
Negative values decrease overall transparency, making surfaces more
opaque.  Value <tt>-0xff</tt> makes the surface fully opaque.  A value
of zero leaves the transparency channel intact, i.e. preserves the
original value of the transparency as stored in the vertex data.</p>

<p>
The function accepts arbitrarily nested vectors.</p>

<p><a name="GMaterial"></a></p><p><a name="GMaterial"></a></p><p><a name="GMaterial"></a></p><hr noshade="noshade" />

<pre>
[material_front, material_back] = <span class="fcndef">GMaterial</span> obj_key
[material_matte, material_glossy] = <span class="fcndef">GMaterial</span> 0
[material_matte, material_glossy] = <span class="fcndef">GMaterial</span> -1
</pre>

<p>For each key in <tt>obj_key</tt>, the function returns the
material properties, <tt>material_front</tt>, <tt>material_back</tt>, of
the front face and back faces, respectively, of the graphics object.
If the key is 0, the function returns the customizable defaults for
materials of matte (dull) and glossy (shiny) appearance.  If the key is -1,
the function returns the internal, uncustomizable defaults.  If the key is
invalid, the function generates an error.  </p>

<p>The function accepts arbitrarily nested vectors.</p>

<p>The material value is an integer that stores 3 channels (bytes),
<i>ambient</i>, <i>diffuse</i> and <i>specular</i>,
each in the range 0 to 255, inclusive:
</p>
<pre>
    [ambient, diffuse, specular] = byteunpack3 material;
    material = bytepack3 [ambient, diffuse, specular];
</pre>

<p>
Each channel specifies the amount of light of given type,
reflected from the surface.
</p>
<ul>
<li><b>Ambient</b> illumination is independent of surface orientation
and gives the appearance of uniform brightness with no apparent
light source.
</li>
<li><b>Diffuse</b> illumination varies gradually with
the orientation of the surface and gives it a matte appearance.
</li>
<li><b>Specular</b> illumination varies dramatically with
the orientation of the surface and gives it a glossy appearance.
</li>
</ul>

<p>The default material property is specified by MOE
<a href="rc.htm">resource configuration</a> (RC) boolean values:
</p>
<pre>
    vsetup.surface_material_matte
    vsetup.surface_material_glossy
</pre>

<p><a name="GSetMaterial"></a></p><p><a name="GSetMaterial"></a></p><hr noshade="noshade" />

<pre>
<span class="fcndef">GSetMaterial</span> [obj_key, [material_front, material_back]]
<span class="fcndef">GSetMaterial</span> [obj_key, [material_both]]
</pre>

<p>For each key in <tt>obj_key</tt>,
the function resets the material properties of the front and
back faces of the graphics object to the corresponding
value of <tt>material_front</tt> and of <tt>material_back</tt>, respectively.
Zero keys are ignored.  Invalid keys generate an error.</p>

<p>The function accepts arbitrarily nested vectors.</p>

<p>Note: Rendering surfaces of different material properties at the same time
may degrade the performace of the graphics rendering system.

<p><a name="obsGTitle"></a></p><hr noshade="noshade" />
<h4 class="obsolete">Obsolete Syntax</h4>

<pre>
old_title = <span class="obsfcndef">GTitle</span> [obj_key, 'title']
</pre>

<p>Changes the title of the given graphics object and
returns its previous title.  This syntax is obsolete.
Use the following code instead:
<pre>
    old_title = GTitle obj_key;
    GSetTitle [obj_key, 'title'];
</pre>

<p><a name="GList"></a></p><hr noshade="noshade" />
<h4 class="obsolete">Obsolete Functions</h4>

<pre>
keys = <span class="obsfcndef">GList</span> []
[keys, show_flags, titles] = <span class="obsfcndef">GList</span> 0
</pre>


<p>Returns a vector of all the graphics object keys that exist.
If 0 is passed as the argument, three vectors are returned: the
keys, visibility flags and object titles.
<p>Function <tt>GList</tt> has been superseded by functions
<tt>GKeyList</tt>, <tt>GVisible</tt>, <tt>GTitle</tt>.

Use the following code instead:

<pre>
    keys = GKeyList []
    [keys, show_flags, titles] = [keys, GVisible keys, GTitle keys]
</pre>

<p><a name="GShow"></a></p><p><a name="GShow"></a></p><hr noshade="noshade" />

<pre>
show_flag = <span class="obsfcndef">GShow</span> obj_key
old_show_flag = <span class="obsfcndef">GShow</span> [ obj_key, show_flag ]
</pre>

<p>Function <tt>GShow</tt> has been superseded by functions
<tt>GVisible</tt> and <tt>GSetVisible</tt>.

Use the following code instead:

<pre>
    <tt>old_show_flag = GVisible obj_key</tt>
    <tt>GSetVisible [obj_key, show_flag]</tt>
</pre>



<h2>See Also</h2>

<a href="gobj2.htm">Graphics Object Functions</a><br />
<a href="view.html">Molecule Viewing Functions</a><br />
<a href="obj.htm">Molecular Object and System Functions</a>

<!--
<p>
<table>
<tr>
<td valign=top>
<tt>
  <a href="gobj2.htm#G_Cross">G_Cross</a><br />
  <a href="gobj2.htm#G_Box">G_Box</a><br />
  <a href="gobj2.htm#G_WireBox">G_WireBox</a><br />
  <a href="gobj2.htm#G_Sphere">G_Sphere</a><br />
  <a href="gobj2.htm#G_WireSphere">G_WireSphere</a><br />
  <a href="gobj2.htm#G_PolySphere">G_PolySphere</a><br />
  <a href="gobj2.htm#G_Cylinder">G_Cylinder</a><br />
  <a href="gobj2.htm#G_WireCylinder">G_WireCylinder</a><br />
  <a href="gobj2.htm#G_PolyCylinder">G_PolyCylinder</a><br />
  <a href="gobj2.htm#G_Cone">G_Cone</a><br />
  <a href="gobj2.htm#G_WireCone">G_WireCone</a><br />
  <a href="gobj2.htm#G_PolyCone">G_PolyCone</a><br />
</tt>
<td valign=top>
<tt>
  <a href="gsurface.html#GSurface">GSurface</a><br />
  <a href="gobj2.htm#G_Cat">G_Cat</a><br />
  <a href="gobj2.htm#G_Cap">G_Cap</a><br />
  <a href="gobj2.htm#G_WireCap">G_WireCap</a><br />
  <a href="gobj2.htm#G_PolyCap">G_PolyCap</a><br />
  <a href="gobj2.htm#G_Circle">G_Circle</a><br />
  <a href="gobj2.htm#G_WireCircle">G_WireCircle</a><br />
  <a href="gobj2.htm#G_UnitSphere">G_UnitSphere</a><br />
  <a href="gobj2.htm#G_UnitCircle">G_UnitCircle</a><br />
  <a href="view.html#ViewScale">ViewScale</a><br />
  <a href="view.html#ViewLookAt">ViewLookAt</a>
</tt>
</tr>
</table>
-->

<p><a href="../../index.htm">MOE Table of Contents</a>&nbsp;&nbsp;<a href="../../fcnindex.html">SVL Function Index</a></p>
<hr noshade="noshade" />
<a href="http://www.chemcomp.com"><img src="../../images/flogo.gif"
alt="CCG Logo"
align="left" width="30" height="30" border="1" hspace="5" vspace="3" /></a>
<font size="2">
<a href="../../legal.html">Copyright</a> &copy; 1997-2010
<a href="http://www.chemcomp.com">Chemical Computing Group Inc.</a><br />
<a href="mailto:info@chemcomp.com"><i>info@chemcomp.com</i></a>
</font>
</body>
</html>
