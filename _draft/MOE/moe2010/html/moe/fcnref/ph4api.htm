<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<!--
!!    MOE 2010.10 On-Line Manuals
!!    COPYRIGHT (C) 2010
!!        CHEMICAL COMPUTING GROUP INC.  ALL RIGHTS RESERVED.
!!-->

<!--
!!	ph4api.htm
!!
!!	07-aug-2009 (ms) created
!!-->

<head>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<link rel="stylesheet" type="text/css"
href="../../manstyle.css" />


<meta keywords>
<meta functions ph4_QueryXxx>

<meta _functions ph4_QueryOpen>
<meta _functions ph4_QueryClose>
<meta _functions ph4_QueryKey>
<meta _functions ph4_QueryKeyOpen>
<meta _functions ph4_QueryWriteFile>
<meta _functions ph4_QueryReadFile>
<meta _functions ph4_QueryWriteString>
<meta _functions ph4_QueryReadString>
<meta _functions ph4_QueryEncode>
<meta _functions ph4_QueryDecode>
<meta _functions ph4_QueryR64encodeln>
<meta _functions ph4_QueryR64decodeln>
<meta _functions ph4_SchemeGetBitmaskAll>
<meta _functions ph4_SchemeExprProp>
<meta _functions ph4_QueryFkeylist>
<meta _functions ph4_QueryCkeylist>
<meta _functions ph4_QueryVkeylist>
<meta _functions ph4_QueryFcount>
<meta _functions ph4_QueryCcount>
<meta _functions ph4_QueryVcount>
<meta _functions ph4_QueryFkeyidx>
<meta _functions ph4_QueryCkeyidx>
<meta _functions ph4_QueryVkeyidx>
<meta _functions ph4_QuerySdata>
<meta _functions ph4_QuerySetSdata>
<meta _functions ph4_QueryFdata>
<meta _functions ph4_QuerySetFdata>
<meta _functions ph4_QueryCdata>
<meta _functions ph4_QuerySetCdata>
<meta _functions ph4_QueryVdata>
<meta _functions ph4_QuerySetVdata>
<meta _functions ph4_QueryCreateF>
<meta _functions ph4_QueryCreateC>
<meta _functions ph4_QueryCreateV>
<meta _functions ph4_QueryCopyF>
<meta _functions ph4_QueryCopyC>
<meta _functions ph4_QueryCopyV>
<meta _functions ph4_QueryDeleteF>
<meta _functions ph4_QueryDeleteC>
<meta _functions ph4_QueryDeleteV>
<meta _functions ph4_QueryDeleteAllFC>
<meta _functions ph4_QueryDeleteAllV>
<meta _functions ph4_QueryDeleteAll>
<meta _functions ph4_QueryPermuteF>
<meta _functions ph4_QueryPermuteC>
<meta _functions ph4_QueryPermuteV>
<meta _functions ph4_QueryDataErr>
<meta _functions ph4_QueryDataOK>
<meta _functions ph4_QueryDeleteUselessC>
<meta _functions ph4_QueryDeleteUselessV>
<meta _functions ph4_QueryDeleteAllIgnored>
<meta _functions ph4_QueryCopyCat>
<meta _functions ph4_QueryMergeV>
<meta _functions ph4_QueryDemergeV>
<meta _functions ph4_QuerySoftenAllF>
<meta _functions ph4_QuerySoftenV>

<title>Ph4 Query API Functions</title>
</head>

<body bgcolor="#ffffff">
<a href="../../index.htm"><img src="../../images/logo.gif"
alt="CCG Logo" align="right" width="174" height="55" border="0" /></a>
<h4>MOE 2010.10</h4>
<h2>Ph4 Query API Functions</h2>
<hr noshade="noshade" />

<h2>Syntax</h2>

<pre>
    qkey = <a class="fcnlink" href="#ph4_QueryOpen"
	>ph4_QueryOpen</a> []
    qkey = <a class="fcnlink" href="#ph4_QueryOpen"
	>ph4_QueryOpen</a> qkey
    <a class="fcnlink" href="#ph4_QueryClose"
	>ph4_QueryClose</a> qkey

    qkey = <a class="fcnlink" href="#ph4_QueryKey"
	>ph4_QueryKey</a> qkey
    qkey = <a class="fcnlink" href="#ph4_QueryKeyOpen"
	>ph4_QueryKeyOpen</a> qkey

---------- <a href="#I/O Functions">I/O Functions</a> ----------

    <a class="fcnlink" href="#ph4_QueryWriteFile"
	>ph4_QueryWriteFile</a> [qkey, fn]
    <a class="fcnlink" href="#ph4_QueryReadFile"
	>ph4_QueryReadFile</a> [qkey, fn]
    bstr = <a class="fcnlink" href="#ph4_QueryWriteString"
	>ph4_QueryWriteString</a> qkey
    <a class="fcnlink" href="#ph4_QueryReadString"
	>ph4_QueryReadString</a> [qkey, bstr]
    bstr = <a class="fcnlink" href="#ph4_QueryEncode"
	>ph4_QueryEncode</a> qkey
    <a class="fcnlink" href="#ph4_QueryDecode"
	>ph4_QueryDecode</a> [qkey, bstr]
    lines = <a class="fcnlink" href="#ph4_QueryR64encodeln"
	>ph4_QueryR64encodeln</a> qkey
    <a class="fcnlink" href="#ph4_QueryR64decodeln"
	>ph4_QueryR64decodeln</a> [qkey, lines]

---------- <a href="#Access Keys">Access Keys</a> ----------

    fkey = <a class="fcnlink" href="#ph4_QueryFkeylist"
	>ph4_QueryFkeylist</a> qkey
    ckey = <a class="fcnlink" href="#ph4_QueryCkeylist"
	>ph4_QueryCkeylist</a> qkey
    vkey = <a class="fcnlink" href="#ph4_QueryVkeylist"
	>ph4_QueryVkeylist</a> qkey

    fcount = <a class="fcnlink" href="#ph4_QueryFcount"
	>ph4_QueryFcount</a> qkey
    ccount = <a class="fcnlink" href="#ph4_QueryCcount"
	>ph4_QueryCcount</a> qkey
    vcount = <a class="fcnlink" href="#ph4_QueryVcount"
	>ph4_QueryVcount</a> qkey

    fidx = <a class="fcnlink" href="#ph4_QueryFkeyidx"
	>ph4_QueryFkeyidx</a> [qkey, fkey]
    cidx = <a class="fcnlink" href="#ph4_QueryCkeyidx"
	>ph4_QueryCkeyidx</a> [qkey, ckey]
    vidx = <a class="fcnlink" href="#ph4_QueryVkeyidx"
	>ph4_QueryVkeyidx</a> [qkey, vkey]

---------- <a href="#Get/Set Data Contents">Get/Set Data Contents</a> ----------

    dvals = <a class="fcnlink" href="#ph4_QuerySdata"
	>ph4_QuerySdata</a> [qkey, dnames]
    <a class="fcnlink" href="#ph4_QuerySetSdata"
	>ph4_QuerySetSdata</a> [qkey, dnames, dvals]
    dvals = <a class="fcnlink" href="#ph4_QuerySetSdata"
	>ph4_QuerySetSdata</a> [qkey, dnames, dvals]

    dvals = <a class="fcnlink" href="#ph4_QueryFdata"
	>ph4_QueryFdata</a> [qkey, fkey, dnames]
    <a class="fcnlink" href="#ph4_QuerySetFdata"
	>ph4_QuerySetFdata</a> [qkey, fkey, dnames, dvals]
    dvals = <a class="fcnlink" href="#ph4_QuerySetFdata"
	>ph4_QuerySetFdata</a> [qkey, fkey, dnames, dvals]

    dvals = <a class="fcnlink" href="#ph4_QueryCdata"
	>ph4_QueryCdata</a> [qkey, ckey, dnames]
    <a class="fcnlink" href="#ph4_QuerySetCdata"
	>ph4_QuerySetCdata</a> [qkey, ckey, dnames, dvals]
    dvals = <a class="fcnlink" href="#ph4_QuerySetCdata"
	>ph4_QuerySetCdata</a> [qkey, ckey, dnames, dvals]

    dvals = <a class="fcnlink" href="#ph4_QueryVdata"
	>ph4_QueryVdata</a> [qkey, vkey, dnames]
    <a class="fcnlink" href="#ph4_QuerySetVdata"
	>ph4_QuerySetVdata</a> [qkey, vkey, dnames, dvals]
    dvals = <a class="fcnlink" href="#ph4_QuerySetVdata"
	>ph4_QuerySetVdata</a> [qkey, vkey, dnames, dvals]

---------- <a href="#Specific Structural Changes">Specific Structural Changes</a> ----------

    fnewkey = <a class="fcnlink" href="#ph4_QueryCreateF"
	>ph4_QueryCreateF</a> [qkey, fdata]
    fnewkey = <a class="fcnlink" href="#ph4_QueryCreateF"
	>ph4_QueryCreateF</a> [qkey, fdata, fdstkey]
    cnewkey = <a class="fcnlink" href="#ph4_QueryCreateC"
	>ph4_QueryCreateC</a> [qkey, cdata]
    cnewkey = <a class="fcnlink" href="#ph4_QueryCreateC"
	>ph4_QueryCreateC</a> [qkey, cdata, cdstkey]
    vnewkey = <a class="fcnlink" href="#ph4_QueryCreateV"
	>ph4_QueryCreateV</a> [qkey, vdata]
    vnewkey = <a class="fcnlink" href="#ph4_QueryCreateV"
	>ph4_QueryCreateV</a> [qkey, vdata, vdstkey]

    fnewkey = <a class="fcnlink" href="#ph4_QueryCopyF"
	>ph4_QueryCopyF</a> [qkey, fkey]
    fnewkey = <a class="fcnlink" href="#ph4_QueryCopyF"
	>ph4_QueryCopyF</a> [qkey, fkey, fdstkey]
    cnewkey = <a class="fcnlink" href="#ph4_QueryCopyC"
	>ph4_QueryCopyC</a> [qkey, ckey]
    cnewkey = <a class="fcnlink" href="#ph4_QueryCopyC"
	>ph4_QueryCopyC</a> [qkey, ckey, cdstkey]
    vnewkey = <a class="fcnlink" href="#ph4_QueryCopyV"
	>ph4_QueryCopyV</a> [qkey, vkey]
    vnewkey = <a class="fcnlink" href="#ph4_QueryCopyV"
	>ph4_QueryCopyV</a> [qkey, vkey, vdstkey]

    <a class="fcnlink" href="#ph4_QueryDeleteF"
	>ph4_QueryDeleteF</a> [qkey, fkey]
    <a class="fcnlink" href="#ph4_QueryDeleteC"
	>ph4_QueryDeleteC</a> [qkey, ckey]
    <a class="fcnlink" href="#ph4_QueryDeleteV"
	>ph4_QueryDeleteV</a> [qkey, vkey]

    <a class="fcnlink" href="#ph4_QueryPermuteF"
	>ph4_QueryPermuteF</a> [qkey, fsrckey, fdstkey]
    <a class="fcnlink" href="#ph4_QueryPermuteC"
	>ph4_QueryPermuteC</a> [qkey, csrckey, cdstkey]
    <a class="fcnlink" href="#ph4_QueryPermuteV"
	>ph4_QueryPermuteV</a> [qkey, vsrckey, vdstkey]

---------- <a href="#General Structural Utilities">General Structural Utilities</a> ----------

    err = <a class="fcnlink" href="#ph4_QueryDataErr"
	>ph4_QueryDataErr</a> qkey
    ok  = <a class="fcnlink" href="#ph4_QueryDataOK"
	>ph4_QueryDataOK</a> qkey

    <a class="fcnlink" href="#ph4_QueryDeleteAllFC"
	>ph4_QueryDeleteAllFC</a> qkey
    <a class="fcnlink" href="#ph4_QueryDeleteAllV"
	>ph4_QueryDeleteAllV</a> qkey
    <a class="fcnlink" href="#ph4_QueryDeleteAll"
	>ph4_QueryDeleteAll</a> qkey

    <a class="fcnlink" href="#ph4_QueryDeleteUselessC"
	>ph4_QueryDeleteUselessC</a> qkey
    <a class="fcnlink" href="#ph4_QueryDeleteUselessV"
	>ph4_QueryDeleteUselessV</a> qkey
    <a class="fcnlink" href="#ph4_QueryDeleteAllIgnored"
	>ph4_QueryDeleteAllIgnored</a> qkey

    <a class="fcnlink" href="#ph4_QueryCopyCat"
	>ph4_QueryCopyCat</a> [qkey, qkeylist]

---------- <a href="#Examples">Examples</a> ----------

    <a class="fcnlink" href="#ph4_QuerySoftenAllF"
	>ph4_QuerySoftenAllF</a> [qkey, fkey, sval]
    <a class="fcnlink" href="#ph4_QuerySoftenV"
	>ph4_QuerySoftenV</a> [qkey, vkey, sval]
    vnewkey = <a class="fcnlink" href="#ph4_QueryMergeV"
	>ph4_QueryMergeV</a> [qkey, vkey, vdstkey]
    vnewkey = <a class="fcnlink" href="#ph4_QueryDemergeV"
	>ph4_QueryDemergeV</a> [qkey, vkey, vdstkey]

---------- <a href="#Additional Utilities">Additional Utilities</a> ----------

    bitmask = <a class="fcnlink" href="#ph4_SchemeGetBitmaskAll"
	>ph4_SchemeGetBitmaskAll</a> [scheme, pnames]
    pvals = <a class="fcnlink" href="#ph4_SchemeExprProp"
	>ph4_SchemeExprProp</a> [scheme, expr, pnames, defval]
</pre>


<h2>Description</h2>

<p>Pharmacophore Query API allows SVL callers to create and modify
pharmacophore queries.  The user is <i>not</i> allowed to access any of the
data structures that store the ph4 query directly and must <i>always</i>
access them only via the provided API methods.  Note that some of
the "values" are not stored directly but calculated from other items,
even when the access is read-write.

<p>All code accessing the query should use the following pattern:
<pre>
    qkey = ph4_QueryOpen[];
    ph4_QueryReadFile [qkey, fn];	// or similar

	...	access and modify		...
	...	features/constraints/volumes	...

    ph4_QueryWriteFile [qkey, fn];	// or similar
    ph4_QueryClose qkey;
</pre>

<p>Each feature/constraint/volume item is accessed via its own unique key.
The list of all keys is returned by functions <tt>ph4_QueryF/C/Vkeylist</tt>.
The data associated with each item are accessible using functions
<tt>ph4_QueryF/C/Vdata</tt> and can be modified with functions
<tt>ph4_QuerySetF/C/Vdata</tt>.  For example, to increase the radii
of essential features by 23%:

<pre>
    fkey = ph4_QueryFkeylist;
    [m_essential, rad] = ph4_QueryFdata [q, fkey, ['essential','rad']];
    ph4_QuerySetFdata [q, fkey | m_essential, ['rad'], [rad * 1.23]];
</pre>

<p>To reorder items, create new items or delete old items, use structural
utilities, such as <tt>ph4_QueryPermuteF/C/V</tt> or
<tt>ph4_QueryCreateF/C/V</tt>.  For example, to append an excluded sphere
volume of a given center, <tt>ctr</tt>, and radius, <tt>rad</tt>, and
then sort volumes by type and delete all ignored volumes:

<pre>
    ph4_QueryCreateV [q, [mtype:'None', sphere_center:ctr, sphere_rad:rad]];
    vkey = ph4_QueryVkeylist;
    [mtype,ignored] = ph4_QueryVdata [q, vkey, ['mtype','ignored']];
    ph4_QueryPermuteV [q, vkey, vkey[x_sort mtype]];
    ph4_QueryDeleteV [q, vkey | ignored];
</pre>

<p>The query can be duplicated or composed from other queries with
<tt>ph4_QueryCopyCat</tt>.
<pre>
    [nf1, nf2, nf3] = app ph4_QueryFcount [q1, q2, q3];
    fkey = ph4_QueryCopy [q, [q1,q2,q3]];
    [fkey1, fkey2, fkey3] = split [fkey, [nf1, nf2, nf3]];
</pre>

<p><a name="ph4_QueryOpen"></a></p>
<p><hr noshade="noshade" />

<pre>
qkey = <span class="fcndef">ph4_QueryOpen</span> []
qkey = <span class="fcndef">ph4_QueryOpen</span> qkey
</pre>

<p>Open a new query context or reopen an existing context.  The
context will be open until the caller task calls ph4_QueryClose or
is terminated.  If a forked task needs to access the same query
context, it should reopen its key.


<p><a name="ph4_QueryClose"></a></p>
<p><hr noshade="noshade" />

<pre>
qkey = <span class="fcndef">ph4_QueryClose</span> qkey
</pre>

<p>Close the given query context and release all its resources.

<p><a name="ph4_QueryKey"></a></p>
<p><a name="ph4_QueryKeyOpen"></a></p>
<p><hr noshade="noshade" />

<pre>
qkey = <span class="fcndef">ph4_QueryKey</span> qkey
qkey = <span class="fcndef">ph4_QueryKeyOpen</span> qkey
</pre>

<p>Function <tt>ph4_QueryKey</tt> validates the given query key,
<tt>qkey</tt>.  If the key is valid, it is returned as-is.  Otherwise,
the function returns 0.

<p>Function <tt>ph4_QueryKeyOpen</tt> returns the same result
as <tt>ph4_QueryKey</tt>.  However, if the key is valid,
function <tt>ph4_QueryKeyOpen</tt> additionally opens
<tt>qkey</tt>.  If the key is valid, it is returned as-is.  Otherwise,
the function returns 0.

<!-- ********************************************************* -->
<p><a name="I/O Functions"></a></p>
<hr noshade="noshade" />
<h3>I/O Functions</h3>


<p><a name="ph4_QueryWriteFile"></a><p>
<p><hr noshade="noshade" />

<pre>
<span class="fcndef"
    >ph4_QueryWriteFile</span> [qkey, fn]
</pre>

<p>
Function <tt>ph4_QueryWriteFile</tt> writes query to a file or
a filehandle in a printable format that can be processed by non-SVL
programs, but is not as efficient as the <tt>ph4_QueryEncode/Decode</tt>
internal SVL format.

<p><a name="ph4_QueryReadFile"></a><p>
<p><hr noshade="noshade" />

<pre>
<span class="fcndef"
    >ph4_QueryReadFile</span> [qkey, fn]
</pre>

<p>
Function <tt>ph4_QueryReadFile</tt> reads query from a file or
a filehandle.  The current contents of the query is replaced (without
warning).

<p><a name="ph4_QueryWriteString"></a></p>
<p><hr noshade="noshade" />

<pre>
bstr = <span class="fcndef"
    >ph4_QueryWriteString</span> qkey
</pre>

<p>
Function <tt>ph4_QueryWriteString</tt> writes query to a string, using
the same format as <tt>ph4_QueryWriteFile</tt>.

<p><a name="ph4_QueryReadString"></a><p>
<p><hr noshade="noshade" />

<pre>
<span class="fcndef"
    >ph4_QueryReadString</span> [qkey, bstr]
</pre>

<p>
Function <tt>ph4_QueryReadString</tt> reads query from a string, using
the same format as <tt>ph4_QueryReadFile</tt>.  The current contents of
the query is replaced.

<p><a name="ph4_QueryEncode"</a></p>
<p><hr noshade="noshade" />

<pre>
bstr = <span class="fcndef"
    >ph4_QueryEncode</span> qkey
</pre>

<p>
Function <tt>ph4_QueryEncode</tt> writes query to a string of bytes using
an efficient internal format suitable to be sent through a socket or get
embedded in a binary file.  The contents of the string is meant to be
processed only by SVL.

<p><a name="ph4_QueryDecode"></a><p>
<p><hr noshade="noshade" />

<pre>
<span class="fcndef"
    >ph4_QueryDecode</span> [qkey, bstr]
</pre>

<p>
Function <tt>ph4_QueryDecode</tt> reads query from a string of bytes
encoded by <tt>ph4_QueryEncode</tt>.  The current contents of the
query is replaced.

<p><a name="ph4_QueryR64encodeln"></a><p>
<p><hr noshade="noshade" />

<pre>
lines = <span class="fcndef"
    >ph4_QueryR64encodeln</span> qkey
</pre>

<p>
Function <tt>ph4_QueryR64encode</tt> writes query to a vector of printable
lines suitable to be embedded in a text file.  The contents of the lines
is meant to be read only by SVL.

<p><a name="ph4_QueryR64decodeln"</a></p>
<p><hr noshade="noshade" />

<pre>
<span class="fcndef"
    >ph4_QueryR64decodeln</span> [qkey, lines]
</pre>

<p>
Function <tt>ph4_QueryR64decode</tt> reads query from a vector of strings
(lines) encoded by <tt>ph4_QueryR64encode</tt>.  The current contents of the
query is replaced.


<!-- ********************************************************* -->
<p><a name="Access keys"></a>
<hr noshade="noshade" />
<h3>Access keys</h3>

<p>Each feature/constraint/volume is accessed via its own unique key.
The keys are returned by functions <tt>ph4_Query<i>X</i>keylist</tt>,
where <tt><i>X</i></tt>=<tt>F,C,V</tt>.

<p>
Each key is guaranteed to be unique across the entire MOE/smp for the
lifetime of the application, but stays valid only until the query is
closed.  If the query is opened and restored, e.g. by reading it from a
file, its feature/constraint/volume keys will change.  However, their
relative positions, returned by functions
<tt>ph4_Query<i>X</i>keyidx</tt>, will stay intact.

<p><a name="ph4_QueryFkeylist"</a></p>
<p><hr noshade="noshade" />

<pre>
fkey = <span class="fcndef"
    >ph4_QueryFkeylist</span> qkey
</pre>

<p>
Function <tt>ph4_QueryFkeylist</tt> returns keys of all
features in the query.

<p><a name="ph4_QueryCkeylist"</a></p>
<p><hr noshade="noshade" />

<pre>
ckeys = <span class="fcndef"
    >ph4_QueryCkeylist</span> qkey
</pre>

<p>
Function <tt>ph4_QueryCkeylist</tt> returns keys of all
constraints in the query.

<p><a name="ph4_QueryVkeylist"</a></p>
<p><hr noshade="noshade" />

<pre>
vkeys = <span class="fcndef"
    >ph4_QueryVkeylist</span> qkey
</pre>

<p>
Function <tt>ph4_QueryVkeylist</tt> returns keys of all
volumes in the query.


<p><a name="ph4_QueryFcount"</a></p>
<p><hr noshade="noshade" />

<pre>
fcount = <span class="fcndef"
    >ph4_QueryFcount</span> qkey
</pre>

<p>
Function <tt>ph4_QueryFcount</tt> returns the number of all features in the
query.

<p><a name="ph4_QueryCcount"</a></p>
<p><hr noshade="noshade" />

<pre>
ccount = <span class="fcndef"
    >ph4_QueryCcount</span> qkey
</pre>

<p>
Function <tt>ph4_QueryCcount</tt> returns the number of all constraints in
the query.

<p><a name="ph4_QueryVcount"</a></p>
<p><hr noshade="noshade" />

<pre>
vcount = <span class="fcndef"
    >ph4_QueryVcount</span> qkey
</pre>

<p>
Function <tt>ph4_QueryVcount</tt> returns the number of all volumes in the
query.


<p><a name="ph4_QueryFkeyidx"</a></p>
<p><hr noshade="noshade" />

<pre>
fidx = <span class="fcndef"
    >ph4_QueryFkeyidx</span> [qkey, fkey]
</pre>

<p>
Function <tt>ph4_QueryFkeyidx</tt> returns, for each key, the position of
the corresponding feature in the query.

The function is a <i>unop</i> in the <tt>fkey</tt> argument.

<p><a name="ph4_QueryCkeyidx"</a></p>
<p><hr noshade="noshade" />

<pre>
cidx = <span class="fcndef"
    >ph4_QueryCkeyidx</span> [qkey, ckey]
</pre>

<p>
Function <tt>ph4_QueryCkeyidx</tt> returns, for each key, the position of
the corresponding constraint in the query.

The function is a <i>unop</i> in the <tt>ckey</tt> argument.

<p><a name="ph4_QueryVkeyidx"</a></p>
<p><hr noshade="noshade" />

<pre>
vidx = <span class="fcndef"
    >ph4_QueryVkeyidx</span> [qkey, vkey]
</pre>

<p>
Function <tt>ph4_QueryVkeyidx</tt> returns, for each key, the position of
the corresponding volume in the query.

The function is a <i>unop</i> in the <tt>vkey</tt> argument.

<!-- ********************************************************* -->
<p><a name="Get/Set Data Contents"></a>
<hr noshade="noshade" />
<h3>Get/Set Data Contents</h3>

<p>Each feature/constraint/volume is described by a number of parameters.
The functions that access and modify these parameters are called
<tt>ph4_Query<i>X</i>data</tt> and <tt>ph4_QuerySet<i>X</i>data</tt>,
where <tt><i>X</i></tt>=<tt>F,C,V,</tt>.  Each function must be given a set of
keys to affect, <tt>fkey/ckey/vkey</tt>, and a set of parameter names,
<tt>dnames</tt>.  Given a set of <i>n</i> keys and <i>m</i>
parameter names, each function gets or sets <i>n</i>&times;<i>m</i> values.
Values of unknown parameters names are set to <tt>[]</tt>.

<p>The positions and radii of features and volumes are rounded to the
nearest 1/1000 angstrom.

<p>Optionally, each set-function can also return the values of the set
parameters to the caller.  These values may sometimes differ from the
input arguments, e.g. when values of type <tt>'pos'</tt> or <tt>'rad'</tt>
are rounded or when values of type <tt>'idx'</tt> contain duplicates
and must be adjusted.

<p>Some parameter types, e.g. <tt>'sphere_count'</tt> are <i>read-only</i>
and cannot be set.

<p><a name="ph4_QuerySdata"</a></p>
<p><a name="ph4_QuerySetSdata"</a></p>
<p><hr noshade="noshade" />

<pre>
dvals = <span class="fcndef"
    >ph4_QuerySdata</span> [qkey, dnames]
<span class="fcndef"
    >ph4_QuerySetSdata</span> [qkey, dnames, dvals]
dvals = <span class="fcndef"
    >ph4_QuerySetSdata</span> [qkey, dnames, dvals]
</pre>

<p>
Function <tt>ph4_QuerySdata</tt> returns, for each name in <tt>dnames</tt>,
the value associated with that name.

<p>
Function <tt>ph4_QuerySetSdata</tt> sets, for each name in <tt>dnames</tt>,
the value associated with that name.  If the return value is requested, the
function returns the actual set values. (In this function, the set values
are identical to the input values.)

<p>Functions <tt>ph4_QuerySdata</tt> and <tt>ph4_QuerySetSdata</tt> support
the following <tt>dnames</tt> values:

<!-- ArgTable -->
<blockquote>
<table border=0 cellspacing=2 cellpadding=2>
<tr>
    <td valign="baseline"><tt>'scheme'</tt>
    </td><td valign="baseline">
	Scheme name (token).
    </td>
</tr><tr>
    <td valign="baseline"><tt>'msize_min'</tt>
    </td><td valign="baseline">
	Minimum match size (integer). Zero is interpreted "all".
	Negative value is interpreted as "all except".
    </td>
</tr><tr>
    <td valign="baseline"><tt>'title'</tt>
    </td><td valign="baseline">
	Single-line title visible in ph4 edit and search panels.
	The value is a token scalar.
    </td>
</tr><tr>
    <td valign="baseline"><tt>'comment'</tt>
    </td><td valign="baseline">
	Multi-line description of the contents of the ph4 query.
	The value is a flat vector of characters.
    </td>
</tr><tr>
    <td valign="baseline"><i>unknown</i>
    </td><td valign="baseline">
	Empty vector (<tt>[]</tt>).
    </td>
</tr>
</table>
</blockquote>
<!-- EndArgTable -->



<p><a name="ph4_QueryFdata"</a></p>
<p><a name="ph4_QuerySetFdata"</a></p>
<p><hr noshade="noshade" />

<pre>
dvals = <span class="fcndef"
    >ph4_QueryFdata</span> [qkey, fkey, dnames]
<span class="fcndef"
    >ph4_QuerySetFdata</span> [qkey, fkey, dnames, dvals]
dvals = <span class="fcndef"
    >ph4_QuerySetFdata</span> [qkey, fkey, dnames, dvals]
</pre>

<p>
Function <tt>ph4_QueryFdata</tt> returns, for each name in <tt>dnames</tt>,
a vector of values associated with that name.  The values are retrieved
only from features specified by the vector of keys, <tt>fkey</tt>.

The result is an <i>n</i>&times;<i>m</i> matrix of <i>n</i> vectors,
<i>n</i>&nbsp;=&nbsp;<tt>length&nbsp;dnames</tt>,
with each vector composed of <i>m</i>
elements, <i>m</i>&nbsp;=&nbsp;<tt>length&nbsp;fkey</tt>.

<p>
The function is a <i>unop</i> in the <tt>fkey</tt> argument.

For example, if keys <tt>f1</tt>, <tt>f2</tt>, <tt>f3</tt>
refer to features with the following values:

<pre>    f1 ::= [expr:'Acc', rad:1.1];
    f2 ::= [expr:'Cat', rad:1.2];
    f3 ::= [expr:'Don', rad:1.3];
    ... </pre>

then

<pre>     r = ph4_QueryFdata [q, [f1, [f2, f3, ...]], ['expr', 'rad']];</pre>

will return

<pre>     r = [['Acc', ['Cat', 'Don', ...]], [1.1, [1.2, 1.3, ...]]]</pre>

<p>
Function <tt>ph4_QuerySetFdata</tt> sets, for each name in <tt>dnames</tt>,
the value associated with that name.  If the return value is requested, the
function returns the actual set values. 

Note that the set values may differ from the input values, e.g.
when the input positions or radii are rounded to the nearest 1/1000 angstrom
or when the input <tt>'idx'</tt> values contain duplicates.

<p>
The function is a <i>unop</i> in the <tt>fkey</tt> argument.  The
<tt>dvals</tt> argument must be of the same length as <tt>dnames</tt>.
Each <tt>dvals(i)</tt> will unit-extend to the shape of <tt>fkey</tt>.

For example, if

<pre>    e = ['Acc', ['Don']];
    r = [1.1];</pre>

then

<pre>    ph4_QuerySetFdata [q, [f1, [f2, f3, ...]], ['expr', 'rad'], [e, r]];</pre>

will reset the feature values to:

<pre>    f1 ::= [expr:'Acc', rad:1.1, ...];
    f2 ::= [expr:'Don', rad:1.1, ...];
    f3 ::= [expr:'Don', rad:1.1, ...];
    ...
</pre>


<p>Functions <tt>ph4_QueryFdata</tt> and <tt>ph4_QuerySetFdata</tt> support
the following <tt>dnames</tt> values:

<!-- ArgTable -->
<blockquote>
<table border=0 cellspacing=2 cellpadding=2>
<tr>
    <td valign="baseline"><tt>'idx'</tt>
    </td><td valign="baseline">
	Position of the feature in the list of all features.
    </td>
</tr><tr>
    <td valign="baseline"><tt>'ignored'</tt>
    </td><td valign="baseline">
	Set to 1 on features that will <i>not</i> be matched by the ph4 search.
    </td>
</tr><tr>
    <td valign="baseline"><tt>'essential'</tt>
    </td><td valign="baseline">
	Set to 1 on features that <i>must</i> be matched by the ph4 search.
    </td>
</tr><tr>
    <td valign="baseline"><tt>'expr'</tt>
    </td><td valign="baseline">
	Matching expression, e.g. <tt>'Don&amp;Acc | Cat'</tt>.
    </td>
</tr><tr>
    <td valign="baseline"><tt>'pos'</tt>
    </td><td valign="baseline">
	Feature position, rounded to the nearest 1/1000 angstrom.
    </td>
</tr><tr>
    <td valign="baseline"><tt>'rad'</tt>
    </td><td valign="baseline">
	Feature size, rounded to the nearest 1/1000 angstrom.
    </td>
</tr><tr>
    <td valign="baseline"><tt>'color'</tt>
    </td><td valign="baseline">
	RGB color of features shown in the 3D window by the ph4 editor.
    </td>
</tr><tr>
    <td valign="baseline"><tt>'hidden'</tt>
    </td><td valign="baseline">
	Set to 1 on features that will not be shown in the 3D window
	by the ph4 editor.
    </td>
</tr><tr>
    <td valign="baseline"><i>unknown</i>
    </td><td valign="baseline">
	Empty vector (<tt>[]</tt>).
    </td>
</tr>
</table>
</blockquote>
<!-- EndArgTable -->

<p>Additionally, the function <tt>ph4_QueryFdata</tt> supports
the following (read-only) <tt>dnames</tt> values:

<!-- ArgTable -->
<blockquote>
<table border=0 cellspacing=2 cellpadding=2>
<tr>
    <td valign="baseline"><tt>'ckeys'</tt>
    </td><td valign="baseline">
	Keys of constraints that affect the feature.
    </td>
</tr><tr>
    <td valign="baseline"><tt>'expr_AtomQ'</tt>
    </td><td valign="baseline">
	Any annotation point that can match the feature is heavy-atom-based.
    </td>
</tr><tr>
    <td valign="baseline"><tt>'expr_Projected'</tt>
    </td><td valign="baseline">
	Any annotation point that can match the feature is a projected point.
    </td>
</tr><tr>
    <td valign="baseline"><tt>'expr_Projecting'</tt>
    </td><td valign="baseline">
	Any annotation point that can match the feature is a projecting point.
    </td>
    </td>
</tr><tr>
    <td valign="baseline"><tt>'expr_OK'</tt>
    </td><td valign="baseline">
	Set to 1 on features whose expression (including SMARTS, if any)
	is syntactically valid.
    </td>
</tr><tr>
    <td valign="baseline"><tt>'expr_Err'</tt>
    </td><td valign="baseline">
	The error message of syntactically invalid feature expressions,
	or empty token otherwise.
    </td>
</tr>
</table>
</blockquote>
<!-- EndArgTable -->

<p>
<i>Note:</i>
The value of the <tt>expr_Xxx</tt> properties above depends on the
scheme used.


<p><a name="ph4_QueryCdata"</a></p>
<p><a name="ph4_QuerySetCdata"</a></p>
<p><hr noshade="noshade" />

<pre>
dvals = <span class="fcndef"
    >ph4_QueryCdata</span> [qkey, ckey, dnames]
<span class="fcndef"
    >ph4_QuerySetCdata</span> [qkey, ckey, dnames, dvals]
dvals = <span class="fcndef"
    >ph4_QuerySetCdata</span> [qkey, ckey, dnames, dvals]
</pre>

<p>
Function <tt>ph4_QueryCdata</tt> returns, for each name in <tt>dnames</tt>,
a vector of values associated with that name.  The values are retrieved
only from constraints specified by the vector of keys, <tt>ckey</tt>.

The result is an <i>n</i>&times;<i>m</i> matrix of <i>n</i> vectors,
<i>n</i>&nbsp;=&nbsp;<tt>length&nbsp;dnames</tt>,
with each vector composed of <i>m</i>
elements, <i>m</i>&nbsp;=&nbsp;<tt>length&nbsp;ckey</tt>.

<p>
The function is a <i>unop</i> in the <tt>ckey</tt> argument.

<p>
Function <tt>ph4_QuerySetCdata</tt> sets, for each name in <tt>dnames</tt>,
the value associated with that name.  If the return value is requested,
the function returns the actual set values.

Note that the set values may differ from the input values, e.g.
when the input <tt>'idx'</tt> values contain duplicates.

<p>
The function is a <i>unop</i> in the <tt>ckey</tt> argument.  The dvals
argument must be of the same length as <tt>dnames</tt>.  Each
<tt>dvals(i)</tt> will unit-extend to the shape of <tt>ckey</tt>.

<p>Functions <tt>ph4_QueryCdata</tt> and <tt>ph4_QuerySetCdata</tt> support
the following <tt>dnames</tt> values:

<!-- ArgTable -->
<blockquote>
<table border=0 cellspacing=2 cellpadding=2>
<tr>
    <td valign="baseline"><tt>'idx'</tt>
    </td><td valign="baseline">
	Position of the constraint in the list of all constraints.
    </td>
</tr><tr>
    <td valign="baseline"><tt>'ignored'</tt>
    </td><td valign="baseline">
	Set to 1 on features that will <i>not</i> be matched by the ph4 search.
    </td>
</tr><tr>
    <td valign="baseline"><tt>'expr'</tt>
    </td><td valign="baseline">
	Constraint expression, e.g. <tt>'&gt;1'</tt> or <tt>'SameA'</tt>.
	(See <i>Constraint Type</i> below.)
    </td>
</tr><tr>
    <td valign="baseline"><tt>'fkeys'</tt>
    </td><td valign="baseline">
	Keys of constrained features.
    </td>
</tr><tr>
    <td valign="baseline"><i>unknown</i>
    </td><td valign="baseline">
	Empty vector (<tt>[]</tt>).
    </td>
</tr>
</table>
</blockquote>
<!-- EndArgTable -->

<p><i>Constraint Type:</i>
The <tt>dval</tt> values of parameter <tt>'expr'</tt> specify the
condition that the constrained features must satisfy in order
for the query to be accepted by the ph4 search.  Valid values
include the following:

<!-- ArgTable -->
<blockquote>
<table border=0 cellspacing=2 cellpadding=2>
<tr>
    <td valign="baseline"><tt>'0'</tt>
    </td><td valign="baseline">
	Match either all or none of the specified features.
    </td>
</tr><tr>
    <td valign="baseline"><tt>'=1','=2'</tt>
    </td><td valign="baseline">
	Match at exactly <i>n</i> of the specified features,
	<i>n</i> = 1, 2.
    </td>
</tr><tr>
    <td valign="baseline"><tt>'&gt;1','&gt;2','&gt;3','&gt;4','&gt;5'</tt>
    </td><td valign="baseline">
	Match at least <i>n</i> of the specified features,
	<i>n</i> = 1, 2, 3, 4, 5.
    </td>
</tr><tr>
    <td valign="baseline"><tt>'SameA'</tt>
    </td><td valign="baseline">
	Matched features must use the same defining atom or the same
	set of defining atoms.
    </td>
</tr><tr>
    <td valign="baseline"><tt>'ShareA'</tt>
    </td><td valign="baseline">
	Matched features must share some of their defining atoms:
	their sets of defining atoms must intersect.
    </td>
</tr>
</table>
</blockquote>
<!-- EndArgTable -->

<p>Additionally, the function <tt>ph4_QueryFdata</tt> supports
the following (read-only) <tt>dnames</tt> value:

<!-- ArgTable -->
<blockquote>
<table border=0 cellspacing=2 cellpadding=2>
<tr>
    <td valign="baseline"><tt>fcount</tt>
    </td><td valign="baseline">
	The number of constrained features.
    </td>
</tr>
</table>
</blockquote>
<!-- EndArgTable -->

<p><a name="ph4_QueryVdata"</a></p>
<p><a name="ph4_QuerySetVdata"</a></p>
<p><hr noshade="noshade" />

<pre>
dvals = <span class="fcndef"
    >ph4_QueryVdata</span> [qkey, vkey, dnames]
<span class="fcndef"
    >ph4_QuerySetVdata</span> [qkey, vkey, dnames, dvals]
dvals = <span class="fcndef"
    >ph4_QuerySetVdata</span> [qkey, vkey, dnames, dvals]
</pre>

<p>
Function <tt>ph4_QueryVdata</tt> returns, for each name in <tt>dnames</tt>,
a vector of values associated with that name.  The values are retrieved
only from volumes specified by the vector of keys, <tt>vkey</tt>.

The result is an <i>n</i>&times;<i>m</i> matrix of <i>n</i> vectors,
<i>n</i>&nbsp;=&nbsp;<tt>length&nbsp;dnames</tt>,
with each vector composed of <i>m</i>
elements, <i>m</i>&nbsp;=&nbsp;<tt>length&nbsp;vkey</tt>.

<p>
The function is a <i>unop</i> in the <tt>vkey</tt> argument.

<p><tt>ph4_QuerySetVdata</tt> sets, for each name in <tt>dnames</tt>,
the value associated with that name.  If the return value is requested,
the function returns the actual set values.

Note that the set values may differ from the input values, e.g.
when the input positions or radii are rounded to the nearest 1/1000 angstrom
or when the input <tt>'idx'</tt> values contain duplicates.

<p>
The function is a <i>unop</i> in the <tt>vkey</tt> argument.  The dvals
argument must be of the same length as <tt>dnames</tt>.  Each
<tt>dvals(i)</tt> will unit-extend to the shape of <tt>vkey</tt>.

<p>Functions <tt>ph4_QueryVdata</tt> and <tt>ph4_QuerySetVdata</tt> support
the following <tt>dnames</tt> values:

<!-- ArgTable -->
<blockquote>
<table border=0 cellspacing=2 cellpadding=2>
<tr>
    <td valign="baseline"><tt>'idx'</tt>
    </td><td valign="baseline">
	Position of the volume in the list of all volumes.
    </td>
</tr><tr>
    <td valign="baseline"><tt>'ignored'</tt>
    </td><td valign="baseline">
	Set to 1 on volumes that will be ignored by the ph4 search.
    </td>
</tr><tr>
    <td valign="baseline"><tt>'expr'</tt>
    </td><td valign="baseline">
	SMARTS expression; <tt>''</tt> means <i>any heavy atom</i>.
    </td>
</tr><tr>
    <td valign="baseline"><tt>'mtype'</tt>
    </td><td valign="baseline">
	Atom match type.  (See <i>Volume Match Type</i> below.)
    </td>
</tr><tr>
    <td valign="baseline"><tt>'gtype'</tt>
    </td><td valign="baseline">
	Volume geometry.  (See <i>Volume Geometry</i> below.)
    </td>
</tr><tr>
    <td valign="baseline"><tt>'pos'</tt>
    </td><td valign="baseline">
	Position.
	In volumes of <tt>gtype</tt> <tt>'SphereUnion'</tt>, it is
	the centroid of all spheres.
    </td>
</tr><tr>
    <td valign="baseline"><tt>'rad'</tt>
    </td><td valign="baseline">
	Size.
	In volumes of <tt>gtype</tt> <tt>'SphereUnion'</tt>, it is
	the radius of the largest sphere.
    </td>
</tr><tr>
    <td valign="baseline"><tt>'sphere_center'</tt>
    </td><td valign="baseline">
	Laminated xyz coordinates of centers of all sphere that comprise
	volumes of type <tt>'SphereUnion'</tt>.
	Set to <tt>[]</tt> otherwise.
    </td>
</tr><tr>
    <td valign="baseline"><tt>'sphere_rad'</tt>
    </td><td valign="baseline">
	Radii of all spheres that comprise volumes
	of type <tt>'SphereUnion'</tt>.
	Set to <tt>[]</tt> otherwise.
    </td>
</tr><tr>
    <td valign="baseline"><tt>'color'</tt>
    </td><td valign="baseline">
	RGB color of volumes shown in the 3D window by the ph4 editor.
    </td>
</tr><tr>
    <td valign="baseline"><tt>'hidden'</tt>
    </td><td valign="baseline">
	Set to 1 on volumes that will not be shown in the 3D window
	by the ph4 editor.
    </td>
</tr><tr>
    <td valign="baseline"><i>unknown</i>
    </td><td valign="baseline">
	Empty vector (<tt>[]</tt>).
    </td>
</tr>
</table>
</blockquote>
<!-- EndArgTable -->

<p>Additionally, the function <tt>ph4_QueryVdata</tt> supports
the following (read-only) <tt>dnames</tt> values:

<!-- ArgTable -->
<blockquote>
<table border=0 cellspacing=2 cellpadding=2>
<tr>
    <td valign="baseline"><tt>'sphere_count'</tt>
    </td><td valign="baseline">
	The number of spheres comprising the volume of type
	<tt>'SphereUnion'</tt>.  Set to 0 otherwise.
    </td>
</tr><tr>
    <td valign="baseline"><tt>'expr_OK'</tt>
    </td><td valign="baseline">
	Set to 1 on volumes whose expression (i.e. the SMARTS string)
	is syntactically valid.
    </td>
</tr><tr>
    <td valign="baseline"><tt>'expr_Err'</tt>
    </td><td valign="baseline">
	The error message of syntactically invalid volume expressions,
	or empty token otherwise.
    </td>
</tr>
</table>
</blockquote>
<!-- EndArgTable -->

<p><i>Volume Match Type:</i>
The <tt>dval</tt> values of parameter <tt>'mtype'</tt> specify how
the atoms that match the volume expression are interpreted by
the ph4 search:

<!-- ArgTable -->
<blockquote>
<table border=0 cellspacing=2 cellpadding=2>
<tr>
    <td valign="baseline"><tt>'None'</tt>
    </td><td valign="baseline">
	"Excluded" volume: no matched atoms allowed in the interior.
    </td>
</tr><tr>
    <td valign="baseline"><tt>'Some'</tt>
    </td><td valign="baseline">
	"Included" volume: some matched atoms must be in the interior
    </td>
</tr><tr>
    <td valign="baseline"><tt>'All'</tt>
    </td><td valign="baseline">
	"Exterior" volume: all matched atoms must be in the interior
    </td>
</tr>
</table>
</blockquote>
<!-- EndArgTable -->

<p><i>Volume Geometry:</i>
The <tt>dval</tt> values of parameter <tt>'gtype'</tt> specify
the volume geometry.  Currently, there is only one possible value:

<!-- ArgTable -->
<blockquote>
<table border=0 cellspacing=2 cellpadding=2>
<tr>
    <td valign="baseline"><tt>'SphereUnion'</tt>
    </td><td valign="baseline">
	A single sphere or a union of several spheres.
    </td>
</tr>
</table>
</blockquote>
<!-- EndArgTable -->

<!-- ********************************************************* -->
<p><a name="Specific Structural Changes"></a>
<hr noshade="noshade" />
<h3>Specific Structural Changes</h3>

<p>
Functions in this chapter can be used to create, duplicate, delete
or permute specified features/constraints/volumes of the query.

<p><i>Destination Keys:</i>

Some of the functions use a vector of <i>destination keys</i>,
<tt>fdstkey/cdstkey/vdstkey</tt>, to specify
the destination positions of the new/duplicated/moved
features/constraints/volumes.


Two additional, non-key values can be used in this argument:

<!-- ArgTable -->
<blockquote>
<table border=0 cellspacing=2 cellpadding=2>
<tr>
    <td valign="baseline">0
    </td><td valign="baseline">
	The positions before the first item.
    </td>
</tr><tr>
    <td valign="baseline"><i>Inf</i>
    </td><td valign="baseline">
	The positions after the last item.
    </td>
</tr>
</table>
</blockquote>
<!-- EndArgTable -->

If the vector of destination keys is shorter that the number of items
that must be positioned, the remaining items are appended after the last
destination position specified.  If the vector of destination keys is
empty, all items are appended at the end.

<p><a name="ph4_QueryCreateF"</a></p>
<p><a name="ph4_QueryCreateC"</a></p>
<p><a name="ph4_QueryCreateV"</a></p>
<p><hr noshade="noshade" />

<pre>
fnewkey = <span class="fcndef"
    >ph4_QueryCreateF</span> [qkey, fdata]
fnewkey = <span class="fcndef"
    >ph4_QueryCreateF</span> [qkey, fdata, fdstkey]

cnewkey = <span class="fcndef"
    >ph4_QueryCreateC</span> [qkey, cdata]
cnewkey = <span class="fcndef"
    >ph4_QueryCreateC</span> [qkey, cdata, cdstkey]

vnewkey = <span class="fcndef"
    >ph4_QueryCreateV</span> [qkey, vdata]
vnewkey = <span class="fcndef"
    >ph4_QueryCreateV</span> [qkey, vdata, vdstkey]
</pre>

<p>

Function

<tt>ph4_QueryCreate<i>X</i></tt>,
<tt><i>X</i></tt>=<tt>F,C,V</tt>,

appends <i>n</i> new
features/constraints/volumes, with the contents of the <tt>i</tt>-th
new feature specified by a tagvector

<tt><i>x</i>data(i)</tt>, <tt><i>x</i></tt>=<tt>f,c,v</tt>,
<tt>i</tt>=1..<i>n</I>.

The tagvector needs to specify only values that different
from their new-feature default, e.g.

<pre>    [pos:[3.1,5,1.2],&nbsp;rad:1.2]</pre>

The optional vector of destination keys,
<tt>fdstkey/cdstkey/vdstkey</tt>, specifies the destination
positions of the new features. (See < i>Destination Keys</i>
above for the interpretation of the destination keys).

If the return value is requested, the function returns the (new) keys of
the created features.


<p><a name="ph4_QueryCopyF"</a></p>
<p><a name="ph4_QueryCopyC"</a></p>
<p><a name="ph4_QueryCopyV"</a></p>
<p><hr noshade="noshade" />

<pre>
fnewkey = <span class="fcndef"
    >ph4_QueryCopyF</span> [qkey, fkey]
fnewkey = <span class="fcndef"
    >ph4_QueryCopyF</span> [qkey, fkey, fdstkey]

fnewkey = <span class="fcndef"
    >ph4_QueryCopyC</span> [qkey, ckey]
fnewkey = <span class="fcndef"
    >ph4_QueryCopyC</span> [qkey, ckey, cdstkey]

fnewkey = <span class="fcndef"
    >ph4_QueryCopyV</span> [qkey, vkey]
fnewkey = <span class="fcndef"
    >ph4_QueryCopyV</span> [qkey, vkey, vdstkey]
</pre>

<p>
Function

<tt>ph4_QueryCopy<i>X</i></tt>,
<tt><i>X</i></tt>=<tt>F,C,V</tt>,

appends <i>n</i> new
features/constraints/volumes that duplicate items specified by keys
<tt><i>x</i>key(i)</tt>, <tt><i>x</i></tt>=<tt>f,c,v</tt>,
<tt>i</tt>=1..<i>n</I>.

The optional vector of destination keys,
<tt>fdstkey/cdstkey/vdstkey</tt>, specifies the destination
positions of the new features. (See note <i>Destination Keys</i>
above for the interpretation of the destination keys).

Each duplicate receives a new key.

If the return value is requested, the function returns the (new) keys of
the created features.

<p>
<i>Note:</i>
When features are duplicated, the (new) duplicates will <i>not</i>
be automatically constrained by the constraints that affect the original
features.  To do add the new features to the old constraints, use:

<pre>    ckey = ph4_QueryCkeylist q;
    [_fkeys_] = ph4_QueryCdata [q, ckey, 'fkeys'];
    _fkeys_ = apt cat [_fkeys_, [newfkey] || _fkeys_ == [fkey]];
    ph4_QuerySetCdata [q, ckey, 'fkeys', [_fkeys_]];
</pre>


<p><a name="ph4_QueryDeleteF"</a></p>
<p><a name="ph4_QueryDeleteC"</a></p>
<p><a name="ph4_QueryDeleteV"</a></p>
<p><hr noshade="noshade" />

<pre>
<span class="fcndef"
    >ph4_QueryDeleteF</span> [qkey, fkey]
<span class="fcndef"
    >ph4_QueryDeleteC</span> [qkey, ckey]
<span class="fcndef"
    >ph4_QueryDeleteV</span> [qkey, vkey]
</pre>

<p>
Function

<tt>ph4_QueryDelete<i>X</i></tt>,
<tt><i>X</i></tt>=<tt>F,C,V</tt>,

deletes <i>n</i>
features/constraints/volumes specified by keys
<tt><i>x</i>key(i)</tt>, <tt><i>x</i></tt>=<tt>f,c,v</tt>,
<tt>i</tt>=1..<i>n</I>.

<p><i>Note:</i>
When features are deleted,
the constraints that, as a result, become empty will <i>not</i>
be automatically deleted.

<p><i>Note:</i>
Unlike other <tt>ph4_QueryXxx</tt> functions that accept keys,
<tt>ph4_QueryDelete<i>X</i></tt> functions do <i>not</i> report
an error when given an illegal key value.

<p><i>Example:</i> To delete all ignored features:
<pre>
    [m_i] = ph4_QueryFdata [q, fkey, ['ignored']];
    ph4_QueryDeleteF [q, fkey | m_i];
</pre>

<p><i>Example:</i> To delete all empty constraints:
<pre>
    [c] = ph4_QueryCdata [q, ckey, ['fcount']];
    ph4_QueryDeleteC [q, ckey | c==0];
</pre>

<p><i>Example:</i> To delete all empty excluded volumes:
<pre>
    [g,m,c] = ph4_QueryVdata [q, vkey, ['gtype', 'mtype', 'sphere_count']];
    ph4_QueryDeleteC [q, vkey | g=='SphereUnion' and m=='None' and c==0];
</pre>


<p><a name="ph4_QueryPermuteF"</a></p>
<p><a name="ph4_QueryPermuteC"</a></p>
<p><a name="ph4_QueryPermuteV"</a></p>
<p><hr noshade="noshade" />

<pre>
<span class="fcndef"
    >ph4_QueryPermuteF</span> [qkey, fsrckey, fdstkey]
<span class="fcndef"
    >ph4_QueryPermuteC</span> [qkey, csrckey, cdstkey]
<span class="fcndef"
    >ph4_QueryPermuteV</span> [qkey, vsrckey, vdstkey]
</pre>

<p>
Function

<tt>ph4_QueryPermute<i>X</i></tt>,
<tt><i>X</i></tt>=<tt>F,C,V</tt>,

permutes the order of features specified by a vector
of unique keys,

<tt><i>x</i>srckey</tt>, <tt><i>x</i></tt>=<tt>f,c,v</tt>.

The permutation is specified by a vector of the same (unique) keys,
given in their desired new order, <tt><i>x</i>dstkey</tt>.

<!-- ********************************************************* -->
<p><a name="General Structural Utilities"></a>
<hr noshade="noshade" />
<h3>General Structural Utilities</h3>

<p>
Functions in this chapter affect or modify the entire query.
There is not specification of features/constraints/volumes
of the query to be affected.

<p><a name="ph4_QueryDataErr"</a></p>
<p><a name="ph4_QueryDataOK"</a></p>
<p><hr noshade="noshade" />

<pre>
err = <span class="fcndef"
    >ph4_QueryDataErr</span> qkey
ok  = <span class="fcndef"
    >ph4_QueryDataOK</span> qkey
</pre>

<p>
Function <tt>ph4_QueryDataError</tt> determines whether the given query
can be used by the ph4 search without generating errors.  If no errors
are detected, the function returns an empty token (<tt>''</tt>).  Otherwise,
the function returns a single token containing the first error found.

<p>
Function <tt>ph4_QueryDataOK</tt> simply returns 0 on error and 1 otherwise.

<p>
<i>Note</i>:

Since the validity of some parameters depends on the value of other
parameters, which may change (e.g. the validity of feature expressions
depends on the value of the scheme parameter), it is not enough for each
individual <tt>ph4_QuerySetF/C/Vdata</tt> call to succeed: the validity
of the query should checked with <tt>ph4_QueryDataOK</tt> at such a time
when the query values will no longer change.

<p>
<i>Warning</i>:

The function <tt>ph4_QueryDataOK</tt> assumes that the query has been
generated by valid API calls.  The function checks only for errors that
can arise by an illegal combination of otherwise legal values.  If the
query has been modified by other means, e.g. by directly accessing the
underlying structures, the function will not return a correct answer.

<p><a name="ph4_QueryDeleteAllFC"</a></p>
<p><a name="ph4_QueryDeleteAllV"</a></p>
<p><a name="ph4_QueryDeleteAll"</a></p>
<p><hr noshade="noshade" />

<pre>
<span class="fcndef"
    >ph4_QueryDeleteAllFC</span> qkey
<span class="fcndef"
    >ph4_QueryDeleteAllV</span> qkey
<span class="fcndef"
    >ph4_QueryDeleteAll</span> qkey
</pre>

<p>
Function <tt>ph4_QueryDeleteAllFC</tt> deletes all features and constraints
in the query.

<p>
Function <tt>ph4_QueryDeleteAllV</tt> deletes all volumes in the query.

<p>
Function <tt>ph4_QueryDeleteAll</tt> deletes all features, constraints and
volumes in the query.


<p><a name="ph4_QueryDeleteUselessC"</a></p>
<p><hr noshade="noshade" />

<pre>
<span class="fcndef"
    >ph4_QueryDeleteUselessC</span> qkey
</pre>

<p>
Function <tt>ph4_QueryDeleteUselessC</tt> deletes all empty or otherwise
useless constraints.  Ignored constraints that are not empty are
<i>not</i> deleted.

<p><a name="ph4_QueryDeleteUselessV"</a></p>
<p><hr noshade="noshade" />

<pre>
<span class="fcndef"
    >ph4_QueryDeleteUselessV</span> qkey
</pre>

<p>
Function <tt>ph4_QueryDeleteUselessV</tt> deletes all useless volumes,
such as a union of empty excluded spheres.  Ignored volumes that are
not empty are <tt>not</tt> deleted.


<p><a name="ph4_QueryDeleteAllIgnored"</a></p>
<p><hr noshade="noshade" />

<pre>
<span class="fcndef"
    >ph4_QueryDeleteAllIgnored</span> qkey
</pre>

<p>
Function <tt>ph4_QueryDeleteAllIgnored</tt> deletes all ignored or
useless features, constraints and volumes.


<p><a name="ph4_QueryCopyCat"</a></p>
<p><hr noshade="noshade" />

<pre>
<span class="fcndef"
    >ph4_QueryCopyCat</span> [qkey, qkeylist]
</pre>

<p>

Function <tt>ph4_QueryCopyCat</tt> replaces the given query, <tt>qkey</tt>,
with the concatenated contents of a list of queries, <tt>qkeylist</tt>.  Each
<tt>qkeylist(i)</tt> must be a valid query key.  However, the list may
contain duplicates and/or the replaced query, <tt>qkey</tt>, itself.

All queries in <tt>qkeylist</tt> <i>must</i> use the same scheme.  The
match size of the result will be set to the added match sizes of the
combined queries, keeping the sign of the match size of
<tt>qkeylist(1)</tt>.

For example, if <tt>qkeylist</tt> contains two queries, one with
<tt>msize_min</tt>=-2 and the other with <tt>msize_min</tt>=-3,

then the match size of the concatenated query, <tt>qkey</tt>,
will be set to <tt>msize_min</tt>=-5.

<p>
<i>Note</i>: All keys in <tt>qkey</tt> will change, even when the query
is copied to itself, i.e.

<pre>    ph4_QueryCopyCat&nbsp;[qkey, qkey]</pre>

Constraints of duplicated queries will <i>not</i> be merged.

<!-- ********************************************************* -->
<p><a name="Examples"></a>
<hr noshade="noshade" />
<h3>Examples</h3>

<p>The following utilities can serve as examples of using the Ph4 Query API 
functions.  They manipulate the input query only via calls to API functions.


<p><a name="ph4_QuerySoftenAllF"</a></p>
<p><hr noshade="noshade" />

<pre>
<span class="fcndef"
    >ph4_QuerySoftenAllF</span> [qkey, sval]
</pre>

<p> Function <tt>ph4_QuerySoftenAllF</tt> makes the query features
easier (<tt>sval</tt>&gt;0) or harder (<tt>sval</tt>&gt;0) to match by
increasing or decreasing the feature radii.  The <tt>sval</tt> argument
specifies the percentage by which the radii should be increased or decreased.

<p><i>Note</i>:
To modify the feature radii, a multiplicative (not additive) factor must be
used to keep the relative weight of matched features intact.

<blockquote>
<pre>
local function soften_f [r, s] = r * maxE [1, 1+s] * invz maxE [1, 1-s];

global function ph4_QuerySoftenAllF [q, sval]
    local fkey = ph4_QueryFkeylist q;
    local [rad] = ph4_QueryFdata [q, fkey, ['rad']];
    ph4_QuerySetFdata [q, fkey, ['rad'], [soften_f [rad, sval]]];
endfunction
</pre>
</blockquote>

<p><a name="ph4_QuerySoftenV"</a></p>
<p><hr noshade="noshade" />

<pre>
<span class="fcndef"
    >ph4_QuerySoftenV</span> [qkey, vkey, sval]
</pre>

<p> Function <tt>ph4_QuerySoftenV</tt> makes the query volumes easier
(<tt>sval</tt> &gt; 0) or harder (<tt>sval</tt> &gt; 0) to match by
increasing/decreasing the volume sizes.  The <tt>sval</tt> argument
specifies, in angstroms, an additive increment or decrement of the radii,
except for very small radii.

<p><i>Note</i>:
To modify the volume radii, which can be large and differ significantly
from each other, an additive factor is more appropriate than the
multiplicative factor used for the feature radii.

The formula has been designed so that if the volumes are
softened by <tt>sval</tt> and then (de_softened again by the opposite
value (<tt>-sval</tt>), they will return to their original size
(except for rounding errors.)

<blockquote>
<pre>
local function soften_v [r, s]
    local m2 = s &gt; 0 and r &lt;= 1;	// small radii grow as a percentage
    local m3 = s &lt;= 0 and r+s &lt;= 1;	// small radii shrink as a percentage
    local m1 = not m2 and not m3;	// big radii grow/shrink as an offset

    if alltrue m1 then return r+s; endif	// no small radii
    return (r+s*m1) * (1+s*m2) * invz (1-s*m3);	// need a binop (not select)
endfunction

global function ph4_QuerySoftenV [q, vkey, sval]
    local [gtype, mtype] = ph4_QueryVdata [q, vkey, ['gtype', 'mtype']];
    [vkey, mtype] = [vkey, mtype] || [gtype == 'SphereUnion'];	// safety
    local [rad] = ph4_QueryVdata [q, vkey, ['sphere_rad']];
    rad = soften_v [rad, sgn [sval, mtype <> 'None']];
    ph4_QuerySetVdata [q, vkey, ['sphere_rad'], [rad]];
endfunction
</pre>
</blockquote>

<p><a name="ph4_QueryMergeV"</a></p>
<p><hr noshade="noshade" />

<pre>
vnewkey = <span class="fcndef"
    >ph4_QueryMergeV</span> [qkey, vkey, vdstkey]
</pre>

<p>Function <tt>ph4_QueryMergeV</tt> merges several volumes (of
compatible types) into one.  The input volumes, specified by
<tt>vkey</tt>, are destroyed and a new volume is created in their place.
The position of the new volume in the list of all volumes is specified
by <tt>vdstkey</tt>.  The function returns the key of the created
volume.  If the volumes can't be merged, the function returns 0.

<p><i>Note</i>:

If the function succeeds and returns non-0,
the input keys, <tt>vkey</tt>, will become invalid.

<blockquote>
<pre>
global function ph4_QueryMergeV [q, vkey, vdstkey]

	// Verify that the supplied volumes are all of the same mtype
	// (e.g. 'None'=excluded volume) and of gtype 'SphereUnion'
	// (even though, currently, there is no other gtype value.)

    local [gtype, mtype] = ph4_QueryVdata [q, vkey, ['gtype','mtype']];
    if neL mtype then return 0; endif
    if neL cat [gtype, 'SphereUnion'] then return 0; endif
    if isnull vkey then return 0; endif
    vkey = uniq vkey;		// allow, but ignore duplicates

	// Create a new volume as a copy of the first volume provided,
	// vkey(1), optionally positioned in the list of all volumes
	// after the volume vdstkey.

    local newvkey = ph4_QueryCopyV [q, vkey(1), vdstkey];

	// Extract the (laminated) centers and radii of the volumes
	// to be merged and delete the volumes.

    local CR = ['sphere_center', 'sphere_rad'];
    local [c, r] = ph4_QueryVdata [q, vkey, CR];
    ph4_QueryDeleteV [q, vkey];

	// Insert the concatenated centers and radii into the new volume.

    ph4_QuerySetVdata [q, newvkey, CR, app nest [[apt cat c], [cat r]]];

    return newvkey;
endfunction
</pre>
</blockquote>

<p><a name="ph4_QueryDemergeV"</a></p>
<p><hr noshade="noshade" />

<pre>
vnewkey = <span class="fcndef"
    >ph4_QueryDemergeV</span> [qkey, vkey, vdstkey]
</pre>

<p>Function <tt>ph4_QueryDemergeV</tt> demerges one or more volumes into
several single-sphere volumes of the same type.  The input volumes are
destroyed and new volumes are created in their place.  The function
returns the keys of the created volumes.  If the volumes can't be
demerged, the function returns 0.

<p><i>Note</i>:

If the function succeeds and returns non-0,
the input keys, <tt>vkey</tt>, will become invalid.

<blockquote>
<pre>
global function ph4_QueryDemergeV [q, vkey, vdstkey]

	// Verify that the volumes can be demerged. (Currently, always ok.)

    local [gtype] = ph4_QueryVdata [q, vkey, ['gtype']];
    if neL cat [gtype, 'SphereUnion'] then return 0; endif
    if isnull vkey then return []; endif	// nothing to demerge
    vkey = uniq vkey;			// allow, but ignore duplicates

	// Collect the centers and radii of spheres from the volumes
	// and flatten them.  NOTE: The total number of spheres to be
	// created is "add v_n".

    local CR = ['sphere_center', 'sphere_rad'];
    local [v_n, v_c, v_r] = ph4_QueryVdata [q, vkey, cat ['sphere_count', CR]];
    v_c = cat app tr v_c;		// a list of all centers
    v_r = cat v_r;			// a flat list of all radii

	// Create new volume to hold individual spheres from the old volume.
	// Each new volume inherits properties of the corresponding old
	// volume (accomplished by duplicating volumes "stretch [vkey, v_n]").

    local newvkey = ph4_QueryCopyV [q, stretch [vkey, v_n], vdstkey];
    ph4_QuerySetVdata [q, newvkey, CR, [v_c, v_r]];
    ph4_QueryDeleteV [q, vkey];

    return newvkey;
endfunction
</pre>
</blockquote>

<!-- ********************************************************* -->
<p><a name="Additional Utilities"></a>
<hr noshade="noshade" />
<h3>Additional Utilities</h3>


<p><a name="ph4_SchemeGetBitmaskAll"</a></p>

<pre>
bitmask = <span class="fcndef"
    >ph4_SchemeGetBitmaskAll</span> [scheme, pnames]
</pre>

<p>Function <tt>ph4_SchemeGetBitmaskAll</tt> returns, for each property
name, <tt>pname(i)</tt>, the bitmask of all scheme bits that satisfy
the given property.

<!-- The supported property names include 'AtomQ', 'NonAtomQ',
'Centroid' 'Projected', 'Projecting' and 'Hydrophobic'. -->

An annotation point has the given property (e.g. "heavy-atom-based") if
at least one bit associated with the point is of that type.  For each
property whose name is not recognized the function returns -1.

<p>The supported values of <tt>pname(i)</tt> include:

<!-- ArgTable -->
<blockquote>
<table border=0 cellspacing=2 cellpadding=2>
<tr>
    <td valign="baseline"><tt>'AtomQ'</tt>
    </td><td valign="baseline">
	Any annotation point that can match the feature is heavy-atom-based.
    </td>
</tr><tr>
    <td valign="baseline"><tt>'Projected'</tt>
    </td><td valign="baseline">
	Any annotation point that can match the feature is a projected point.
    </td>
</tr><tr>
    <td valign="baseline"><tt>'Projecting'</tt>
    </td><td valign="baseline">
	Any annotation point that can match the feature is a projecting point.
    </td>
    <td valign="baseline"><em>unknown</em>
    </td><td valign="baseline">
	Set to -1.
	
    </td>
</tr>
</table>
</blockquote>
<!-- EndArgTable -->

<p><a name="ph4_SchemeExprProp"</a></p>
<p><hr noshade="noshade" />

<pre>
pvals = <span class="fcndef"
    >ph4_SchemeExprProp</span> [scheme, expr, pnames, defval]
</pre>

Function <tt>ph4_SchemeExprProp</tt> calculates properties of a list of
expressions, <tt>expr</tt>.

The function returns a matrix of values, <tt>M</tt>, where
<tt>M(i)(j)</tt> is the value of property <tt>pname(i)</tt> in the
expression <tt>expr(j)</tt>.

<p>
The function supports the following values to be used as the property name,
<tt>pname(i)</tt>:

<!-- ArgTable -->
<blockquote>
<table border=0 cellspacing=2 cellpadding=2>
<tr>
    <td valign="baseline"><tt>'OK'</tt>
    </td><td valign="baseline">
	Expression will not cause an error.
    </td>
</tr><tr>
    <td valign="baseline"><tt>'Err'</tt>
    </td><td valign="baseline">
	Error message reported by an expression (empty token when no error).
    </td>
</tr><tr>
    <td valign="baseline"><tt>'AtomQ'</tt>
    </td><td valign="baseline">
	Any annotation point that can match the feature is heavy-atom-based.
    </td>
</tr><tr>
    <td valign="baseline"><tt>'Projected'</tt>
    </td><td valign="baseline">
	Any annotation point that can match the feature is a projected point.
    </td>
</tr><tr>
    <td valign="baseline"><tt>'Projecting'</tt>
    </td><td valign="baseline">
	Any annotation point that can match the feature is a projecting point.
    </td>
</tr><tr>
    <td valign="baseline"><em>unknown</em>
    </td><td valign="baseline">
	The value of <tt>defval(i)</tt>.
	
    </td>
</tr>
</table>
</blockquote>
<!-- EndArgTable -->

When the property value, <tt>pname(i)</tt> is <i>unknown</i>, i.e. not
recognized, the returned valued is set to <tt>defval(i)</tt>.  The
<tt>defval</tt> argument is optional; if <tt>defval</tt> is missing (or
empty), <tt>defval(i)</tt> is set to 0.

If <tt>defval</tt> is non-empty, it unit extends.

<p><b>Example.

</b>Given a list feature expressions, <tt>expr</tt>, the following code
sets <tt>m_atomic</tt> to the mask of all atom-based features:
<pre>
    [m_atomic] = ph4_SchemeExprProp [scheme, expr, 'AtomQ'];
</pre>


<p><a href="../../index.htm">MOE Table of Contents</a>&nbsp;&nbsp;<a href="../../fcnindex.html">SVL Function Index</a></p>
<hr noshade="noshade" />
<a href="http://www.chemcomp.com"><img src="../../images/flogo.gif"
alt="CCG Logo"
align="left" width="30" height="30" border="1" hspace="5" vspace="3" /></a>
<font size="2">
<a href="../../legal.html">Copyright</a> &copy; 1997-2010
<a href="http://www.chemcomp.com">Chemical Computing Group Inc.</a><br />
<a href="mailto:info@chemcomp.com"><i>info@chemcomp.com</i></a>
</font>
</body>
</html>
