<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<!--
!!    MOE 2010.10 On-Line Manuals
!!    COPYRIGHT (C) 2010
!!        CHEMICAL COMPUTING GROUP INC.  ALL RIGHTS RESERVED.
!!-->

<head>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<link rel="stylesheet" type="text/css"
href="../../manstyle.css" />


<title>SVL Expressions</title>
</head>

<body bgcolor="#ffffff">
<a href="../../index.htm"><img src="../../images/logo.gif"
alt="CCG Logo" align="right" width="174" height="55" border="0" /></a>
<h4>MOE 2010.10</h4>
<h2>SVL Expressions</h2>
<hr noshade="noshade" />

<p>
[<a href="svlfund.html">Previous Chapter</a>] 
[<a href="control.html">Next Chapter</a>]
[<a href="index.html">Table of Contents</a>]</p>

<ul>
  <li><a href="#Statements">Statements</a></li>
  <li><a href="#SVL Expressions">SVL Expressions</a><ul>
      <li><a href="#Identifiers">Identifiers</a></li>
      <li><a href="#White Space">White Space</a></li>
      <li><a href="#Comments">Comments</a></li>
    </ul>
  </li>
  <li><a href="#Operators">Operators</a><ul>
      <li><a href="#Arithmetic Operators">Arithmetic Operators</a></li>
      <li><a href="#Relational and Logical Operators">Relational and Logical Operators</a></li>
      <li><a href="#Assignment Operator =">Assignment Operator <tt> =</tt></a></li>
      <li><a href="#Data Access Operators">Data Access Operators <tt> ( ) ( ) = [ ] [ ] = | | =</tt></a></li>
      <li><a href="#Operator Precedence">Operator Precedence</a></li>
    </ul>
  </li>
</ul>

<h2><a name="Statements">Statements</a></h2>

<p>A statement is the smallest executable unit in SVL. It is usually
terminated by a semi-colon (<tt>;</tt>). SVL programs are composed of
expression statements and declaration statements. Declarations define
variables and functions, and expressions manipulate the variables and
invoke the functions.</p>

<p>For more on variable and function declarations see
<a href="funcs.html">Functions, Programs and Scoping Rules</a>.</p>

<p>An SVL expression statement generally comprises at least one
expression, and may or may not contain special keywords. An expression
statement contains special keywords when it is used for controlling
program flow, that is, for controlling the order in which statements are
executed in the course of running a program.</p>

<h2><a name="SVL Expressions">SVL Expressions</a></h2>

<p>An SVL <i>expression</i> can be made up of expressions, or can be
simply a single <i>identifier</i>.  Identifiers are discussed below.
Informally, an expression is something that has a value associated with
it. For instance, the value of a number is just the number itself, and the
value of <tt>3 &gt; 4, 0</tt>. An assignment is also considered to be an
expression. Most expressions involve variables as well as functions, a
special class of which is operators.  Many expressions contain comments
and white space for purposes of readability.</p>

<p>Here are some examples of expressions. </p>

<pre>
    -3.0e-4 
    a 
    'hello' 
    [3,4,5] 
    [ &quot;a&quot;, 'tok', c, 34 ]
    1 + 3.5 
    ( a - 5 ) * 2 
    a == 4 
    v[3] 
    diff [a,b] 
    [ a &gt; b, c(4), x + 3 ] 
    x = [1,2,3] 
</pre>

<p>The only data unit in SVL is the <i>vector</i>. Expressions build and
manipulate vectors.</p>

<h3><a name="Identifiers">Identifiers</a></h3>

<p>An identifier is a sequence of letters and digits used to name
functions, variables, constants and statement labels. The first character
must be a letter. Letters are from <tt>A</tt> to <tt>Z</tt>, and from
<tt>a</tt> to <tt>z</tt>. The underscore character <tt>_</tt> is also
considered to be a letter. Digits are the numerals <tt>0</tt> to
<tt>9</tt>.</p>

<p>SVL is case-sensitive so that the identifiers <tt>xsize</tt>,
<tt>Xsize</tt> and <tt>xsizE</tt> are distinct.
SVL identifiers should not be longer than 78 characters.
</p>

<p>The table below shows SVL reserved words that must not be used as identifiers.</p>
<div align="center"><center>

<table border="0" width="70%" cellpadding="4">
  <tr>
    <td>if</td>
    <td>then</td>
    <td>else</td>
    <td>elseif</td>
    <td>endif</td>
  </tr>
  <tr>
    <td>for</td>
    <td>in</td>
    <td>while</td>
    <td>loop</td>
    <td>until</td>
  </tr>
  <tr>
    <td>endloop</td>
    <td>break</td>
    <td>continue</td>
    <td>function</td>
    <td>endfunction</td>
  </tr>
  <tr>
    <td>local</td>
    <td>global</td>
    <td>static</td>
    <td>const</td>
    <td>goto</td>
  </tr>
  <tr>
    <td>return</td>
    <td>let</td>
    <td>import</td>
    <td>export</td>
    <td>var</td>
  </tr>
</table>
</center></div><i>

<p ALIGN="CENTER">SVL Reserved Words</p>
</i>

<h3><a name="White Space">White Space</a></h3>

<p>White space comprises blank spaces, tabs, newlines, form feeds as well
as comments.  Generally speaking, white space is ignored, except when
found within 'single' or &quot;double&quot; quotes, in which case it is no
longer called white space. The only place where white space is required is
where characters must be separated from each other so as not to be treated
as a single unit. Otherwise, white space may be used freely for stylistic
and legibility purposes without influencing the outcome of any SVL
expressions.</p>

<h3><a name="Comments">Comments</a></h3>

<p>Comments are important for clarifying code. Because SVL code can be
written very compactly, comments should be considered a mandatory part of
SVL programming practice.
It is astonishing how quickly a piece of code, even one that has been
lovingly sweated over for many weeks, becomes obscure. You should never
attempt to &quot;document&quot; algorithmic and implementation details
with uncommented lines of program code, no matter how descriptive the
variable and function names.</p>

<p>There are 2 kinds of comment delimiters, the <tt>/* */</tt> paired
delimiters and the <tt>//</tt> delimiter. The <tt>/*&nbsp;*/</tt> comment
can be used to enclose multiple lines of text, and can be nested. Its
purpose is for commenting out blocks of code to facilitate debugging. The
sequence <tt>//</tt> renders all characters to the right of itself part of
that comment; this includes the <tt>*/</tt> characters: <tt>*/</tt> to the
right of <tt>//</tt> cannot be used to close a comment begun with
<tt>/*</tt>. The <tt>//</tt> comment is terminated by a newline characters
and thus may not span more than one line. Its purpose is for documenting
code. </p>

<pre>
    /* This is a multi-line 
       comment 
    */

    /* /* This type of comment can nest. */ */

    const NUMBER_OF_THINGS = 100; // comment to end of line

    // this is also a comment to the end of the line
</pre>

<h2><a name="Operators">Operators</a></h2>

<p>Operators were introduced in the previous chapter.  There, we mentioned
that frequently used operators have special infix shorthand. We discussed
how or unops and binops are special terms we coined to signify operators
that are element-wise vector extensions of scalar operators. We also
examined how some binops undergo reduction when presented with more than
two arguments. We then made the distinction between lexicographic and
element-wise relational and logical operators. Finally, we looked at order
of evaluation of expressions. </p>

<p>In this section, we will review all the SVL operators, and catalogue
operator precedence. As a general rule of thumb, binary operators have
lower precedence than all other SVL built-in functions.</p>

<h3><a name="Arithmetic Operators">Arithmetic Operators</a></h3>

<p>The 4 arithmetic binops are <tt>+</tt>, <tt>-</tt>, <tt>*</tt> and
<tt>/</tt>. Unary <tt>-</tt> or <tt>neg</tt> performs negation. The
arithmetic operations are all, by default, floating-point operations.
<tt>+</tt> and <tt>-</tt> have the same precedence, and will associate
from left to right. <tt>*</tt> and <tt>/</tt> have higher precedence, and
also associate from left to right.</p>

<p>Here are some examples. </p>

<pre>
    svl&gt; 1 + 2
    3
    svl&gt; [1,2] + [3,4]
    [4,6]
    svl&gt; [3,4] * 2
    [6,8]
    svl&gt; 3 / [2,3]
    [1.5,1]
    svl&gt; 2 * 4 / 10 // 8 / 10
    0.8
    svl&gt; 2 + 7.5 * 2 // 2 + 15
    17
</pre>

<p>When reduction is desired of a binop, use the longhand form of the
operator, i.e. the SVL built-in function name. </p>

<pre>
    svl&gt; add [2,3,4]
    9
    svl&gt; mul [ [2,3], [4,5], 2 ]
    [16,30]
</pre>

<h3><a name="Relational and Logical Operators">Relational and Logical Operators</a></h3>

<p>The relational operators are: </p>

<pre>
    &gt; &gt;= &lt; &lt;=
</pre>

<p>which all have the same precedence, and the equality operators: </p>

<pre>
    == === &lt;&gt;
</pre>

<p>which also have the same precedence. Relationals have lower precedence than arithmetic
operators.</p>

<p>The shorthand notations correspond to the following SVL built-in functions:</p>
<div align="center"><center>

<table border="1" width="40%" cellpadding="3">
  <tr>
    <td><tt>&gt; </tt></td>
    <td><tt>gtE </tt></td>
  </tr>
  <tr>
    <td><tt>&gt;=</tt></td>
    <td><tt>geE </tt></td>
  </tr>
  <tr>
    <td><tt>&lt;</tt></td>
    <td><tt>ltE</tt></td>
  </tr>
  <tr>
    <td><tt>&lt;=</tt></td>
    <td><tt>leE</tt></td>
  </tr>
  <tr>
    <td><tt>==</tt></td>
    <td><tt>eqE</tt></td>
  </tr>
  <tr>
    <td><tt>=== </tt></td>
    <td><tt>eqL</tt></td>
  </tr>
  <tr>
    <td><tt>&lt;&gt;</tt></td>
    <td><tt>neE</tt></td>
  </tr>
</table>
</center></div>

<p>Relationals cannot be chained together. For instance, </p>

<pre>
    svl&gt; 2 &gt; 3 == 4 &gt; 5 // error!
</pre>

<p>is an illegal construction. However, this is legal: </p>

<pre>
    svl&gt; (2 &gt; 3) == (4 &gt; 5)
    1
</pre>

<p>Recall that arguments to element-wise operators must be of the same
shape (allowing for unit extension), while arguments to lexicographic
operators need not be so. Also, recall that
element-wise relational operators can undergo reduction.</p>

<p>Here are some examples. </p>

<pre>
    svl&gt; [2,3] == [4,3] // eqE
    [0,1]
    svl&gt; eqE ['a','ab']
    0
    svl&gt; &quot;b&quot; == &quot;bc&quot; // &quot;b&quot; unit extends
    [1,0]
    svl&gt; [ [2,3], 'a' ] == [ [4,3], 'ab' ]
    [ [0,1], 0 ]
    svl&gt; &quot;bc&quot; == &quot;bcd&quot; // Error! wrong shape
    svl&gt; &quot;bc&quot; === &quot;bcd&quot; // eqL
    0
    svl&gt; 2 &gt; 3 &gt; 1 // Error!
    svl&gt; (2 &gt; 3) &gt; 1
    0
    svl&gt; gtE [2,3,1] // reduction (2&gt;3)&gt;1
    0
</pre>

<p>Shorthand notations do not exist for the other lexicographic operators: </p>

<pre>
    gtL geL ltL leL neL
</pre>

<p>Two logical infix shorthand notations exist: <tt>and</tt>, short for
<tt>andE</tt>, and <tt>or</tt> short for <tt>orE</tt>. They are of equal
precedence, and evaluate from left to right. There are no lexicographic
logical operators, and no short forms for the other logical functions:
</p>

<pre>
    xorE not notnot
</pre>

<p>Here is an example of <tt>and</tt> and <tt>or</tt> in use; non-zero values evaluate to
&quot;true&quot;: 

<pre>
    svl&gt; [1,1,1] and [2,-1,0]
    [1,1,0]
    svl&gt; [1,0,0] or [2,-1,0]
    [1,1,0]
</pre>

<p><b>Note:</b> In relational and logical expressions, all function
arguments are evaluated before applying the operator. This is unlike, for
instance, in C, where there are <i>short-circuited</i>
expressions that terminate execution as soon as they
become false, in the case of AND, or true, in the case of OR, leaving any
remaining parts of the expression unevaluated.</p>

<h3><a name="Assignment Operator =">Assignment Operator = </a></h3>

<p>There are 3 forms of assignment. In all cases, the right-hand side of
an assignment must be an expression. Since assignments themselves are
expressions, this means that they can be chained together. The left-hand
side of an assignment must be an addressable location, i.e. an
<i>lvalue</i>. The return value of an assignment is the value of its
right-hand side. </p>

<p>The 3 forms of assignment differ in the nature of the left-hand side lvalue. In the
first and simplest case, the left-hand side is a single identifier: 

<pre>
    svl&gt; x = [2,3,4]
    svl&gt; a = [ 1 + 2, &quot;a&quot;, 't' ]
    svl&gt; 'a' = 2 // Error! illegal destination
</pre>

<p>The left-hand side may also be a vector, in which case the left- and
right-hand sides of the assignment must be conformable. This second form
of assignment is shorthand for assigning to the variables of the left-hand
side vector the values of the right-hand side vector elements. The
left-hand side vector does not need to be flat. Instead of shorthand,
assignments can be made directly and explicitly within a vector.

<pre>
    svl&gt; [a,b,c] = [ &quot;a&quot;, 'abc', [2,'b'] ]
    svl&gt; [a, [b,c] ] = [2, [3,4]]; [b,c]
    [3,4]
    svl&gt; [ a=3, [b=4,c=5] ]; [a,b,c]
    [3,4,5]
</pre>

<b><p>Note:</b> A unit vector on the right-hand side of an assignment will not
unit-extend to a vector of variables on the left-hand side.</p>

<pre>
    svl&gt; [a,b,c] = [1,2,3] // a=1, b=2, c=3
    svl&gt; [a,b,c] = 0; [a,b,c]
    [ 0, [], [] ]
</pre>

<p>The third form of assignment uses the shorthand notation for
<tt>put</tt> and <tt>poke</tt>.
Recall that <tt>put</tt> inserts elements at the same level
as nesting as originally in the source, while <tt>poke</tt> increases the
level of nesting of the inserted elements, and that their shorthand
notations, <tt>[]=</tt> and <tt>()=</tt>, cause the source vector to be
overwritten.</p>

<p>Here are some examples: 

<pre>
    svl&gt; a = [2,3,4]
    svl&gt; a(2) = [5,6]; a // poke
    [ 2, [5,6], 4 ]
    svl&gt; a[1] = [ [2,3] ]; a // put
    [ [2,3], [5,6], 4 ]
    svl&gt; [ a(3), b ] = [2,3] // Error!
    svl&gt; [ a[3], b ] = [ [2,3] ] // Error!
    svl&gt; [ a(3) = 2 ] // okay
    2
    svl&gt; a
    [ [2,3], [5,6], 2 ]
</pre>

<p>The two statements that generated errors did so because it is not
permissible to combine the <tt>put</tt> and <tt>poke</tt> form of
assignment with the vector form of assignment.</p>

<h3><a name="Data Access Operators">Data Access Operators ( ) ( )= [ ] [ ]= | |=
</a></h3>

<p>The data access operators violate our previous definition of an operator
since they are purely vector functions and have no scalar counterparts.
Nonetheless, we will place them here among the operators because they are,
like the other SVL operators, sequences of special symbols that are
shorthand for SVL function calls. The <tt>()</tt> and <tt>[]</tt>
operators are for indexing (or subscripting). <tt>()</tt> is shorthand for
<tt>peek</tt> and <tt>()=</tt> for <tt>poke</tt>, and <tt>[]</tt> is
shorthand for <tt>get</tt> and <tt>[]=</tt> for <tt>put</tt>. 
For information on data access functions see
<a href="svlfund.html#Primary Data Access Functions">
Primary Data Access Functions </a>.</p>

<p>The <tt>mget</tt> binary operator, written in infix form as <tt>|</tt>,
extracts vector elements according to a mask. The companion function mput
has the shorthand <tt>|=</tt> (the shorthand performs an actual
assignment, and hence does not behave identically to <tt>mput</tt>).  </p>

<p>The usage of <tt>|</tt> is: 

<pre>
    expr | mask
</pre>

<p>where <tt>expr</tt> and <tt>mask</tt> must be of the same length.</p>

<p>Here is an example: 

<pre>
    svl&gt; &quot;abcde&quot; | [0,1,0,1,1] // mget [ &quot;abcde&quot;, [0,1,0,1,1] ]
    &quot;bde&quot;
</pre>

<p>mget</tt> can be thought of as a filtering or &quot;set-restriction&quot; operation,
and is often used to extract elements of one vector associatively with another. To
illustrate: 

<pre>
    svl&gt; LastName = [ 'Philips', 'Johnson', 'Sousa', 'Jones' ]
    svl&gt; FirstName = [ 'Phil', 'John', 'Sue', 'John' ]
    svl&gt; Salary = [ 55, 35, 45, 25 ]
    svl&gt; LastName | FirstName == 'John'
    ['Johnson','Jones']
    svl&gt; LastName | Salary &gt; 35
    ['Philips','Sousa']
</pre>

<p>|=</tt> is used as follows: 

<pre>
    expr | mask = val
</pre>

<p>where <tt>expr</tt> and <tt>mask</tt> must be of the same length, and
the length of <tt>val</tt> must be equal to the number of non-zero
elements in mask.</p>

<p>Here are some examples of <tt>mput</tt> and <tt>|=</tt>: 

<pre>
    svl&gt; a = &quot;abcde&quot;
    svl&gt; mput [a, [1,0,1,0,0], &quot;AC&quot;]; a
    &quot;abcde&quot;
    svl&gt; a | [1,0,1,0,0] = &quot;AC&quot;; a
    &quot;AbCde&quot;
    svl&gt; a = &quot;abc&quot;
    svl&gt; a | [1,0,1,0,0] = &quot;fg&quot; // Error!
    svl&gt; a = &quot;abcde&quot;
    svl&gt; a | [1,0,1,0,0] = &quot;fghij&quot; // Error!
</pre>

<h3><a name="Operator Precedence">Operator Precedence</a></h3>

<p>The table below summarizes the rules for precedence and associativity
of SVL operators.  By associativity, we mean the manner in which arguments
associate with an operator, determining order of evaluation. For instance,
<tt>+</tt> and <tt>-</tt> have left-to-right associativity, so that:

<pre>
    a + b - c + d
</pre>

<p>is evaluated in the following manner, the numbers indicating the order
in which the operations are done:

<pre>
    ((a + b) - c) + d
    1 2 3
</pre>

<p>However, the assignment operator <tt>=</tt> has right-to-left
associativity so that the right-hand side of an assignment is evaluated
before the left-hand side. Subscripting operators associate with whatever
is to the left of them, and functions associate with their arguments that
are found to their right. </p>

<p>Operators on the same line have the same precedence. Operators at the
top of the table have highest precedence, and precedence diminishes as the
rows descend. As we mentioned before, in SVL, operators have lower
precedence than other built-in functions. Precedence can be overridden
using parentheses <tt>()</tt>. </p>

<p>The following table shows the precedence and order of evaluation of 
SVL operators.

<a name="TableOfOperators"></a>
<p>

<table border="1" width="100%" cellpadding=3>
  <tr>
    <th>Operator</th>
    <th>SVL Function</th>
    <th colspan=2>Associativity</th>
  </tr>
  <tr>
    <td><tt>[] () . </tt></td>
    <td><tt>get peek tagpeek</tt></td>
    <td>L</td>
    <td><tt>a(2)[3](4)<br>((a(2))[3])(4)</tt></td>
  </tr>
  <tr>
    <td><em>fcn</em></td>
    <td>any built-in or user function</td>
    <td>R</td>
    <td><tt>sin cos a<br>sin (cos a)</tt></td>
  </tr>
  <tr>
    <td><tt>-</tt></td>
    <td><tt>neg</tt></td>
    <td>R</td>
    <td><tt>--a<br>-(-a)</tt></td>
  </tr>
  <tr>
    <td><tt>* /</tt></td>
    <td><tt>mul div</tt></td>
    <td>LR</td>
    <td><tt>a / b * c<br>(a / b) * c</tt></td>
  </tr>
  <tr>
    <td><tt>+ -</tt></td>
    <td><tt>add sub</tt></td>
    <td>LR</td>
    <td><tt>a + b - c<br>(a + b) - c</tt> </td>
  </tr>
  <tr>
    <td><tt>=== == &lt;&gt;<br>
    &gt; &gt;= &lt; &lt;=</tt></td>
    <td><tt>eqL eqE neE<br>
    gtE geE ltE leE</td>
    <td>none</td>
    <td><tt>a <= b => c</tt><br><em>error</em></td>
  </tr>
  <tr>
    <td><tt>and</tt></td>
    <td><tt>andE</tt></td>
    <td>any</td>
    <td><tt>a and b and c<br>
    (a and b) and c<br>
    a and (b and c)</tt></td>
  </tr>
  <tr>
    <td><tt>or</tt></td>
    <td><tt>orE</tt></td>
    <td>any</td>
    <td><tt>a or b or c<br>
    (a or b) or c<br>
    a or (b or c)</tt></td>
  </tr>
  <tr>
    <td><tt>| || </tt></td>
    <td><tt>mget</tt>, <tt>apt</tt> <tt>mget</tt></td>
    <td>LR</td>
    <td><tt>a | b | c<br>
    (a | b) | c</tt></td>
  </tr>
  <tr>
    <td><tt>= |= ||= </tt></td>
    <td>assignment, <tt>mput</tt>, <tt>apt</tt> <tt>mput</tt></td>
    <td>RL</td>
    <td><tt>a = b | m = c<br>
    a = (b | m = c)</tt></td>
  </tr>
</table>


<p>L means left associativity, R means right, LR means left-to-right
associativity, and RL means right-to-left.</p>

<p>Next: <a href="control.html">Control Flow</a></p>

<p><a href="../../fcnindex.html">Function Index</a></p>
<p><a href="../../index.htm">MOE Table of Contents</a></p>
<hr noshade="noshade" />
<a href="http://www.chemcomp.com"><img src="../../images/flogo.gif"
alt="CCG Logo"
align="left" width="30" height="30" border="1" hspace="5" vspace="3" /></a>
<font size="2">
<a href="../../legal.html">Copyright</a> &copy; 1997-2010
<a href="http://www.chemcomp.com">Chemical Computing Group Inc.</a><br />
<a href="mailto:info@chemcomp.com"><i>info@chemcomp.com</i></a>
</font>
</body>
</html>
