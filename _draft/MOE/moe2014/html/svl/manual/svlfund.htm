<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">


<!--
!!    MOE Online Manuals
!!    COPYRIGHT (C) 1997-2015
!!        CHEMICAL COMPUTING GROUP INC.  ALL RIGHTS RESERVED.
!!-->

<head>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<script type="text/javascript" 
src="../../include/jsincludes_moe.js"></script>

<link rel="stylesheet" type="text/css"
href="../../include/manstyle.css" />


<title>Fundamental SVL Concepts</title>
</head>

<body>
<div id="MoeHeader"></div>
<noscript>
	<span class="warning">Warning: JavaScript is disabled. This page will not display correctly.</span>
	<h1 class="title">MOE Documentation</h1>
	<hr noshade="noshade" />
	<style>.LaTeX {color: #C08080;}</style>
</noscript>

<p>[<a href="intro.htm">Previous Chapter</a>] [<a href="data.htm">Next
Chapter</a>] [<a href="index.htm">Table of Contents</a>]

<ul>
  <li><a href="#VectorsAndVectorNotation">Vectors and Vector Notation</a>
  <ul>
    <li><a href="#UnitVectors">Unit Vectors</a>
    <li><a href="#Scalars">Scalars</a>
  </ul>
  <li><a href="#UnitExtension">Unit Extension</a>
  <li><a href="#Fundamental Data Types">Fundamental Data Types</a><ul>
      <li><a href="#NumericData">Numeric Data</a>
      <li><a href="#CharacterData">Character Data</a>
      <li><a href="#TokenData">Token Data</a>
      <li><a href="#TypeConversions">Type Conversions</a>
    </ul>
  
  <li><a href="#VectorSyntax">Vector Syntax</a>
  <li><a href="#Nesting">Nesting</a>
  <li><a href="#IndexingandTagging">Vector Elements: Indexing and Tagging</a>
    <ul>
      <li><a href="#Indexing">Indexing</a>
      <li><a href="#Tagging">Tagging</a>
    </ul>
  
    <li><a href="#SVLFunctions">SVL Functions</a><ul>
	<li><a href="#FunctionExtension">Function Extension</a>
	<li><a href="#Operators">Operators</a>
	<li><a href="#UnaryOperators">Unary Operators</a>
	<li><a href="#BinaryOperatorsAndReduction">Binary Operators and
	Reduction</a>
	<li><a href="#LexicographicAndElementWiseOperators">Lexicographic and
	Element-wise Operators</a>
	<li><a href="#StructuralFunctions">Structural Functions</a>
	<li><a href="#PrimaryDataAccessFunctions">Primary Data Access Functions</a>
	<li><a href="#m_-typeAndx_-typeFunctions">m_-type and x_-type Functions</a>
	<li><a href="#ClassificationOfStructuralFunctions">Classification of
	Structural Functions</a>
    </ul>
  
  <li><a href="#HowCLICommandsAreExecuted">How CLI Commands Are Executed</a>
  <li><a href="#Built-inConstants">Built-in Constants</a>
</ul>

<p>SVL is a collection-oriented language. This means that it acts on
collections or aggregates of data as a whole rather on single data items.  The
SVL collection is the <i>vector</i>, a quantity very much like the array that
is found in many programming languages; i.e. a random-access collection
of values. A vector is a list of objects. These objects are labeled and
referred to by either <i>indices</i> or <i>tags</i>. Each vector has a
particular <i>shape</i> or <i>conformation</i>, characterized by its length,
and the length and levels of nesting of its elements.

<h2><a name="VectorsAndVectorNotation">Vectors and Vector Notation</a></h2>

<p>The basic unit of data in SVL is the vector. A vector is denoted by
brackets ([]) and its elements are separated by commas. For example: 

<pre>
    [2,3,4]
</pre>

<p>is a vector with three elements. 

<p>The general ordered vector has the form: 

<pre>
    x = [ x<sub>1</sub>, ... , x<sub>n</sub> ].
</pre>

<p>Each x<sub>i</sub> is called an <i>element</i> of x, and <i>n</i> is
the length of x.  In turn, each element <i>x<sub>i</sub></i> may be a
vector itself. Vectors can nest to arbitrary depths. If <i>n </i>= 0, then
x is a <i>null vector</i>, and if <i>n </i>= 1, then x is called a <i>unit
vector</i>. All vectors are constructed from the set of <i>atomic unit
vectors</i> (characters, numbers, etc.) and null vectors.

<p>There are 2 cases in which the brackets may be omitted, as a kind of shorthand: 

<ul>
  <li>Scalars
  <li>Strings, where double quotes are used instead
</ul>

<h2><a name="UnitVectors">Unit Vectors</a></h2>

<p>A vector of length 1 is called a <i>unit vector</i>. It is important to
understand what constitutes a unit vector since the concept of <i>unit
extension</i> depends on unit vectors. Here are some examples of unit
vectors: 

<pre>
    3                
    [ [1,2] ]       
    [ [ 1, [2,3] ] ]
    [ &quot;abc&quot; ]
</pre>

<p>These are <b>not</b> unit vectors: 

<pre>
    [1, 2]
    &quot;abc&quot;
</pre>

<h2><a name="Scalars">Scalars</a></h2>

<p>Scalars are vectors that contain a single value of a basic data type,
such as a number or a character.

<p>Scalars can be written with or without enclosing brackets. Moreover,
because they are infinitely nestable, they can also be written with as
many enclosing brackets as desired. 

<p>The following are examples of scalars: 

<pre>
    1            
    'token'     
    &quot;0&quot; 
    [ 'a' ]      
    [[&quot;a&quot;]]      
    [[[[1.3]]]]  
    ''           // null token
</pre>

<p>The following are <b>not</b> scalars: 

<pre>
    [] 
    [ [] ] 
    &quot;&quot; 
    [1,2]
    [ [1,2] ]
    &quot;ab&quot;
</pre>

<p>A <i>scalar</i> has the property: 

<pre>
    a === [a]
</pre>

<p>Note: although scalars are unit vectors, not all unit vectors are scalars. 

<h2><a name="UnitExtension">Unit Extension</a></h2>

<p>SVL operations on two vectors generally proceed element-wise, 
i.e. by pairing an
element from one operand with the corresponding element in the other operand.
In general, the vectors must be of equal length. However, if one of them is a
unit, it is automatically replicated to the length of the other argument. The
mechanism to do this is called <i>unit extension</i>.

<p>Unit extension is illustrated in the following examples.

<pre>
    svl&gt; 1 + [2,3]         // 1 extends to [1,1]
    [3,4]

    svl&gt; 1 + [ 2, [3,4] ]  // 1 extends to [1,[1,1]]
    [ 3, [4,5] ]

    svl&gt; [1,2] + [ 3, [4,5] ] // 2 extends to [2,2]
    [ 4, [6,7] ]

    svl&gt; print 2 + []      // 2 extends to []
    []

    svl&gt; [2,3,4] * [ [5,6,7] ] // outer product
    [ [10,12,14], [15,18,21], [20,24,28] ]
</pre>

<p>We used the command <tt>print</tt> in the third example to make sure the
result (the empty vector, <tt>[]</tt>) gets printed.  By default, the empty
vector would not get printed in the CLI.

<p>In the last example, <tt>[[5,6,7]]</tt> is the unit, which extends to
each element of the vector on the left.

<p>Not all functions unit extend their arguments at all levels of nesting.
Some functions unit extend at the top level only while others do not unit
extend at all.

<h2><a name="Fundamental Data Types">Fundamental Data Types</a></h2>

<p>When we discuss fundamental data types, we are looking at the different
types of <i>literal constants</i> that can be defined. A literal constant
is an object whose value cannot be changed (constant), and which can only
be discussed in terms of its value (literal). There are 3 types:
<i>numeric</i>, <i>character</i> and <i>token</i>.

<h3><a name="NumericData">Numeric Data</a></h3>

<p>Numeric literals can be either integer or floating point. However, in
normal usage, all numeric data is manipulated in floating point
representation, so that this distinction is unimportant. However, integer
operations (e.g. <tt>even</tt> and <tt>bitand</tt>) expect
integers, and are not well defined for real arguments. The precision of
floating point representation is machine dependent, and you will have to
consult your system documentation to determine what the precision is for
your particular set-up.

<p>For information on how to
determine the numerical limits of your machine see
<a href="#Built-inConstants">Built-in Constants</a>.

<p>Explicit integer operations do exist, but we recommend that, in
general, you use the default floating-point representation for your
calculations.

<p>An integer has absolute value less than 2<sup>31</sup>-1. Integers any
larger than this become floating-point quantities. Floating point or
<i>real</i> numbers may be written with or without a decimal point, and
may be written in exponential notation. They are stored as IEEE
double-precision numbers. <b>

<p>Note:</b> Numbers must begin with a digit. They cannot begin with
either <tt>e</tt> or the decimal point.

<p>These are examples of numeric data: 

<pre>
    0
    0.3
    3.
    -2.718e-4
    3.1415E10
</pre>

<p>Hexadecimal numbers are indicated by the prefix <tt>0x</tt>
(zero-lowercase x). 

<pre>
    0x10 // 16
</pre>

<p>It is possible to explicitly force integer arithmetic for purposes of
performance. 

<h3><a name="CharacterData">Character Data</a></h3>

<p>Character data is indicated by the presence of &quot;double
quotes.&quot; Often, character data is aggregated into strings. A
<i>string</i> is a <i>flat</i> vector of characters that can be written
using a shorthand that puts all the characters of the string inside one
set of double quotes; e.g. <tt>[&nbsp;&quot;a&quot;,
&quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]</tt> is the same as
<tt>&quot;abcd&quot;</tt>.  A flat vector has only scalar elements.

<p>Note the following: 

<pre>
    svl&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;cd&quot; ] // not the same as &quot;abcd&quot;
    [ &quot;a&quot;, &quot;b&quot;, &quot;cd&quot; ]
    svl&gt; [ &quot;abcd&quot; ]      // not the same as &quot;abcd&quot;
    [ &quot;abcd&quot; ]
    svl&gt; [ 'abcd' ]      // compare to token
    'abcd'
</pre>

<p>Observe that the third element of <tt>[ &quot;a&quot;, &quot;b&quot;,
&quot;cd&quot; ]</tt> is itself a character vector containing 2
elements.

<p><b>Caution!</b> Double quotes should not be considered an alternative
to brackets for delimiting vectors. Unlike brackets, double quotes cannot
be nested: 

<pre>
    svl&gt; &quot;&quot;a&quot;&quot; // error!
</pre>

<p>String literals may not straddle line boundaries, that is, they must
fit on one line.  There is no string continuation character that permits
multi-line literals. However, strings separated by white space (blanks,
tabs, newlines) are automatically concatenated into a single string. For
example, 

<pre>
    svl&gt; &quot;sit&quot; &quot;e&quot;
</pre>

<p>and 

<pre>
    print &quot;sit&quot; // in a function
	  &quot;e&quot;;
</pre>

<p>both yield: 

<pre>
    &quot;site&quot;
</pre>

<p>Selected characters can be specified using the backslash (<tt>\</tt>).
For example, the backslash is used for including a double quote character in
a string: (<tt>\&quot;</tt>). To generate the backslash character itself, use
double backslash (<tt>\\</tt>).

<center>
<table border="1" width="50%" cellpadding=3>
  <tr>
    <th>sequence</th>
    <th>character</th>
  </tr>
  <tr>
    <td><tt>\n</tt></td>
    <td>newline</td>
  </tr>
  <tr>
    <td><tt>\t</tt></td>
    <td>horizontal tab</td>
  </tr>
  <tr>
    <td><tt>\"</tt></td>
    <td>double quote</td>
  </tr>
  <tr>
    <td><tt>\'</tt></td>
    <td>single quote</td>
  </tr>
  <tr>
    <td><tt>\\</tt></td>
    <td>backslash</td>
  </tr>
</table>
</center>


<p>Note that generalized escape sequences of the form 

<pre>
    \ooo
</pre>

<p>are permitted, where <tt>ooo</tt> represents up to three octal digits.
These octal digits give the numerical value of a character in the ASCII
character set. 

<pre>
    svl&gt; &quot;\101&quot;
    &quot;A&quot;
</pre>

<p>These numerical values can also be expressed in hexadecimal using the escape sequence <tt>\x</tt>.
For example, 

<pre>
    svl&gt; &quot;\x65&quot;
    &quot;e&quot;
</pre>

<p>Here are some examples of valid string literals: 

<pre>
    &quot;\&quot;Hello\n How are you?\&quot;&quot;
    &quot;file1.svl&quot;
    &quot;!\@\#\$\%\ *()_+|&quot;
</pre>

<p>The null string <tt>""</tt> is the null vector, which can also be written
as <tt>[]</tt>.

<h3><a name="TokenData">Token Data</a></h3>

<p>Tokens are sequences of characters enclosed in 'single quotes.' As with
string literals, token literals cannot straddle line boundaries. Like
strings, tokens separated by white space (blanks, tabs, newlines) are
automatically concatenated into a single token. For example, 

<pre>
    svl&gt; 'to' 'me'
</pre>

<p>becomes: 

<pre>
    'tome'
</pre>

<p>Tokens may also contain characters specified using codes preceded by
backslash (see previous table). The single
quote character is generated using two-character combination of a backlash
and single quote (<tt>\'</tt>).

<p>Tokens are fundamentally different from strings: strings are vectors
containing one or more elements; all tokens are unit vectors; in fact,
they are scalars. Thus, the individual characters of strings can be
compared and extracted, but those of tokens cannot.

<p>Some valid SVL tokens: 

<pre>
    'Error message #4'
    'The vampire\'s kiss\n was somniferous.'
</pre>

<p>The null token (<tt>''</tt>) is <i>not</i> the null vector (<tt>[]</tt>).
The null token is a scalar.

<h3><a name="TypeConversions">Type Conversions</a></h3>

<p>Explicit type conversion is required to turn one type of data into
another. The SVL conversion functions are: 

<pre>
    int real string token
</pre>

<p>Below are some examples of their usage. Note that <tt>string</tt> works
only on scalars, and <tt>token</tt> operates only on flat vectors
(i.e. on one string at a time). 

<pre>
    svl&gt; string 'abc def'
    &quot;abc def&quot;
    svl&gt; string [ 'abc', 'def' ] // error!
    svl&gt; token &quot;hat&quot;
    'hat'
    svl&gt; token [ &quot;hat&quot;, &quot;abc&quot; ] // error!
</pre>

<p><tt>token</tt> behaves much the same as <tt>string</tt>, except it
returns tokens instead of strings.

<p><tt>int</tt> and <tt>real</tt> only operate on numeric data, and are for
specifying explicit data representation in memory. These 2 functions are
generally not needed in the normal course of computations.

<h2><a name="VectorSyntax">Vector Syntax</a></h2>

<p>The formal syntax of a vector is as follows: 

<pre>
    [ <i>expr</i>, ... , <i>expr</i> ]
</pre>

<p>where <i>expr</i> is an identifier, an expression, or a <i>null</i>
(<tt>[]</tt>). In the latter case, the null must be explicitly written, as
in, for example, 

<pre>
    [ 2, 3, [] , 4]
</pre>

<p>This kind of construct is useful for passing arguments to functions. In
this case, a vector of known structure can be passed to a function that
expects values in specified locations in the vector. Thus, only certain
values are assigned to local variables. For instance, in the function
definition: 

<pre>
    function do_something [ a, b, [] , c, d ]
	...
    endfunction
</pre>

<p>The function expects a vector of 5 elements, only 4 of which are used
in the function (if the vector passed to the function is longer than five
elements, the additional elements are ignored). 

<p>The elements of a vector may be vectors themselves. 

<pre>
    [ 1, [2,3] ]
    [ 1, [ 2, [3,4] ] ]
</pre>

<p>They may in fact be any kind of expression, including assignments, which can be nested,
as, for example, in: 

<pre>
    [ 1, a=2 ] // a=2
    [ 1, a = [ b = [2,3,4] ] ] // a=[ [2,3,4] ] b=[2,3,4]
</pre>

<h2><a name="Nesting">Nesting</a></h2>

<p>SVL vectors can be nested. In other words, a vector can contain another
vector. We count the levels of nesting from the vector's <i>top level</i>.  The
top level of a vector comprises objects that are enclosed by the outermost set
of vector delimiters. The <i>first level</i> of nesting refers to the objects
belonging to the top-level elements, and so forth.  The <i>leaf level</i> is
the earliest (closest to top) level of nesting in which all the elements are
scalars. When the top level and the leaf level are one and the same, as in
<tt>[1,2,'a',&quot;b&quot;]</tt>, a vector is referred to as being <i>flat</i>.

<pre>
    [ [ 1, [3,4] ], [ &quot;a&quot;, ['a', 2] ] ]
      [ 1, [3,4] ] [ &quot;a&quot;, ['a', 2] ] top level elements
      1 [3,4] &quot;a&quot; ['a', 2] first nesting level
      1 3 4 &quot;a&quot; 'a' 2 second nesting level
                                (leaf level)
      1 3 4 &quot;a&quot; 'a' 2 subsequent levels
                                are identical
</pre>

<p>Observe that scalars continue to exist through all levels of nesting. This
is due to the arbitrary nestability of scalar quantities, as was discussed in
<a href="#UnitExtension">Unit Extension</a>.

<h2><a name="IndexingandTagging">Vector Elements: Indexing and Tagging</a></h2>

<p>Vectors can be treated as either ordered or unordered lists. In the
former case, each element has an associated numerical <i>index</i> or
<i>subscript</i>, in the latter, each element is <i>tagged</i> or
<i>keyed</i>.

<h3><a name="Indexing">Indexing</a></h3>

<p>When vectors are untagged, they are ordered lists. Elements are
consecutively numbered from left to right, beginning at 1. These indices can be
generated using the index generator <tt>x_id</tt>. The largest index gives the
length of the vector, which can also be found using the <tt>length</tt>.

<p>Indices need not be numbers, but can also be expressions, such as
<tt>a+3</tt> or <tt>x(1)</tt>.  Indices less than 1, i.e. 0 and
negative numbers, are never valid, and any attempt to access vector elements
using indices less than 1 will always result in an error.  However, it
<i>is</i> permissible to access elements whose indices are greater than the
length of the vector, that is, elements beyond the end of the vector. These
elements are nulls <tt>[]</tt>.

<p>See <a href="#PrimaryDataAccessFunctions">primary data access
functions</a> for more on accessing indexed elements and elements beyond
the end of a vector. 

<h3><a name="Tagging">Tagging</a></h3>

<p>Vector elements can be <i>tagged</i>. A tagged vector has the form: 

<pre>
    [ tok:opt, ..., tok:opt ]
</pre>

<p>where <tt>tok</tt>, the tag, is an identifier (a token) undelimited by
single quotes, double quotes, or brackets, and where <tt>opt</tt>, the tagged
field, also called an <i>option field</i>, is an expression.  Together, a tag
and its field are known as an <i>attribute-value pair</i>.  This is also known
as an <i>options</i> construct. A tag is separated from its field by a colon
(<tt>:)</tt>. The dot operator <tt>.</tt>, shorthand for <tt>tagpeek</tt>, is
used to access a tagged field. For example:

<pre>
    svl&gt; v = [ hey:3, ho:&quot;hello&quot; ]
    svl&gt; v.ho
    &quot;hello&quot;
    svl&gt; v.ho = 'good-bye'; v
    [ hey:3, ho:'good-bye' ]
    svl&gt; tagpeek [ v, 'hey' ]
    3
</pre>

<p>Tag names should begin with a letter (a-z, A-Z) or an underscore _.  There
is no checking performed on the existence of tag names. Attempting to access a
field by a non-existent tag will result in a null <tt>[] </tt>being
returned. Multiple occurrences of a tag name may occur in one vector. In this
case, the value of the first tag encountered when scanning the vector from left
to right is returned.

<p>The primary use of tagged vectors is dynamic parameter passing. For
instance, optional parameters can be achieved by concatenating an options and a
defaults vector. Doing so allows the fields of the options vector to override
those of the default.

<h2><a name="SVLFunctions">SVL Functions</a></h2>

<p>SVL provides a rich set of built-in functions, such as trigonometric
functions, random number generators, sampling, sorting, and permutation
functions, as well as mathematical reduction functions. Syntactic shorthand
notations are provided for common functions such as addition and
multiplication. SVL functions (we speak here of <i>generic</i> SVL; a given
application may have an additional set of built-in functions written in SVL)
can be classified according to functionality. Loosely, functions fall under one
or more of the following categories:

<ul>
<li><b>Operators</b>: extensions of scalar operators: 
    <ul>
      <li>Unary: arithmetic functions, type conversions, 
	 logical properties, identities, random number generators
      <li>Binary: arithmetic, logical, relational, and bitwise functions<ul>
	  <li>Lexicographic
	  <li>Element-wise
	</ul>
      
    </ul>

<li><b>Structural Functions</b>: functions that deal with the ordering and 
value of elements: 

    <ul>
      <li>Primary   data   access   functions:   <tt>get</tt>,   <tt>peek</tt>,
      <tt>put</tt>, <tt>poke</tt>
      <li>m_-type and x_-type functions
      <li>Functions that preserve the original ordering of elements
      <li>Functions that preserve all original elements, but re-order them
      <li>Re-shaping functions
    </ul>

<li><b>I/O Functions</b>: sread, fread, write, swrite, fwrite, pr, print, 
	file handling functions;

<li><b>Conversion Functions</b>: string, token, int, real, char

<li><b>Module and Task Management Functions</b>: load, script, fork, etc.

<li><b>Miscellaneous Functions</b>: igen, length, null, sleep, clock, quit, etc.
</ul>

<p>Functions take one and only one argument. A function argument is a
vector. If a function requires multiple inputs, these will comprise the
elements of the vector argument. Within the function definition, the argument
values are assigned to variables local to the function. The process of doing
this assignment is called <i>argument comprehension</i>.  The elements of the
argument vector need not all be assigned, and scalar elements up to the second
level of nesting may be assigned. Beyond the second level of nesting, only
entire sub-vectors can be assigned. If the vector passed to the function is of
insufficient length or depth, nulls are assigned to the local variables.

<p>Here is an example where the expected argument vector has five leaf-level
elements, of which only four are assigned to local variables.  Note that the
argument vector may be of arbitrary shape.

<pre>
    function some_func [ a, [] , [ b, [c,d] ] ]
	...
    endfunction
</pre>

<p>If <tt>some_func</tt> is called as follows: 

<pre>
    some_func [ 1, 2, [ [3,4], [5,6] ] ]
</pre>

<p>then the local variable assignments are: 

<pre>
    a = 1;
    b = [3,4];
    c = 5;
    d = 6;
</pre>

<p>The brackets that you see enclosing the input argument in our illustrations
of function calls, e.g. <tt>join [a,b]</tt>, are not a part of the
function definition. This is in contrast, for instance, to C, where functions
are signaled by parentheses, e.g. <tt>main( )</tt>. In most of the
examples in this document, we have put a space between the function name and
the function argument to emphasize this distinction. Observe that if we set
<tt>v</tt>&nbsp;<tt>= [a,b]</tt>, then we can invoke join by typing join
<tt>v</tt>.  Using brackets here to enclose <tt>v</tt> would in fact result in
a syntax error. <b>

<p>Note:</b> When calling a function without passing any arguments, <tt>[]</tt>
must be provided as the function argument. Scalar arguments may, of course, be
passed without brackets.

<pre>
    svl&gt; neg 2 // scalar argument, call without brackets
      -2
    svl&gt; m = [ &quot;ab&quot;, [2,1] ]
    svl&gt; m[2] // careful! shorthand for get
      [ [2,1] ]
    svl&gt; m 2 // error!
</pre>

<p>The call <tt>m[2]</tt> is really shorthand for <tt>m[ [2] ]</tt>, which
is shorthand for <tt>get</tt> <tt>[ m, [2] ]</tt>; observe that the
argument (here <tt>2</tt>) is an index list, i.e. a vector. 

<p>For more on <tt>get</tt> see
<a href="#PrimaryDataAccessFunctions">
Primary Data Access Functions</a>.

<h3><a name="FunctionExtension">Function Extension</a></h3>

<p>Some functions operate only at the top level of a vector. This is the case,
for instance, of most structural functions and all lexicographic
operators. These functions can be forced to descend one level of nesting using
<i>function extension</i> or <i>apply-to-each</i>.  The
<tt>app</tt> function distributes a function over the top-level elements
of a vector. 

<p>Here is an example of the behavior of an app'd function: 

<pre>
    svl&gt; reverse [ &quot;ab&quot;, &quot;cde&quot;, &quot;fghi&quot; ]
    [ &quot;fghi&quot;, &quot;cde&quot;, &quot;ab&quot; ]
    svl&gt; app reverse [ &quot;ab&quot;, &quot;cde&quot;, &quot;fghi&quot; ]
    [ &quot;ba&quot;, &quot;edc&quot;, &quot;ihgf&quot; ]
</pre>

<p>Observe how the applied-to-each function operates only on elements at
the first level of nesting.

<p>A special form of <tt>app</tt> is <tt>apt</tt>, short for <tt>app
tr</tt>, where <tt>tr</tt> is the transpose function. <tt>apt</tt> first
matrix-transposes the arguments to the function to be applied, and then
app's the function. Here is an example: 

<pre>
    svl&gt; get [ [10,20,30], [1,2] ]
    [10,20]
    svl&gt; get [ [ [10,20,30], [40,50] ], [1,2] ]
    [ [10,20,30], [40,50] ]
    svl&gt; apt get [ [ [10,20,30], [40,50] ], [1,2] ]
    [10,50]
</pre>

<h3><a name="Operators">Operators</a></h3>

<p>A special kind of SVL function is the <i>operator</i>. SVL operators have
both infix (traditional symbolic shorthand, such as <tt>+</tt> and
<tt>&gt;</tt>) and prefix (the longhand SVL function name, such as
<tt>add</tt>) notations. There are 2 kinds of operators: <ul> <li>Unary
operators (referred to as <i>unops</i>) operate on individual arguments,
e.g. <tt>neg</tt>.  <li>Binary operators (referred to as <i>binops</i>)
operate on two arguments at once
e.g. <tt>add</tt>.
</ul>

<p>Some SVL operators are element-wise vector generalizations of scalar
operators which can operate on vectors in addition to scalars. For
example, add in SVL allows element-wise addition of 2 vectors, as well as
addition with unit extension. 

<h3><a name="UnaryOperators">Unary Operators</a></h3>

<p>Unary operators operate at the leaf level of a vector. The result of
applying an unop to a vector is a vector of the same shape as the input, with
each scalar element transformed according to the applied operation. Here is an
example: 

<pre>
    svl&gt; neg [1,2,3]
    [-1,-2,-3]
    svl&gt; neg [ 1, [2,3] ]
    [ -1, [-2,-3] ]
</pre>

<h3><a name="BinaryOperatorsAndReduction">Binary Operators and Reduction</a></h3>

<p>In general, when binary operators are called with 2 input vectors, the
binary operation is applied to pairs of corresponding elements, one taken
from each input vector. (One notable exception is lexicographic operators,
which will be discussed in the next section; for now, we will not take
them into consideration.) The 2 input vectors must be conformable, and the
operations are performed on their leaves. 

<pre>
    svl&gt; pow [ [ 2, [3,4] ], [ 4, [2,3] ] ]
    [ 16, [9,64] ]
</pre>

<p>Some binary operators, however, can accept more than 2 arguments. The
word &quot;argument&quot; refers to any of the top-level elements
comprising the function's single argument vector. Arguments are said to be
<i>reducible</i>. The arguments, which must be conformable, are combined
through the successive applications of the operator <tt>op</tt> to each
argument paired with the result of a previous application of <tt>op</tt>.
(This is a conceptual explanation of what takes place; the SVL
implementation is not necessarily sequential.) Such an operation implies
that op be associative to guarantee that the result of a reduction be the
same no matter how it is evaluated. Here are a few examples of arithmetic
reduction: 

<pre>
    svl&gt; add [3,4,5]
    12
    svl&gt; add ( [2,3,4] * [5,6,7] ) // dot product
    56
    svl&gt; mul [3,4,5]
    60
    svl&gt; maxE [0,-1,4,3]
    4
    svl&gt; minE [0,-1,4,3]
    -1
</pre>

<p>Logical operators behave in the same manner: 

<pre>
    svl&gt; andE [1,1,0]
    0
    svl&gt; orE [1,1,0]
    1
    svl&gt; xorE [1,0,0]
    1
</pre>

<p>Relational operators reduce as follows:

<pre>
    f [a,b,c,d] = andE [ f[a,b], f[b,c], f[c,d] ]
</pre>

<p>Hence, the following: 

<pre>
    svl&gt; ltE [-1,0,3,4]
    1
    svl&gt; ltE [1,0,3,4]
    0
</pre>

<h3><a name="LexicographicAndElementWiseOperators">
Lexicographic and Element-wise Operators</a></h3>

<p>Relational and logical operators are classified into 2 types:
<i>lexicographic</i> and <i>element-wise</i>.  Only element-wise operators are
considered binops, and only they reduce.

<p>Relational operators are referred to as lexicographic if comparisons
are made among only top-level elements, otherwise they are element-wise.
In the former case, the operators are marked by the suffix <tt>L</tt>, in
the latter, by the suffix <tt>E</tt>.

<p>Comparisons are made based on ASCII value, which is, essentially,
<i>dictionary order</i>, summarized in the following table:

<div align="center"><center>

<table border="1" width="70%" cellpadding="4">
  <tr>
    <th WIDTH="70%">Object</th>
    <th WIDTH="30%">Placement</th>
  </tr>
  <tr>
    <td>Numbers (consecutive order)</td>
    <td>First </td>
  </tr>
  <tr>
    <td>Double-quoted characters<br>
    ASCII ordering:<br>
    Punctuation, A-Z, a-z</td>
    <td>Last</td>
  </tr>
  <tr>
    <td>Token data</td>
    <td>Unordered</td>
  </tr>
</table>
</center></div>

<p>Here are a few illustrations of the difference in behavior between
<tt>L</tt> and <tt>E</tt> operators. Note that element-wise operators
require that their arguments be conformable, whereas lexicographic ones do
not. 

<pre>
    svl&gt; [1,2] == [1,3]             // == shorthand for eqE
    [1,0]
    svl&gt; [1,2] === [1,3]            // === shorthand for eqL
    0
    svl&gt; minE [ [2,4], [1,3,5] ]    // error!
    svl&gt; minL [ [2,4], [1,3,5] ]
    [1,3,5]
    svl&gt; minE [ ["c","d"], ["a","e"] ]
    "ad"                            // equivalent to ["a","d"]
    svl&gt; minL [ ["c","d"], ["a","e"] ]
    "ae"                            // equivalent to ["a","e"]
</pre>

<h3><a name="StructuralFunctions">Structural Functions</a></h3>

<p>The umbrella term <i>structural functions</i> loosely groups together
an assemblage of SVL functions that extract, insert and re-order vector
elements without modifying the individual element values. The primary data
access functions extract and insert elements according to an index list
which specifies the elements to extract and insert. Data access can also
be mediated by vector masks. Several functions can be invoked to generate
both vector masks and index lists. Other functions make extractions
according to element value rather than to position.

<h3><a name="PrimaryDataAccessFunctions">Primary Data Access Functions</a></h3>

<p>There are four primary data access functions: <tt>get</tt> and
<tt>peek</tt>, and their counterparts, <tt>put</tt> and <tt>poke</tt>.


<p><tt>get</tt> extracts a sub-vector from amongst the top-level elements of
the original input vector, whereas <tt>peek</tt> extracts only one element
from the input vector, from any level of nesting. <tt>get</tt> leaves the
extracted elements at the same level of nesting as in the source, while
<tt>peek</tt> decreases their level of nesting.

<p>Similarly, <tt>put</tt> replaces the top-level elements of a vector
with the elements belonging to its argument vector, whereas <tt>poke</tt>
replaces a single element at any level of nesting. <tt>put</tt> leaves the
inserted elements at the same level of nesting as found in the source,
while <tt>poke</tt> increases their level. Neither function changes the
length of the vector. Note that <tt>put</tt> and <tt>poke</tt> do not
actually alter the value of their source vectors; they merely return
values without overwriting their sources.

<p>Because the primary data functions are so frequently used, shorthand
notations exist. <tt>get</tt> and <tt>put </tt>can be indicated by
brackets <tt>[]</tt>, and <tt>peek</tt> and <tt>poke</tt> by parentheses.


<p><b>Note:</b> The <tt>put</tt> and <tt>poke</tt> shorthand notations are
not exactly equivalent to their longhand notations because they overwrite
their source vectors with their return values. Thus, the shorthand
notations include the assignment symbol <tt>=</tt>.

<p>Remember that the order of parameters to <tt>put</tt> and <tt>get</tt> is
the same as in their shorthand forms, i.e. destination, index, value. 

<pre>
    svl&gt; a = [ 1, [2,3], 4 ]
    svl&gt; a[2] // get
    [ [2,3] ]
    svl&gt; a(2) // peek
    [2,3]
    svl&gt; a[ [2,1] ] // get: elements 2 and 1
    [ [2,3], 1 ]
    svl&gt; a( [2,1] ) // peek: element 2's first element
    2
    svl&gt; a[ [2,1] ] = [ 5, 6 ]; a // put into elements 2 and 1
    [6,5,4]
    svl&gt; a = [ 1, [2,3], 4 ]
    svl&gt; a( [2,1] ) = [ 5, 6 ]; a // poke element 1 of element 2
    [ 1, [ [5,6], 3 ], 4 ]
    svl&gt; b = [2,3]; a( b(2) ) // index is an expression
    4
</pre>

<p>A summary of Primary Access Functions get and peek is as follows:

<p><center>
<table border="1" width="80%" cellpadding="3">
  <tr>
    <td><b>Behavior</b></td>
    <td><tt>get</tt> </td>
    <td><tt>peek</tt> </td>
  </tr>
  <tr>
    <td>Extracts </td>
    <td>vector of elements </td>
    <td>one element</td>
  </tr>
  <tr>
    <td>Extracts from </td>
    <td>top level </td>
    <td>any level </td>
  </tr>
  <tr>
    <td>Extracted objects' level of nesting</td>
    <td>same </td>
    <td>decreased </td>
  </tr>
</table>
</center>

<p>A summary of primary access functions, <tt>put</tt> and <tt>poke</tt>, follows:

<center>
<p><table border="1" width="80%" cellpadding="3">
  <tr>
    <td><b>Behavior</b></td>
    <td><tt>put</tt> </td>
    <td><tt>poke</tt> </td>
  </tr>
  <tr>
    <td>Replaces </td>
    <td>several elements </td>
    <td>one element </td>
  </tr>
  <tr>
    <td>Inserts at </td>
    <td>top level </td>
    <td>any level</td>
  </tr>
  <tr>
    <td>Inserted objects' level of nesting</td>
    <td>same </td>
    <td>increased</td>
  </tr>
</table>
</center>


<p>Recall that it is possible to index beyond the end of a vector. This
implies that we can extract and insert elements beyond the end of a
vector: 

<pre>
    svl&gt; a = igen 5; a
    [1,2,3,4,5]
    svl&gt; a(0) // error! can't access this end
    svl&gt; a(6) // peek returns null (not displayed)
    svl&gt; a[6] // get
    [ [] ]
    svl&gt; a(7) = [6,7] // poke
    svl&gt; a[8] = [ [8,9] ]; a // put
    [ 1, 2, 3, 4, 5, [] , [6,7], [8,9] ]
</pre>

<p><tt>get</tt> and <tt>put</tt> have masked variants which use masks
instead of index lists to specify which elements to access. See the next
section for more on masking and indexing.

<h3><a name="m_-typeAndx_-typeFunctions">m_-type and x_-type Functions</a></h3>

<p>SVL vector elements can be specified by their position in a vector
using either an index list or a mask. Both index lists and masks are flat
numeric vectors. There are two conspicuous differences between an index
list and a mask. Firstly, an index list is a list of positions, and thus
can be arbitrarily long or short, and may contain duplicates. A mask,
however, is composed of zero and non-zero values, the non-zero values
marking selected elements. Thus, a mask must match its corresponding
vector exactly in length, except if there is a possibility of
unit-extension. Secondly, an index list may be used to specify elements at
deeper levels of nesting, for instance, when used with <tt>peek</tt> or
<tt>poke</tt>. A mask, however, is applied to only the top level of a
vector. 

<p>SVL functions that involve masks or index lists have a naming
convention that makes this association explicit. The prefix <tt>m_</tt> is
used to mark a function that returns a mask, and the prefix <tt>x_</tt> to
mark one that returns an index list. Note that <tt>get</tt> and
<tt>put</tt> have <tt>m</tt> forms, i.e. without an underscore.
They <i>use</i> rather than <i>return</i> masks or index lists, and they
do not have an <tt>x_</tt> form (because in their basic form, <tt>get</tt>
and <tt>put</tt> use index lists). Similarly, <tt>smear</tt> has an
<tt>m</tt> form, not <tt>m_</tt>, as it also uses rather than returns a
mask. 

<p>SVL functions have the following relationship with their indexed and
masked variants: 

<pre>
    get [ v, x_op v ] = op v
    OR 
    get [ v, x_op [v,w] ] = op [v,w]

    v | m_op v = op v
    OR
    v | m_op [v,w] = op [v,w]
</pre>

<p>Note that the functions <tt>x_minE</tt>, <tt>x_minL</tt>, <tt>x_maxE</tt>,
and <tt>x_maxL</tt> are associated with <tt>peek</tt> rather than with
<tt>get</tt>:

<pre>
    peek [ v, x_minE/L v ] = minE/L v
    peek [ v, x_maxE/L v ] = maxE/L v
</pre>

<h3><a name="ClassificationOfStructuralFunctions">Classification of Structural
Functions</a></h3>

<p>The myriad SVL structural functions can be classified according to
whether or not they preserve the source order of elements, whether or not
they keep all source elements, and whether they maintain or alter the
shape of the source vector. Functions that select elements conditioned on
their value generally preserve the order of the elements as found in the
source. Pure re-ordering functions preserve all the original elements.
Reshaping functions keep all the original elements of the source, but may
replicate some of them, or split them off into separate vectors. For more
on structural functions, consult the function reference. 

<h2><a name="HowCLICommandsAreExecuted">How CLI Commands Are Executed</a></h2>

<p>Command-line interpreter commands input by the user are packaged and
compiled into modules by the interpreter, and then run. Semi-colons are
supplied, if necessary. Because each line becomes a <i>module</i> (an
executable block of vector binary code), multi-line statements are
forbidden. Thus, loops can only be used if their scope is confined to one
line, and function definitions exist only on the line upon which they have
been declared. 

<p>Functions cannot contain &quot;do nothing&quot; (history-insensitive)
statements, that is, statements that contain neither assignments, nor
function calls involving random numbers, nor <tt>print</tt> statements.
Such expressions are legal when entered at the command line, however, for
they are made into <tt>print</tt> statements; this is why their return
values are echoed back to the display. 

<p>For more information on modules see 
<a class="svl" href="funcs.htm">modules</a>. For more information on declaring
variables at the command line see
<a href="funcs.htm">
Variables and Functions at the CLI</a>.

<h2><a name="Built-inConstants">Built-in Constants</a></h2>

<p>SVL has a set of pre-defined constants that give the numerical limits of
your machine.  These constants are given in the following table:

<table border="1" width="100%" cellpadding="4">
  <tr>
    <td valign="top">REAL_MIN</td>
    <td valign="top">minimum positive floating-point number; under IEEE
    standard, smaller positive numbers can be created, but at the expense of
    precision</td>
  </tr>
  <tr>
    <td valign="top">REAL_MAX</td>
    <td valign="top">maximum positive floating-point number</td>
  </tr>
  <tr>
    <td valign="top">REAL_BITS</td>
    <td valign="top">number of bits in the mantissa of a 
	floating-point number</td>
  </tr>
  <tr>
    <td valign="top">INT_MIN</td>
    <td valign="top">maximum negative integer</td>
  </tr>
  <tr>
    <td valign="top">INT_MAX</td>
    <td valign="top">maximum positive integer</td>
  </tr>
  <tr>
    <td valign="top">EPS_M</td>
    <td valign="top">machine epsilon: floating-point precision </td>
  </tr>
  <tr>
    <td valign="top">REAL_IEEE</td>
    <td valign="top">1 if IEEE standard used, 0 otherwise </td>
  </tr>
  <tr>
    <td valign="top">REAL_MAXEXP </td>
    <td valign="top">maximum exponent for positive numbers in e-notation </td>
  </tr>
  <tr>
    <td valign="top">REAL_MINEXP </td>
    <td valign="top">minimum exponent for normalized positive numbers in
    e-notation; under IEEE standard, the exponent may be further reduced, but
    at the expense of precision </td>
  </tr>
  <tr>
    <td valign="top">REAL_DIGITS </td>
    <td valign="top">number of significant bits in a floating-point number </td>
  </tr>
  <tr>
    <td valign="top">REAL_INF </td>
    <td valign="top">positive infinity (1/0) </td>
  </tr>
  <tr>
    <td valign="top">INT_BITS </td>
    <td valign="top">number of bits (including sign bit) in an integer </td>
  </tr>
</table>
<i>

<p align="center">SVL Built-In Constants</p>
</i>

<p>Next: <a href="data.htm">SVL Expressions</a>

<p><a href="../../fcnindex.htm">Function Index</a>

<noscript>
	<hr noshade="noshade" />
	<font size="2"> Copyright &copy; 1997&ndash;2015
	<a href="http://www.chemcomp.com">Chemical Computing Group Inc.</a> </font>
</noscript>
<div id="MoeFooter"></div>
</body>
</html>
