<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">


<!--	s_expr.htm			expressions
!!-->

<!--
!!    MOE Online Manuals
!!    COPYRIGHT (C) 1997-2015
!!        CHEMICAL COMPUTING GROUP INC.  ALL RIGHTS RESERVED.
!!-->

<head>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<script type="text/javascript" 
src="../../include/jsincludes_moe.js"></script>

<link rel="stylesheet" type="text/css"
href="../../include/manstyle.css" />


<meta SVL:syntax SVL Expressions>

<title>SVL Expressions</title>
</head>
<body>
<div id="MoeHeader"></div>
<noscript>
	<span class="warning">Warning: JavaScript is disabled. This page will not display correctly.</span>
	<h1 class="title">MOE Documentation</h1>
	<hr noshade="noshade" />
	<style>.LaTeX {color: #C08080;}</style>
</noscript>

<h2>Syntax</h2>

<p>
<blockquote>
<table border="0">

<tr>
    <td valign="top"><i>expression</i>:</td>
    <td width="10"></td>
    <td>
	: <i>primary</i><br />
	: <tt>-</tt> <i>expression</i><br />
	: <i>expression binop expression</i><br />
	: <i>lvalue</i> <tt>=</tt> <i>expression</i>
    </td>
</tr>
<tr>
    <td><i>binop</i> </td>
    <td></td>
    <td>: <b>{</b>
	    <tt>+</tt>
	<b>|</b> <tt>-</tt>
	<b>|</b> <tt>*</tt>
	<b>|</b> <tt>/</tt>
	<b>|</b> <tt>&lt;</tt>
	<b>|</b> <tt>&gt;</tt>
	<b>|</b> <tt>&lt;=</tt>
	<b>|</b> <tt>&gt;=</tt>
	<b>|</b> <tt>&lt;&gt;</tt>
	<b>|</b> <tt>==</tt>
	<b>|</b> <tt>===</tt>
	<b>|</b> <tt>and</tt>
	<b>|</b> <tt>or</tt>
	<b>|</b> <tt>|</tt>
	<b>|</b> <tt>||</tt>
	<b>}<sup>1</sup></b>
    </td>
</tr>
<tr>
    <td valign="top"><i>primary</i></td>
    <td width="10"></td>
    <td>
	: <i>number</i><br />
	: <i>string</i> <b>{</b><i>string</i><b>}<sup>*</sup></b><br />
	: <i>token</i> <b>{</b><i>token</i><b>}<sup>*</sup></b><br />
	: <i>var_name</i><br />
	: <tt>*</tt> <i>var_name</i><br />
	: <tt>(</tt> <i>expression</i> <tt>)</tt><br />
	: <tt>[</tt> <i>expression</i><tt> </tt>
	    <b>{</b><tt>,</tt> <i>expression</i><b>}<sup>*</sup></b>
	    <tt>]</tt><br />
	: <tt>[&nbsp;]</tt><br />
	: <i>fcn_name</i> <i>expression</i><br />
	: <tt>app</tt> <i>fcn_name</i> <i>expression</i><br />
	: <tt>apt</tt> <i>fcn_name</i> <i>expression</i><br />
	: <tt>#</tt> <i>fcn_name</i><br />
	: <i>primary</i> <tt>[</tt> <i>expression</i> <tt>]</tt><br />
	: <i>primary</i> <tt>(</tt> <i>expression</i> <tt>)</tt><br />
	: <tt>[</tt>
	    <i>tag</i> <tt>:</tt> <i>expression</i>
	    <b>{</b>
		<tt>,</tt> <i>tag</i> <tt>:</tt> <i>expression</i>
	    <b>}<sup>*</sup></b>
	  <tt>]</tt><br />
	: <i>primary</i> <tt>.</tt> <i>tag</i><br />
	: <i>primary</i> <tt>.</tt> <tt>(</tt> <i>expression</i> <tt>)</tt>
    </td>
</tr>
<tr>
    <td valign="top"><i>tag</i></td>
    <td width="10"></td>
    <td>:
	<b>{</b> <i>identifier</i> | <i>token</i> <b>}<sup>1</sup></b>
    </td>
</tr>
<tr>
    <td valign="top"><i>lvalue</i>:</td>
    <td width="10"></td>
    <td>
	: <i>var_name</i><br />
	: <tt>[ </tt><i>var_name</i>
	    <b>{</b><tt>,</tt> <i>var_name</i><b>}<sup>*</sup></b>
	    <tt>]</tt><br />
	: <i>var_name</i> <tt>(</tt> <i>expression</i> <tt>)</tt>
	    <b>{</b><tt>(</tt> <i>expression</i>
	    <tt>)</tt><b>}<sup>*</sup></b><br />
	: <i>var_name</i> <tt>[</tt> <i>expression</i> <tt>]</tt><br />
	: <i>var_name</i> <tt>|</tt> <i>expression</i><br />
	: <i>var_name</i> <tt>||</tt> <i>expression</i><br />
	: <i>var_name</i> <tt>.</tt> <i>identifier</i><br />
	: <i>var_name</i> <tt>.(</tt> <i>expression</i> <tt>)</tt><br />
	: <tt>*</tt> <i>var_name</i><br />
	: <tt>*</tt> <i>var_name</i> <tt>(</tt> <i>expression</i> <tt>)</tt>
	    <b>{</b><tt>(</tt> <i>expression</i>
	    <tt>)</tt><b>}<sup>*</sup></b><br />
	: <tt>*</tt> <i>var_name</i> <tt>[</tt> <i>expression</i> <tt>]</tt><br />
	: <tt>*</tt> <i>var_name</i> <tt>|</tt> <i>expression</i><br />
	: <tt>*</tt> <i>var_name</i> <tt>||</tt> <i>expression</i><br />
	: <tt>*</tt> <i>var_name</i> <tt>.</tt> <i>identifier</i><br />
	: <tt>*</tt> <i>var_name</i> <tt>.(</tt> <i>expression</i> <tt>)</tt>
    </td>
    </td>
</tr>

</table>
</blockquote>

<h2>Description</h2>

<p>The only data structure of SVL is the <i>vector</i>. Expressions operate
on vectors. The result of an expression is also a vector.  A vector of length
<tt>0</tt> is a null vector, denoted by <tt>[]</tt>.  Numeric vectors contain
only numbers, character vectors contain only characters, and token vectors
contain only tokens; such vectors are termed <i>homogeneous</i>. Types can be
mixed (forming <i>heterogeneous</i> vectors), and vectors can nest to
arbitrary depths.  Vectors that are not nested (i.e, of depth
<tt>1</tt>) are called <em>flat</em> vectors. Strings are flat character
vectors.</p>

<p>
The following notation is used to describe SVL syntax and syntactic
categories.
The name of a category is printed in italics, e.g. <i>lvalue</i>.</li>
SVL keywords and symbols are printed in teletype, e.g. <tt>loop</tt>
or <tt>[]</tt>.</li>
Each category is defined as a list of syntactic patterns composed
of SVL keywords or symbols and of names of other categories (like BNF
notation); for example,
<i>lvalue</i> : <i>identifier</i> <tt>[</tt> <i>expression</i> <tt>]</tt> 
means "an lvalue can be an identifier followed by a bracketed expression".
Bold braces are used to apply a special rule to the part of the pattern
inside the braces:

<ul>
<li><b>{</b>...<b>}</b> specifies an optional pattern, e.g.
    <span class="nobr"><b>{</b><em>for</em><b>}</b> <tt>loop</tt></span>
</li>

<li><b>{</b>...<b>}<sup>*</sup></b> specifies a sequence of zero or more
    repetitions, e.g.
    <span class="nobr"><b>{</b><em>while</em><b>}<sup>*</sup></b> <tt>loop</tt></span>
</li>

<li><b>{</b>...<b>}<sup>+</sup></b> specifies a sequence of one or more
    repetitions, e.g.
    <span class="nobr"><b>{</b><em>digit</em><b>}<sup>*</sup></b></span>
</li>

<li><b>{</b>...<b>|</b>...<b>}</b> and
    <b>{</b>...<b>|</b>...<b>}<sup>1</sup></b> specify
    (optional and compulsory) alternative patterns, e.g.
    <span class="nobr"><b>{</b><tt>local</tt><b> | </b><tt>global</tt><b>}</b>
	<tt>function</tt></span>
</li>
</ul>


<p><b>Primary Expressions</b>.  Vectors can be constructed from literals
(constants) or aggregates of other expressions using square brackets
<tt>[</tt>&nbsp;...&nbsp;<tt>]</tt>.  The null vector, or length zero
vector is denoted with square brackets enclosing an empty expression.
Parentheses enclosing expressions are used to override operator precedence
and have no structural implications.
<p>
<blockquote>
<table border="0">
<tr>
    <td valign="top"><i>primary</i></td>
    <td width="10"></td>
    <td>
	: <i>number</i><br />
	: <i>string</i> <b>{</b><i>string</i><b>}<sup>*</sup></b><br />
	: <i>token</i> <b>{</b><i>token</i><b>}<sup>*</sup></b><br />
	: <i>var_name</i><br />
	: <tt>*</tt> <i>var_name</i><br />
	: <tt>(</tt> <i>expression</i> <tt>)</tt><br />
	: <tt>[</tt> <i>expression</i><tt> </tt>
	    <b>{</b><tt>,</tt> <i>expression</i><b>}<sup>*</sup></b>
	    <tt>]</tt><br />
	: <tt>[&nbsp;]</tt><br />
    </td>
</tr>
</table>
</blockquote>

<p>Note that in the case of <i>string</i> and <i>token</i>, zero or more
occurrences with only intervening white space are automatically concatenated 
into a single string or token.  <i>var_name</i> denotes an <i>identifier</i>
that is, or has been declared to be, a variable (i.e. not a function).

Syntax <tt>*</tt><i>var_name</i> denotes a <i>dynamic variable</i>.
A dynamic variable is first allocated using the function <tt>dvar_open</tt>
and then accessed by the prefix <tt>*</tt>, followed by
the name of a variable storing the numerical key of the dynamic variable.

<p>
All SVL functions accept exactly one argument, a vector, and return exactly
one value, a vector.  Therefore, no parentheses are required to indicate
arguments to functions (as in other languages).  A function call is
indicated by a function <i>identifier</i> (<i>fcn_name</i>) followed by
the single argument expression.  Functions which normally operate at the
top level of vectors can be forced to descend one level of nesting by using
the <tt>app</tt> or <tt>apt</tt> keywords. This results in the function
being distributed over, or applied-to-each of, the top-level elements of
the vector.
<p>
<blockquote>
<table border="0">
<tr>
    <td valign="top"><i>primary</i></td>
    <td width="10"></td>
    <td>
	: <i>fcn_name</i> <i>expression</i><br />
	: <tt>app</tt> <i>fcn_name</i> <i>expression</i><br />
	: <tt>apt</tt> <i>fcn_name</i> <i>expression</i><br />
    </td>
</tr>
</table>
</blockquote>

<p>
The address of an SVL functions may be obtained with the special syntactic
expression:
<p>
<blockquote>
<table border="0">
<tr>
    <td valign="top"><i>primary</i></td>
    <td width="10"></td>
    <td>
	: <tt>#</tt> <i>fcn_name</i><br />
    </td>
</tr>
</table>
</blockquote>

<p>Components of a vector may be extracted by indexing (subscripting).  There
are two forms of indexing: <i>peek</i> (indicated by subscripting with
parentheses) and <i>get</i> (indicated by subscripting with square brackets):

<p>
<blockquote>
<table border="0">
<tr>
    <td valign="top"><i>primary</i></td>
    <td width="10"></td>
    <td>
	: <i>primary</i> <tt>[</tt> <i>expression</i> <tt>]</tt><br />
	: <i>primary</i> <tt>(</tt> <i>expression</i> <tt>)</tt><br />
    </td>
</tr>
</table>
</blockquote>

<p>These primary expressions are shorthand notations for SVL subscripting
functions.
The primary expression <i>value</i>&nbsp;<tt>(</tt><i>index</i><tt>)</tt>
is equivalent to the function call
<span class="nobr"><tt>peek[</tt><i>value</i><tt>,</tt><i>index</i><tt>]</tt></span>.
The primary expression <i>value</i>&nbsp;<tt>[</tt><i>index</i><tt>]</tt>
is equivalent to the function call
<span class="nobr"><tt>get[</tt><i>value</i><tt>,</tt><i>index</i><tt>]</tt></span>.

If <span class="nobr"><i>e</i><sub>1</sub>, ... , <i>e</i><sub><i>N</i></sub></span>
are expressions, then

<span class="nobr"><tt>[</tt><i>e</i><sub>1</sub>, ...
,<i>e</i><sub><i>N</i></sub><tt>]</tt></span>

is a vector of <i>N</i> elements such that its <i>i</i>-th element is
<i>e</i><sub><i>i</i></sub>.

<tt>peek</tt> extracts a single element of the vector,
while <tt>get</tt> extracts multiple elements:

<tt>peek[[</tt><i>e</i><sub>1</sub><tt>,</tt>...<tt>,</tt>
    <span class="nobr">
	<i>e</i><sub><i>N</i></sub><tt>],</tt>
	<i>i</i><tt>]</tt>
    </span>
returns <i>e</i><sub><i>i</i></sub> while
    <span class="nobr">
	<tt>get[[</tt><i>e</i><sub>1</sub><tt>,</tt>...<tt>,</tt>
	<i>e</i><sub><i>N</i></sub><tt>],</tt>
	<tt>[</tt><i>i</i><tt>,</tt> <i>j</i>...<tt>]]</tt>
    </span>
returns
    <span class="nobr">
	<tt>[</tt><i>e</i><sub><i>i</i></sub><tt>,</tt>
	<i>e</i><sub><i>j</i></sub>...<tt>]</tt>
    </span>.

An out-of-range index produces an error if it is less than <tt>1</tt>,
otherwise it produces a null (<tt>[]</tt>). </p>

<p>A <i>tagged</i> vector is shorthand for a vector constructed of pairs of
tokens and data values.  A special form of indexing is provided to extract
a value from a tagged vector: <tt>tagpeek</tt> denoted with a dot

<p>
<blockquote>
<table border="0">
<tr>
    <td valign="top"><i>primary</i></td>
    <td width="10"></td>
    <td>
	: <tt>[</tt>
	    <i>tag</i> <tt>:</tt> <i>expression</i>
	    <b>{</b>
		<tt>,</tt> <i>tag</i> <tt>:</tt> <i>expression</i>
	    <b>}<sup>*</sup></b>
	  <tt>]</tt><br />
	: <i>primary</i> <tt>.</tt> <i>tag</i><br />
	: <i>primary</i> <tt>.</tt> <tt>(</tt> <i>expression</i> <tt>)</tt>
    </td>
</tr>
<tr>
    <td valign="top"><i>tag</i></td>
    <td></td>
    <td>
	: <b>{</b> <i>identifier</i> | <i>token</i> <b>}<sup>1</sup></b>
    </td>
</tr>
</table>
</blockquote>

<p>
Note that the tag is always interpreted as a token, whether it is supplied
with or without the enclosing single quotes; for example: </p>

<pre>    [ name: 'John', size: 10, 'next item': 35 ]
</pre>

specifies three tags: <tt>'name'</tt>, <tt>'size'</tt>, and
<span class="nobr"><tt>'next item'</tt></span>.


<p>
<b>Operators</b>.
There are two types of operators: <i>unary</i> and <i>binary</i>. Unary
operators operate on one expression, while binary operators operate on two.
Syntactically, we have:</p>

<p>
<blockquote>
<table border="0">
<tr>
    <td valign="top"><i>expression</i>:</td>
    <td width="10"></td>
    <td>
	: <i>primary</i><br />
	: <tt>-</tt> <i>expression</i><br />
	: <i>expression binop expression</i><br />
	: <i>lvalue</i> <tt>=</tt> <i>expression</i>
    </td>
</tr>
<tr>
    <td><i>binop</i> </td>
    <td></td>
    <td>: <b>{</b>
	    <tt>+</tt>
	<b>|</b> <tt>-</tt>
	<b>|</b> <tt>*</tt>
	<b>|</b> <tt>/</tt>
	<b>|</b> <tt>&lt;</tt>
	<b>|</b> <tt>&gt;</tt>
	<b>|</b> <tt>&lt;=</tt>
	<b>|</b> <tt>&gt;=</tt>
	<b>|</b> <tt>&lt;&gt;</tt>
	<b>|</b> <tt>==</tt>
	<b>|</b> <tt>===</tt>
	<b>|</b> <tt>and</tt>
	<b>|</b> <tt>or</tt>
	<b>|</b> <tt>|</tt>
	<b>|</b> <tt>||</tt>
	<b>}<sup>1</sup></b>
    </td>
</tr>
</table>
</blockquote>

<p>Except for the assignment operator, <tt>=</tt>, all operators are
shorthand notations for common SVL functions:

<p>
<center>
<table class="titlebar" border="1" cellpadding="3">

<tr>
    <th>Operator</th>
    <th>Function</th>
    <th>Operator</th>
    <th>Function</th>
</tr>

<tr>
    <td><tt>-</tt> <i>ex</i></td>
    <td><tt>neg</tt> <i>ex</i></td>
    <td><i>ex</i><sub>1</sub> <tt>&lt;</tt> <i>ex</i><sub>2</sub></td>
    <td><tt>ltE[</tt> <i>ex</i><sub>1</sub> <tt>,</tt> <i>ex</i><sub>2</sub>
	<tt>]</tt></td>
</tr>

<tr>
    <td><i>ex</i><sub>1</sub> <tt>+</tt> <i>ex</i><sub>2</sub></td>
    <td><tt>add[</tt> <i>ex</i><sub>1</sub> <tt>,</tt> <i>ex</i><sub>2</sub>
	<tt>]</tt></td>
    <td><i>ex</i><sub>1</sub> <tt>&gt;</tt> <i>ex</i><sub>2</sub></td>
    <td><tt>gtE[</tt> <i>ex</i><sub>1</sub> <tt>,</tt> <i>ex</i><sub>2</sub>
	<tt>]</tt></td>
</tr>

<tr>
    <td><i>ex</i><sub>1</sub> <tt>-</tt> <i>ex</i><sub>2</sub></td>
    <td><tt>sub[</tt> <i>ex</i><sub>1</sub> <tt>,</tt> <i>ex</i><sub>2</sub>
	<tt>]</tt></td>
    <td><i>ex</i><sub>1</sub> <tt>&lt;=</tt> <i>ex</i><sub>2</sub></td>
    <td><tt>leE[</tt> <i>ex</i><sub>1</sub> <tt>,</tt> <i>ex</i><sub>2</sub>
	<tt>]</tt></td>
</tr>

<tr>
    <td><i>ex</i><sub>1</sub> <tt>*</tt> <i>ex</i><sub>2</sub></td>
    <td><tt>mul[</tt> <i>ex</i><sub>1</sub> <tt>,</tt> <i>ex</i><sub>2</sub>
	<tt>]</tt></td>
    <td><i>ex</i><sub>1</sub> <tt>&gt;=</tt> <i>ex</i><sub>2</sub></td>
    <td><tt>geE[</tt> <i>ex</i><sub>1</sub> <tt>,</tt> <i>ex</i><sub>2</sub>
	<tt>]</tt></td>
</tr>

<tr>
    <td><i>ex</i><sub>1</sub> <tt>/</tt> <i>ex</i><sub>2</sub></td>
    <td><tt>div[</tt> <i>ex</i><sub>1</sub> <tt>,</tt> <i>ex</i><sub>2</sub>
	<tt>]</tt></td>
    <td><i>ex</i><sub>1</sub> <tt>&lt;&gt;</tt> <i>ex</i><sub>2</sub></td>
    <td><tt>neE[</tt> <i>ex</i><sub>1</sub> <tt>,</tt> <i>ex</i><sub>2</sub>
	<tt>]</tt></td>
</tr>

<tr>
    <td><i>ex</i><sub>1</sub> <tt>|</tt> <i>ex</i><sub>2</sub></td>
    <td><tt>mput[</tt> <i>ex</i><sub>1</sub> <tt>,</tt> <i>ex</i><sub>2</sub>
	<tt>]</tt></td>
    <td><i>ex</i><sub>1</sub> <tt>==</tt> <i>ex</i><sub>2</sub></td>
    <td><tt>eqE[</tt> <i>ex</i><sub>1</sub> <tt>,</tt> <i>ex</i><sub>2</sub>
	<tt>]</tt></td>
</tr>

<tr>
    <td><i>ex</i><sub>1</sub> <tt>||</tt> <i>ex</i><sub>2</sub></td>
    <td><tt>apt
mput[</tt><i>ex</i><sub>1</sub><tt>,</tt><i>ex</i><sub>2</sub><tt>]</tt></td>
    <td><i>ex</i><sub>1</sub> <tt>===</tt> <i>ex</i><sub>2</sub></td>
    <td><tt>eqL[</tt> <i>ex</i><sub>1</sub> <tt>,</tt> <i>ex</i><sub>2</sub>
	<tt>]</tt></td>
</tr>

<tr>
    <td><i>ex</i> <tt>.</tt> <i>id</i></td>
    <td><tt>tagpeek[</tt><i>ex</i> <tt>,</tt><tt>'</tt><i>id</i><tt>'</tt><tt>]</tt></td>
    <td><i>ex</i><sub>1</sub> <tt>and</tt> <i>ex</i><sub>2</sub></td>
    <td><tt>andE[</tt> <i>ex</i><sub>1</sub> <tt>,</tt> <i>ex</i><sub>2</sub>
	<tt>]</tt></td>
</tr>

<tr>
    <td><i>ex</i><sub>1</sub> <tt>.(</tt> <i>ex</i><sub>2</sub> <tt>)</tt></td>
    <td><tt>tagpeek[</tt><i>ex</i><sub>1</sub><tt>,</tt><i>ex</i><sub>2</sub><tt>]</tt></td>
    <td><i>ex</i><sub>1</sub> <tt>or</tt> <i>ex</i><sub>2</sub></td>
    <td><tt>orE[ </tt><i>ex</i><sub>1</sub> <tt>,</tt> <i>ex</i><sub>2</sub>
	<tt>]</tt></td>
</tr>

</table>
</center></p>

<p>Values can be assigned to variables (or elements of vectors) through the
assignment operator <tt>=</tt>. A number of forms exist:</p>

<p>
<blockquote>
<table border="0">
<tr>
    <td valign="top"><i>expression</i></td>
    <td width="10"></td>
    <td>:
	<i>lvalue</i> <tt>=</tt> <i>expression</i><br />
    </td>
</tr>
<tr>
    <td valign="top"><i>lvalue</i>:</td>
    <td width="10"></td>
    <td>
	: <i>var_name</i><br />
	: <tt>[ </tt><i>var_name</i>
	    <b>{</b><tt>,</tt> <i>var_name</i><b>}<sup>*</sup></b>
	    <tt>]</tt><br />
	: <i>var_name</i> <tt>(</tt> <i>expression</i> <tt>)</tt>
	    <b>{</b><tt>(</tt> <i>expression</i>
	    <tt>)</tt><b>}<sup>*</sup></b><br />
	: <i>var_name</i> <tt>[</tt> <i>expression</i> <tt>]</tt><br />
	: <i>var_name</i> <tt>|</tt> <i>expression</i><br />
	: <i>var_name</i> <tt>||</tt> <i>expression</i><br />
	: <i>var_name</i> <tt>.</tt> <i>identifier</i><br />
	: <i>var_name</i> <tt>.(</tt> <i>expression</i> <tt>)</tt>
	: <tt>*</tt> <i>var_name</i><br />
	: <tt>*</tt> <i>var_name</i> <tt>(</tt> <i>expression</i> <tt>)</tt>
	    <b>{</b><tt>(</tt> <i>expression</i>
	    <tt>)</tt><b>}<sup>*</sup></b><br />
	: <tt>*</tt> <i>var_name</i> <tt>[</tt> <i>expression</i> <tt>]</tt><br />
	: <tt>*</tt> <i>var_name</i> <tt>|</tt> <i>expression</i><br />
	: <tt>*</tt> <i>var_name</i> <tt>||</tt> <i>expression</i><br />
	: <tt>*</tt> <i>var_name</i> <tt>.</tt> <i>identifier</i><br />
	: <tt>*</tt> <i>var_name</i> <tt>.(</tt> <i>expression</i> <tt>)</tt>
    </td>
    </td>
</tr>
</table>
</blockquote>

<p>The assignment operator replaces either the whole or a part of the variable
(or the dynamic variable) specified by the identifier in the <i>lvalue</i> by
the value of the <i>expression</i>.  This value then becomes the result of the assignment
expression.

For example, the expression

<span class="nobr"><tt>a(5) = i + 1</tt></span>

has the value

<span class="nobr"><tt>i + 1</tt></span>, so that:

<pre>
    svl&gt; i = igen 3; a = "xyz";
    svl&gt; print a(2) = i + 1;
    [2,3,4]
</pre>

<p>When <i>lvalue</i> is a <i>var_name</i>, its value is replaced with
the value of <i>expression</i>.  When the left-hand side is of the form

    <span class="nobr"><tt>[</tt><i>var_name</i><tt>,</tt>...<tt>,</tt>
    <i>var_name</i><tt>]</tt></span>,

the expression is shorthand for assigning the components of the right-hand
side expression to the variables contained in the left-hand side. For
example,

<pre>
    [a,b,c,d] = x;
</pre>

is equivalent to:

<pre>
    t = x;
    a = t(1);
    b = t(2);
    c = t(3);
    d = t(4);
</pre>

<p>Assignments involving the remaining forms of <i>lvalue</i> are shorthand
notations for single-variable assignments combined with the SVL functions

	<tt>poke</tt>,
	<tt>put</tt>,
	<tt>mput</tt>,
	<tt>apt mput</tt>,and
	<tt>tagpoke</tt>:</p>

<p> <center> <table class="titlebar" border="1" cellpadding="5">
<tr>
    <th>Assignment</th>
    <th>Shorthand For</th>
</tr>
<tr>
    <td><i>var</i> <tt>(</tt> <i>i</i> <tt>)</tt> <tt>= </tt><i>ex</i></td>
    <td><i>var</i><tt> = poke[</tt> <i>var</i> <tt>,</tt>
	 <i>i</i> <tt>,</tt> <i>ex</i> <tt>]</tt></td>
</tr>
<tr>
    <td><i>var</i>
	<tt>(</tt> <i>i</i> <tt>)(</tt>
	<i>j</i> <tt>)</tt><i>...</i>
	<tt> = </tt><i>ex</i></td>
    <td><i>var</i><tt> = poke[</tt> <i>var</i> <tt>,</tt>
	<tt>[</tt>
	    <i>i</i>
	<tt>,</tt>
	    <i>j</i>
	    <i>...</i>
	<tt>],</tt>
	<i>ex</i> <tt>]</tt></td>
</tr>
<tr>
    <td><i>var</i> <tt>[</tt> <i>idx</i> <tt>]</tt> <tt>= </tt><i>ex</i></td>
    <td><i>var</i><tt> = put[</tt> <i>var</i> <tt>,</tt>
	 <i>idx</i> <tt>,</tt> <i>ex</i> <tt>]</tt></td>
</tr>
<tr>
    <td><i>var</i> <tt>|</tt> <i>msk</i><tt> = </tt><i>ex</i></td>
    <td><i>var</i><tt> = mput[</tt> <i>var</i> <tt>,</tt>
	 <i>msk</i> <tt>,</tt> <i>ex</i> <tt>]</tt></td>
</tr>
<tr>
    <td><i>var</i> <tt>||</tt> <i>msk</i><tt> = </tt><i>ex</i></td>
    <td><i>var</i><tt> = apt mput[</tt> <i>var</i> <tt>,</tt>
	 <i>msk</i> <tt>,</tt> <i>ex</i> <tt>]</tt></td>
</tr>
<tr>
    <td><i>var</i> <tt>.</tt> <i>tag</i><tt> = </tt><i>ex</i></td>
    <td><i>var</i><tt> = tagpoke[</tt> <i>var</i> <tt>,</tt>
	 <tt>'</tt><i>tag</i><tt>'</tt> <tt>,</tt> <i>ex</i> <tt>]</tt></td>
<tr>
</tr>
    <td><i>var</i> <tt>.(</tt> <i>tag</i> <tt>)</tt>
	<tt>= </tt><i>ex</i></td>
    <td><i>var</i><tt> = tagpoke[</tt> <i>var</i> <tt>,</tt>
	 <i>tag</i> <tt>,</tt> <i>ex</i> <tt>]</tt></td>
</tr>
</table> </center> </p>

<p>
If the variable name, <tt>var_name</tt>, is not prefixed by <tt>*</tt>,
then the contents of the variable <tt>var_name</tt> itself will change.

If the variable name is prefixed by <tt>*</tt>, then the variable is
assumed to store the key of a dynamic variable, whose contents will
change.  The contents of the variable <tt>var_name</tt> itself will
not change.  For example:

<pre>
    y = *a;
    *a = x;
    *b(3) = x;
    *c.num = x;
</pre>

are equivalent to:

<pre>
    y = dvar_value a;
    dvar_setvalue [a, x];
    dvar_setvalue [b, poke [*b, 3, x]];
    dvar_setvalue [c, tagpoke [*c, 'num', x]];
</pre>


<p>
<b>Precedence</b>.
When a term in a general expression is attached on both left and right to
symbols for two operations, an ambiguity arises in the interpretation of the
expression:
<span class="nobr">... <i>op<sub>1</sub> term op<sub>2</sub></i> ...</span>
can be taken to mean
<span class="nobr">Case A: (... <i>op<sub>1</sub> term</i>)<i> op<sub>2</sub></i> ...</span>
or
<span class="nobr">Case B: ... <i>op<sub>1</sub></i> (<i>term op<sub>2</sub></i> ...)</span>.
This ambiguity is resolved by the SVL rules of precedence and associativity.
Each operator belongs to one precedence class; each class is of either
left-to-right (LR) or right-to-left (RL) associativity.

<ul>
<li>
    If <i>op</i><sub>1</sub> is of higher precedence
    than <i>op</i><sub>2</sub> then Case <i>A</i> applies.
</li><li>
    If <i>op</i><sub>2</sub> is of higher precedence
    than <i>op</i><sub>1</sub> then Case <i>B</i> applies.
</li><li>
    If both operators belong to the same precedence class, the associativity
    of that class determines the outcome:
    <ul>
	<li>LR associativity implies Case&nbsp;A</li>
	<li>RL associativity implies Case&nbsp;B</li>
    </ul>
</li>
</ul>

<P>
The binding of operators can be modified from default precedence rules
by explicit use of parenthesis <tt>(&nbsp;)</tt> in the expression.
The following table shows the precedence classes of SVL operators;
with the highest precedence class on the top of the table
and the lowest on the bottom:


<p><center><table class="titlebar" border="1" cellpadding="3">
<tr>
    <th>Class</th>
    <th>Operators</th>
    <th>Associativity</th>
</tr><tr>
    <td>identifier prefix</td>
    <td><tt> * # app apt</tt></td>
    <td> none </td>
</tr><tr>
    <td>subscript</td>
    <td><tt> [&nbsp;] (&nbsp;) .  </tt></td>
    <td> LR </td>
</tr><tr>
    <td>function argument</td>
    <td><i>fcn_name</i> <i>argument</i></td>
    <td> RL </td>
</tr><tr>
    <td>unary</td>
    <td><tt> -  </tt></td>
    <td> RL </td>
</tr><tr>
    <td>arithmetic *</td>
    <td><tt> * /  </tt></td>
    <td> LR </td>
</tr><tr>
    <td>arithmetic +</td>
    <td><tt> + -  </tt></td>
    <td> LR </td>
</tr><tr>
    <td>comparative</td>
    <td><tt> === == &lt;&gt; &lt; &lt;=  &gt;  &gt;= </tt></td>
    <td> LR </td>
</tr><tr>
    <td>boolean *</td>
    <td><tt> and  </tt></td>
    <td> LR </td>
</tr><tr>
    <td>boolean +</td>
    <td><tt> or  </tt></td>
    <td> LR </td>
</tr><tr>
    <td>packing</td>
    <td><tt> | ||  </tt></td>
    <td> LR </td>
</tr><tr>
    <td>assignment</td>
    <td><tt> =  </tt></td>
    <td> RL </td>
</tr>
</table></center></p>


<h2>See Also</h2>

<a href="s_lex.htm">SVL Lexical Analysis</a><br />
<a href="s_stmt.htm">SVL Statements</a><br />
<a href="s_decl.htm">SVL Declarations</a>

<noscript>
	<hr noshade="noshade" />
	<font size="2"> Copyright &copy; 1997&ndash;2015
	<a href="http://www.chemcomp.com">Chemical Computing Group Inc.</a> </font>
</noscript>
<div id="MoeFooter"></div>
</body>
</html>

