<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<!--	a_extend.htm	selection expression	
!!-->

<!--
!!    MOE Online Manuals
!!    COPYRIGHT (C) 1997-2015
!!        CHEMICAL COMPUTING GROUP INC.  ALL RIGHTS RESERVED.
!!-->

<head>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<script type="text/javascript" 
src="../../include/jsincludes_moe.js"></script>

<link rel="stylesheet" type="text/css"
href="../../include/manstyle.css" />


<meta keywords SEL:syntax Selection Expression />

<title>Selection Expression Language</title>
</head>

<body>
<div id="MoeHeader"></div>
<noscript>
	<span class="warning">Warning: JavaScript is disabled. This page will not display correctly.</span>
	<h1 class="title">MOE Documentation</h1>
	<hr noshade="noshade" />
	<style>.LaTeX {color: #C08080;}</style>
</noscript>

<h2>Syntax</h2>

<p>
<blockquote>
<table border="0">
<tr>
    <td valign="top"><i>expression</i></td>
    <td width="10"></td>
    <td>
	:   <b>{</b> <tt>bytag</tt>
	    <b>|</b> <tt>bychain</tt>
	    <b>|</b> <tt>bymol</tt>
	    <b>|</b> <tt>byres</tt>
	    <b>|</b> <tt>bydomain</tt>
	    <b>}<sup>*</sup></b> <i>expr</i><br />
	: <i>expression</i><tt> </tt>
	    <b>{</b> <tt>,</tt> <i>expression</i> <b>}<sup>*</sup></b>
	    <br />
    </td>
</tr>

<tr>
    <td valign="top"><i>expr</i></td>
    <td width="10"></td>
    <td>
	: <tt>(</tt> <i>expression</i> <tt>)</tt><br />
	: <i>primary</i><br />
	:
	    <b>{</b> <tt>!</tt>
	    <b>|</b> <tt>not</tt>
	    <b>}</b><sup>1</sup>
	    <i>expr</i><br />
	: <i>expr</i>
	    <b>{</b>
	    <tt>&gt;&gt;</tt> 
	    <b>|</b> <tt>-&gt;&gt;</tt>
	    <b>}</b><sup>1</sup>
	    <i>mode</i><br />	
	: <i>expr</i>
	    <b>{</b> <tt>&</tt>
	    <b>|</b> <tt>and</tt>
	    <b>|</b> <tt>*</tt>
	    <b>}</b><sup>1</sup>
	    <i>expr</i><br />
	: <i>expr</i>
	    <b>{</b> <tt>-</tt>
	    <b>|</b> <tt>|</tt>
	    <b>|</b> <tt>or</tt>
	    <b>|</b> <tt>+</tt>
	    <b>}</b><sup>1</sup>
	    <i>expr</i><br />
	: <i>nset</i>
	    <b>{</b>
	    <tt>&gt;&gt;=</tt> 
	    <b>|</b> <tt>-&gt;&gt;=</tt>
	    <b>}</b><sup>1</sup>
	    <i>mode</i><br />
	: <i>nset</i>
	    <b>{</b> <tt>=</tt>
	    <b>|</b> <tt>&=</tt>
	    <b>|</b> <tt>*=</tt>
	    <b>|</b> <tt>|=</tt>
	    <b>|</b> <tt>+=</tt>
	    <b>|</b> <tt>-=</tt>
	    <b>}</b><sup>1</sup>
	    <i>expr</i><br />
    </td>
</tr>

<tr>
    <td valign="top"><i>primary</i></td>
    <td width="10"></td>
    <td>
	: <i>nset</i><br />
	: <i>string</i><br />
	: <i>macro</i><br />
	: <i>seqpattern</i><br />
	: <i>function</i> <b>{</b> <i>cmp</i> </b>}</b><br />
	: <i>keyword</i><br />
	: <tt>hbond</tt> 
	    <b>{</b> <tt>(</tt> <i>expr</i><tt>, </tt><i>expr</i> <tt>)</tt>
	    <b>}</b> <b>{</b> <i>cmp</i> <b>}</b> <br />
	: <tt>clash</tt>
	    <b>{</b> <tt>(</tt> <i>expr</i><tt>, </tt><i>expr</i> <tt>)</tt>
	    <b>}</b> <b>{</b> <i>cmp</i> <b>}</b> <br />
	: <tt>dist</tt> 
	    <b>{</b> <tt>(</tt> <i>expr</i><tt>, </tt><i>expr</i> <tt>)</tt>
	    <b>}</b> <b>{</b> <i>cmp</i> <b>}</b> <br />
	: <tt>prosite </tt><i>string</i><br />
	: <tt>smarts </tt><i>string</i><br />
    </td>
</tr>

<tr>
    <td><i>cmp</i> </td>
    <td></td>
    <td>:  
	<b>{</b> <tt><</tt>
	<b>|</b> <tt>&gt;</tt>
	<b>|</b> <tt><=</tt>
	<b>|</b> <tt>>=</tt>
	<b>|</b> <tt>==</tt>
	<b>|</b> <tt>&lt;&gt;</tt>
	<b>}</b><sup>1</sup>
	<b>{</b> <b>{</b> <tt>-</tt> <b>|</b> <tt>+</tt> <b>}</b><i>number</i>
	<b>|</b> <i>token</i>
	<b>|</b> <i>string</i>
	<b>}</b><sup>1</sup>
    </td>
</tr>

<tr>
    <td valign="top"><i>nset</i></td>
    <td width="10"></td>
    <td>  
	 : <tt>$</tt><b>{</b> <tt>$</tt> <b>}</b><b>{</b> <i>name</i> <b>|</b> 
	<i>string</i> <b>}</b><sup>1</sup><br />
 
    </td>
</tr>

<tr>
    <td valign="top"><i>mode</i>:</td>
    <td width="10"></td>
    <td>
	: <i>number</i><br />
	: <tt>res</tt><b>{</b><tt>idue</tt><b>}</b></tt><br />
	: <tt>chain</tt><br />
	: <b>{</b><tt>c</tt><b>}</b><tt>tag</tt><br />
	: <tt>mol</tt><b>{</b><tt>ecule</tt><b>}</b><br />
	: <tt>light</tt><br />
	: <tt>lp</tt><br />
	: <tt>h</tt><br />
	: <tt>hc</tt><br />
	: <tt>hx</tt><br />
	: <tt>heavy</tt><br />
	: <tt>bond</tt> <b>{</b> <i>number</i> <b>}</b><br />
	: <tt>multibond</tt> <b>{</b> <i>number</i> <b>}</b><br /> 
	: <b>{</b>
	    <tt>column</tt> <b>|</b> <tt>col</tt> <b>|</b> <tt>secol</tt>
	    <b>}</b><sup>1</sup><br />
	: <b>{</b> <tt>rpos</tt> <b>|</b> <tt>sepos</tt> <b>}</b><sup>1</sup>
	    <b>{</b> <tt>-</tt> <b>|</b> <tt>+</tt> <b>}</b><i>number</i><br />
	: <tt>rnumber</tt> <b>{</b> <tt>-</tt> <b>|</b> <tt>+</tt> <b>}</b><i>number</i><br />
	: <tt>connector</tt><br />
	: <tt>sstruct</tt><br />
	: <tt>domain</tt><br />
	: <tt>sidechain</tt><br />
	: <tt>backbone</tt><br />
    </td>
</tr>

<tr>
    <td valign="top"><i>number</i>
    <td width="10">
    <td>
	: <b>{</b> <i>digit</i> <b>}<sup>+</sup></b><br />
	: <tt>0o</tt> <b>{</b>
	<tt>0</tt> <b>|</b> <tt>1</tt> <b>|</b> ... <b>|</b> <tt>7</tt>
	<b>}<sup>+</sup></b><br /> 
	: <tt>0x</tt> <b>{</b>
		<tt>0</tt> <b>|</b> <tt>1</tt> <b>|</b> ... <b>|</b> <tt>9</tt>
		<b>|</b> <tt>a</tt> <b>|</b> <tt>b</tt> <b>|</b> ... <b>|</b> <tt>f</tt>
		<b>|</b> <tt>A</tt> <b>|</b> <tt>B</tt> <b>|</b> ... <b>|</b> <tt>F</tt>
	<b>}<sup>+</sup></b><br />
	: <tt>0y</tt> <b>{</b>
	<tt>0</tt> <b>|</b> <tt>1</tt>
	<b>}<sup>+</sup></b><br />
	: <b>{</b> <i>digit</i> <b>}<sup>+</sup></b>
	<tt>.</tt>
	<b>{</b> <i>digit</i> <b>}<sup>+</sup></b>
	<br />
	: <b>{</b> <i>digit</i> <b>}<sup>+</sup></b>
	<b>{</b> <tt>.</tt> <b>{</b> <i>digit</i> <b>}<sup>+</sup></b> <b>}</b>
	<b>{</b> <tt>e</tt> <b>|</b> <tt>E</tt> <b>}<sup>1</sup></b>
	<b>{</b> <tt>+</tt> <b>|</b> <tt>-</tt> <b>}</b>
	<b>{</b> <i>digit</i> <b>}<sup>+</sup></b>
    </td>
</tr>

<tr>
     <td><i>digit</i> </td>
    <td></td>
    <td>:  
 	 <b>{</b> <tt>0</tt>
	<b>|</b> <tt>1</tt>
	<b>|</b> ...
	<b>|</b> <tt>9</tt>
	<b>}</b> <sup>1</sup>
 
    </td>
</tr>

<tr>
<td valign="top"><i>token</i>
<td width="10"></td>
<td>
    : <tt>'</tt> <b>{</b> <i>printable_character</i> <b>}<sup>*</sup></b> <tt>'</tt>
</tr>

<tr>
<td valign="top"><i>string</i>
<td width="10"></td>
<td>
    : <tt>"</tt> <b>{</b> <i>printable_character</i> <b>}<sup>*</sup></b> <tt>"</tt>
</tr>

<tr>
<td valign="top"><i>name</i>
<td width="10"></td>
<td>
    : <b>{</b> <i>printable_character</i> <b>}<sup>*</sup></b>
</tr>

<tr>
    <td valign="top"><a name="macro_syntax"></a><i>macro</i>:</td>
    <td width="10"></td>
    <td>
	: <tt>/</tt><i>tname</i>
	<b>{</b> <tt>/</tt><i>cletter</i> 
	<b>{</b> <tt>/</tt><i>rname</i>
	<b>{</b> <tt>/</tt><i>aname</i> <b>}</b> <b>}</b> <b>}</b><br />
 
	: <i>aname</i>  
	<tt>/</tt><b>{</b> <i>rname</i>
	<b>{</b> <tt>/</tt><i>cletter</i>  
	<b>{</b> <tt>/</tt><i>tname</i> <b>}</b> <b>}</b> <b>}</b><br />
	 
    </td>
</tr>

<tr>
    <td valign="top"><i>seqpattern</i></td>
    <td width="10"></td>
    <td>
	: <i>rcode</i><b>{</b> <i>ruid</i>
	    <b>{</b> <i>rins</i> <b>}</b> <b>}</b><br />
	: <i>rcode</i><b>{</b> <i>rcode</i> <b>}</b><sup>+</sup><br />
	: <b>{</b> <i>rcode</i>  <b>}</b><i>ruid</i><b>{</b> <i>rins</i>
	    <b>}</b><tt>:</tt><b>{</b> <i>rcode</i>  
	    <b>}</b><i>ruid</i><b>{</b> <i>rins</i> <b>}</b><br />
	: <i>rcode</i><b>{</b> <i>ruid</i> <b>}</b><b>{</b>  
	    <i>rins</i> <b>}</b><tt>:</tt><i>rcode</i><b>{</b> <i>ruid</i> 
	    <b>}</b><b>{</b> <i>rins</i> <b>}</b<br />
    </td>
</tr>

<tr>
 <td valign="top"><i>upperletter</i></td>
    <td width="10"></td>
    <td>:
	<b>{</b> <tt>A</tt> <b>|</b> <tt>B</tt> <b>|</b> ... <b>|</b> <tt>Z</tt> 
	<b>}</b><sup>1</sup> <br />
    </td>
</tr>
<tr>
 <td valign="top"><i>lowerletter</i></td>
    <td width="10"></td>
    <td>:
	<b>{</b> <tt>a</tt> <b>|</b> <tt>b</tt> <b>|</b> ... <b>|</b> <tt>z</tt> 
	<b>}</b><sup>1</sup> <br />
    </td>
</tr>
<tr>
    <td valign="top"><i>rcode</i></td>
    <td width="10"></td>
    <td>
	: <i>upperletter</i><b>{</b> <i>lowerletter</i> <b>|</b>
	<i>digit</i> <b>}</b><sup>*</sup> <br /> 
    </td>
</tr>

<tr>
    <td valign="top"><i>ruid</i></td>
    <td width="10"></td>
    <td>: <b>{</b> - <b>}</b><b>{</b> <i>digit</i> <b>}<sup>+</sup></b></td>
</tr>

<tr>
    <td valign="top"><i>rins</i></td>
    <td width="10"></td>
    <td>: <i>printable_character</i></td>
</tr>

<tr>
    <td valign="top"><i>function</i>:</td>
    <td width="10"></td>
    <td>
	: <tt>aBackbone</tt><br />
	: <tt>aBondLook</tt><br />
	: <tt>aCharge</tt><br />
	: <tt>aColor</tt><br />
	: <tt>aColorBy</tt><br />
	: <tt>aFixed</tt><br />
	: <tt>aForceRS</tt><br />
	: <tt>aGeometry</tt><br />
	: <tt>aHidden</tt><br />
	: <tt>aElement</tt><br />
	: <tt>aHintLP</tt><br />
	: <tt>aInert</tt><br />
	: <tt>aIon</tt><br />
	: <tt>aLabelRes</tt><br />
	: <tt>aLabelName</tt><br />
	: <tt>aLabelCharge</tt><br />
	: <tt>aLabelElement</tt><br />
	: <tt>aMass</tt><br />
	: <tt>aName</tt><br />
	: <tt>aState</tt><br />
	: <tt>aLabelChain</tt><br />
	: <tt>aRGB</tt><br />
	: <tt>aScalar</tt><br />
	: <tt>aOccupancy</tt><br />
	: <tt>aLabelMMType</tt><br />
	: <tt>aSelected</tt><br />
	: <tt>aTempFactor</tt><br />
	: <tt>aWall</tt><br />
	: <tt>aNucleusLook</tt><br />
	: <tt>aMMType</tt><br />

	: <tt>rFixedSE</tt><br />
	: <tt>rINS</tt><br />
	: <tt>rColor</tt><br />
	: <tt>rColorBy</tt><br />
	: <tt>rName</tt><br />
	: <tt>rUID</tt><br />
	: <tt>rPos</tt><br />
	: <tt>rRGB</tt><br />
	: <tt>rDomain</tt><br />
	: <tt>rNumber</tt><br />
	: <tt>rPosSE</tt><br />
	: <tt>rVisibleSE</tt><br />
	: <tt>rLetter</tt><br />
	: <tt>rSegment</tt><br />
	: <tt>rType</tt><br />
	: <tt>rAtomCount</tt><br />
	: <tt>rScalar1</tt><br />
	: <tt>rScalar2</tt><br />
	: <tt>rScalar3</tt><br />
	: <tt>rActualSegment</tt><br />
	: <tt>rRibbonMode</tt><br />

	: <tt>cColorBy</tt><br />
	: <tt>cColor</tt><br />
	: <tt>cHeader</tt><br />
	: <tt>cName</tt><br />
	: <tt>cTag</tt><br />
	: <tt>cRGB</tt><br />
	: <tt>cHiddenSE</tt><br />
	: <tt>cResidueCount</tt><br />
	: <tt>cLetter</tt><br />
    </td>
</tr>

<tr>
    <td valign="top"><i>keyword</i>:</td>
    <td width="10"></td>
    <td>
	: <tt>all</tt><br />
	: <tt>none</tt><br />
	: <tt>isempty</tt><br />
	: <tt>cempty</tt><br />
	: <tt>rempty</tt><br />
	: <tt>asel</tt><br />
	: <tt>rsel</tt><br />
	: <tt>csel</tt><br />
	: <tt>asel?</tt><br />
	: <tt>rsel?</tt><br />
	: <tt>csel?</tt><br />
	: <tt>backbone</tt><br />
	: <tt>sidechain</tt><br />

	: <tt>ligand</tt><br />
	: <tt>lig</tt><br />
	: <tt>receptor</tt><br />
	: <tt>rec</tt><br />
	: <tt>solvent</tt><br />
	: <tt>sol</tt><br />
	: <tt>pocket</tt><br />
	: <tt>amino</tt><br />
	: <tt>nucleic</tt><br />
	: <tt>dummy</tt><br />
 
	: <tt>light</tt><br />
	: <tt>heavy</tt><br />
	: <tt>visible</tt><br />
	: <tt>hidden</tt><br />
	: <tt>inert</tt><br />
	: <tt>fixed</tt><br />
	: <tt>free</tt><br />
	: <tt>active</tt><br />
	: <tt>walled</tt><br />
	: <tt>tethered</tt><br />
	: <tt>constrained</tt><br />
	: <tt>restrained</tt><br />

	: <tt>water</tt><br />
	: <tt>hoh</tt><br />
	: <tt>hydrogen</tt><br />
	: <tt>h</tt><br />
	: <tt>hc</tt><br />
	: <tt>hx</tt><br />
	: <tt>lonepair</tt><br />
	: <tt>lp</tt><br />
	: <tt>tmetal</tt><br />
	: <tt>ion</tt><br />

	: <tt>sstruct</tt> 
	    <b>{</b> <tt>h</tt>
	    <b>|</b> <tt>s</tt>
	    <b>|</b> <tt>t</tt>
	    <b>|</b> <tt>n</tt> 
	    <b>}</b><br />
	: <tt>buried</tt> <b>{</b> <i>number</i> <b>}</b><br />
	: <tt>exposed</tt> <b>{</b> <i>number</i> <b>}</b><br />
    </td>
</tr>
</table>
</blockquote>

<h2>Description</h2>

<p>Selection expressions operate on object keys, i.e.
on chains, residues, and atoms.
The result of an expression is the object keys that
satisfy the expression. 
</p>

<p>
The following notation is used to describe the selection expression syntax and
syntactic categories.  The name of a category is printed in italics, e.g.
<i>lvalue</i>.  Selection expression keywords and symbols are printed in
teletype, e.g. <tt>loop</tt> or <tt>[]</tt>.  Each category is defined as
a list of syntactic patterns composed of expression keywords or symbols and of
names of other categories, similar to BNF notation. For example,

<pre>
    <i>lvalue</i> : <i>identifier</i> [ <i>expression</i> ]
</pre>

means &quot;an lvalue can
be an identifier followed by a bracketed expression&quot;.
Bold braces are used to
apply a special rule to the part of the pattern inside the braces:

<ul>
<li><b>{</b>...<b>}</b> specifies an optional pattern, e.g.
    <span class="nobr"><b>{</b><em>for</em><b>}</b> <tt>loop</tt></span>
</li>

<li><b>{</b>...<b>}<sup>*</sup></b> specifies a sequence of zero or more
    repetitions, e.g.
    <span class="nobr"><b>{</b><em>while</em><b>}<sup>*</sup></b> <tt>loop</tt></span>
</li>

<li><b>{</b>...<b>}<sup>+</sup></b> specifies a sequence of one or more
    repetitions, e.g.
    <span class="nobr"><b>{</b><em>digit</em><b>}<sup>*</sup></b></span>
</li>

<li><b>{</b>...<b>|</b>...<b>}</b> and
    <b>{</b>...<b>|</b>...<b>}<sup>1</sup></b> specify
    (optional and compulsory) alternative patterns, e.g.
    <span class="nobr"><b>{</b><tt>local</tt><b> | </b><tt>global</tt><b>}</b>
	<tt>function</tt></span>
</li>
</ul>

<p><b>Expression Sequence</b>.
An expression sequence is a list of expressions, separated by commas,
and is evaluated linearly from left 
to right. For example,
<pre>
	$a = ligand &gt;&gt; 3, $a &amp; receptor
</pre>

<p><b>Nset</b>.  

A named set can be used to store the expression result. There are two types of
sets, global and temporary.  Global sets are specified by
prefixing with a single '<tt>$</tt>' character,
and temporary by prefixing with two '<tt>$</tt>' characters, i.e.
'<tt>$$</tt>'.  If the set
name contains spaces or reserved characters, e.g. <tt>+</tt>,
<tt>&amp;</tt>, or  <tt>&ndash;</tt>, 
the name must be enclosed in double
quotes. An empty set name is not allowed. Examples: 

<pre>
	$global 
	$$temporary
	$&quot;aa,+bb cc&quot;
</pre>

Temporary sets can only be used in the expression evaluation period whereas
global sets remain in memory and can be accessed as
a named SVL <a href="collect.htm#oGetCollection">collection</a>.
When accessing global sets using SVL functions, the name is given
without the '<tt>$</tt>' prefix. For example.

<pre>
	$&quot;global seta&quot;
</pre>

would be accessed as

<pre>
	svl&gt; oGetCollection 'global seta'
</pre>

<p><b>Assignment</b>. The result of an assignment operation is the
value of the named set.  Shorthand operators such as
'<tt>+=</tt>' exist, combining a boolean or extension
operation together with the assignment. For
example,

<pre>
	$aset &amp;= ligand
	$bset &gt;&gt;= 3 
</pre>

have the same effect as

<pre>
	$aset = $aset &amp; ligand
	$bset = $bset &gt;&gt; 3 
</pre>

<p><b>Extension</b>.

'<tt>&gt;&gt;</tt>' acts as an extension operator which returns the selection
of its left expression plus all the objects that match the extension mode to
that expression. '<tt>-&gt;&gt;</tt>' returns just the extended part. For
example,

<pre>
	asel &gt;&gt; bond
</pre>

will extend the selection to include atoms that are bonded to the currently
selected atoms.

<pre>
	ligand -&gt;&gt; 5
</pre>

will select all atoms that are within a radius of 5 &Aring;
of any ligand atom,
excluding the ligand atoms themselves.

<p>The following table describes all extension modes: 
</p>

<p><center><table class="titlebar" border="1" cellpadding="3">
<tr>
    <th>Mode</th>
    <th>Description</th>
</tr><tr> 
    <td><i>number</i></td>
    <td>extend to a given radius (&Aring;)</td>
</tr><tr> 
    <td><tt>residue</tt>, <tt>chain</tt>, <tt>tag</tt></td>
    <td>extend to residue, chain or tag</td>
</tr><tr>
    <td><tt>light</tt>, <tt>lp</tt>, <tt>h</tt>, <tt>hc</tt>,
	<tt>hx</tt>, <tt>heavy</tt></td>
    <td>extend to bonded light, lone pair, hydrogen,
	nonpolar hydrogen, polar hydrogen or heavy atom neighbors
    </td>
</tr><tr>
    <td><tt>molecule</tt></td>
    <td>extend to the connected component
	(see <a href="atom.htm#aMoleculeNumber" >aMoleculeNumber</a>)
    </td>
</tr><tr>
   <td><tt>bond <i>n</i></tt></td>
    <td>extend to bonded atoms; <i>n</i> is optional and
	specifies the extension degree (default 1, maximum 10)</td>
</tr><tr>
   <td><tt>multibond <i>n</i></tt></td>
    <td>extend to higher-order bonded atoms; <i>n</i> is optional and
	defined as for <tt>bond</tt></td>
</tr><tr>
    <td><tt>column</tt></td>
    <td>residues that belongs to the same column in the Sequence Editor</td>
</tr><tr>
    <td><tt>rpos {+|-}<i>n</i></tt></td>
    <td>residues that match the <a href="residue.htm#rPosSE">rPosSE</a>
	position range; '<tt>+</tt>' meaning to the right and
	'<tt>&ndash;</tt>' meaning to the left (default </br>
	extend to both sides); <i>n</i> is optional and
	specifies the number of positions by which to extend
	(default 1, maximum 5000)
    </td>
</tr><tr>
    <td><tt>rnumber</tt></td>
    <td>same as <tt>rpos</tt> but evaluated on the index
	number in its parent chain</td>
</tr><tr>
    <td><tt>connector</tt></td>
    <td>extend to atoms along all shortest paths connecting any two atoms
	in the initial set
</tr><tr>
    <td><tt>sstruct</tt></td>
    <td>extend to same secondary structure</td>
</tr><tr>
    <td><tt>domain</tt></td>
    <td>extend to all the same domains</td>
</tr><tr>
    <td><tt>sidechain</tt></td>
    <td>for each sidechain atom, extend to the rest of the sidechain atoms
	belonging to the same residue
    </td>
</tr><tr>
    <td><tt>backbone</tt></td>
    <td>for each backbone atom, extend to the rest of the backbone atoms
	belonging to the same residue</td>
</tr>
</table></center></p>

<p><b>Split Tag</b>. <i>splitop</i> splits the input by the given
category, performs individual evaluations,
and returns the union of the results. For example,
<pre>
	bytag ligand &gt;&gt; 3
</pre>

will iterate through all tags, extending the selection to include
each ligand as well as all atoms within 3 &Aring; of that ligand
that share a tag with that ligand.
 
<p><b>Boolean Operator</b>. The following tables shows the meaning and alternates of all the boolean operators.
<p><center><table class="titlebar" border="1" cellpadding="3">
<tr>
    <th>Class</th>
    <th>Alternates</th>
    <th>Example</th>
     <th>Meaning</th>
</tr>
<tr>
    <td>intersection</td>
    <td><tt>and &amp; *</tt></td>
    <td><tt>receptor &amp; heavy</tt></td>
    <td>receptor heavy atoms</td>
</tr>
<tr>
    <td>union</td>
    <td><tt>or | +</tt></td>
    <td><tt>ligand + solvent</tt></td>
    <td>ligand and solvent atoms</td>
</tr>
<tr>
    <td>difference</td>
    <td><tt>&ndash;</tt></td>
    <td><tt>backbone &ndash; fixed</tt></td>
    <td>unfixed backbone atoms</td>
</tr>

</table></center></p>

<p><b>Negation Operator</b>. When '<tt>!</tt>' or '<tt>not</tt>'
is placed in front of an expression, 
the returned value comprises everything that does not match the
expression.

<p><b>function</b>.  Some common SVL functions which take object keys as an
argument are accessible directly from the selection language. The objects
satisfying the selection expression will be those for
which the result from the SVL function matches the comparison criteria.
The comparison value needs to be in the same format as the return
value of the SVL function. For example,

<pre>
	aCharge &lt; 0.4
	aName == 'CA'
	rLetter == "G"
	cRGB &gt;= 0x00ffff
	aBackbone
</pre>
In the case where the comparison criterion is omitted,
return values are evaluated using the following rules,
depending on the type of return value from the SVL function:

    <ul>
    <li>number: &lt;&gt; 0
    </li><li>token: &lt;&gt; ''
    </li><li>string: &lt;&gt; &quot; &quot;
    </li>
    </ul>

<p><b>SMARTS</b>. Double quoted strings preceded by the
'<tt>smarts</tt>' keyword are  
parsed as SMARTS patterns.  Note that the keyword <tt>smarts</tt>
can be omitted. The return value is the set of all atoms
comprising the substructures that match the SMARTS string
(see <a href="smartsfcn.htm#sm_MatchAll" class="svl">sm_MatchAll</a> for more details).
For example,

<pre>
	smarts &quot;C(=O)C&quot;
</pre>

will return all atoms belonging to ketone groups.

<p><b>Keywords</b> are predefined terms for some common selections. Most
keywords do not require any parameters; special cases are explained in the
table below.

<p><center><table class="titlebar" border="1" cellpadding="3">
<tr>
    <th>Keyword</th>
    <th>Description</th>
</tr>
<tr>
    <td><tt>isempty</tt></td>
    <td>empty chains or residues </td>
</tr>
<tr>
    <td><tt>asel?</tt></td>
    <td>all currently selected atoms or all atoms if none selected</td>
</tr>
<tr>
    <td><tt>rsel?</tt></td>
    <td>all currently selected residues or all residues if none selected</td>
</tr>
<tr>
    <td><tt>csel?</tt></td>
    <td>all currently selected chains or all chains if none selected</td>
</tr>
<tr>
    <td><tt>lig</tt></td>
    <td>ligand</td>
</tr>
<tr>
    <td><tt>rec</tt></td>
    <td>receptor</td>
</tr>
<tr>
    <td><tt>sol</tt></td>
    <td>solvent</td>
</tr>
<tr>
    <td><tt>hx</tt></td>
    <td>polar hydrogen</td>
</tr>
<tr>
    <td><tt>hc</tt></td>
    <td>nonpolar hydrogen</td>
</tr>
<tr>
    <td><tt>h</tt></td>
    <td>hydrogen</td>
</tr>
<tr>
    <td><tt>lp</tt></td>
    <td>lone pair</td>
</tr>
<tr>
    <td><tt>hoh</tt></td>
    <td>water</td>
</tr>
<tr>
    <td><a name="sstruct"></a><tt>sstruct {h|s|t|n}</tt></td>
    <td>Secondary structure specification:</br>
	<ul>
	<li><tt>h</tt>: helix
	</li><li><tt>s</tt>: strand
	</li><li><tt>t</tt>: turn
	</li><li><tt>n</tt>: none
	</li>
	</ul>
    </td>
</tr>
<tr>
    <td><tt>buried <i>n</i></tt></td>
    <td>buried atoms, <i>n</i> is the probe size (default 1.4&Aring;)</td>
</tr>
<tr>
    <td><tt>exposed <i>n</i></tt></td>
    <td>exposed atoms, <i>n</i> is the probe size (default 1.4&Aring;)</td>
</tr>
</table></center></p>

<p><b>Interactions</b>. <tt>hbond</tt>, <tt>clash</tt>, and
<tt>dist</tt> each operate on two expression sets which
are supplied as a parenthesized list and
optionally followed by a comparison expression.
The return value is atoms from the first set in the list
that satisfy the comparison. For example,

<pre>
	dist (ligand, receptor) &gt; 5
</pre>

returns all ligand atoms that are at least 5&Aring; away
from any receptor atoms.

<p> The expression sets can be omitted, in which case the default will be
&quot;(all, all)&quot;, i.e. all available objects. If the
comparison is omitted, the implied defaults are as follows:
</p>

<p><center><table class="titlebar" border="1" cellpadding="3">
<tr>
    <th>Function</th>
    <th>Default</th>
    <th>Units</th>
</tr><tr> 
    <td><tt>hbond</tt></td>
    <td>&lt;= -0.5</td>
    <td>kcal/mol</td>
</tr><tr>
    <td><tt>clash</tt></td>
    <td>&gt;= 2.0</td>
    <td>kcal/mol</td>
</tr><tr>
    <td><tt>dist</tt></td>
    <td>&lt;= 1.0</td>
    <td>&Aring;</td>
</tr>
</table></center></p>

<p><b>Macro</b>.  The selection syntax includes a shorthand notation for
specifying selections based on object name properties.  In the
syntax description <a href="#macro_syntax">above</a>,
<tt>tname</tt> stands
for chain tag name, <tt>cletter</tt> stands for chain letter, <tt>rname</tt>
stands for residue name and <tt>aname</tt> stands for atom name.
</p>

<p>Two forms are
supported. Macros that start with a '/' are interpreted from left
to right beginning with the tag name and proceeding down the object
hierarchy to the atom name.  If there is no leading '/',
the order of fields is
reversed. Missing components are interpreted as '*'.  Patterns using
<a href="../../svl/fcnref/findetc.htm">findmatch</a> syntax
are permitted, and matching is case-insensitive.
</p>

<p>
<tt>rname</tt> can be a <a href="#seqpattern">sequence pattern</a>
which contains UID/INS combinations or a residue range.
For example,
</p>

<pre>
    /1ATP/E/VAL/CA	cTag == '1ATP' &amp; cLetter == 'E'
			    &amp; rName == 'VAL' &amp; aName == 'CA'
    /1ATP/E/V*/C[AB]	parent residue name starts with 'V',
			    atoms named either 'CA' or 'CB'
    ca//E	 	aName == 'CA' &amp; cLetter == 'E'
    ///Ala12f		residue 'ALA' with UID 12 and INS either 'f' or 'F'
</pre>

<p><a name="seqpattern"></a><b>Sequence Pattern</b>.

<i>seqpattern</i> is a shorthand for residue sequence selections.  The pattern
can take one of three forms: single residue, residue sequence, or range. To
indicate a single residue, the pattern must start with the name of
that residue (first letter in uppercase and other letters in lowercase)
optionally followed by the UID number, optionally followed by the INS number.
When the residue name is not one of the
standard IUPAC codes, e.g. it contain numbers, 
use <b>~</b> as separator between the name, UID and INS.
To indicate a sequence, the pattern is a string of residue names, expressed
using either 
single-letter IUPAC codes (must be uppercase) or full names,
with the first
letter in uppercase and remaining letters in lowercase. For example,

<pre>
	Ala245f
	Ala245
	G12~3~A		residue with name 'G12', UID 3 and INS code A
	Ala
	AGH
	AlaGHis
	 
</pre>

A colon separating two single residue forms specifies a range.
The INS number is
optional, but at least one residue name or UID number needs to be provided.
For example

<pre>
	Ala4b:Gly10		 
	4b:10			 
</pre>

<p>
<a name="PROSITE"><b>PROSITE Pattern</b></a>.
Please refer to the official
<b>PROSITE</b> website for the <a
href="http://prosite.expasy.org/scanprosite/scanprosite-doc.html#pattern_syntax">pattern</a>
syntax.  <b>Note:</b> extended PROSITE patterns, e.g.
&quot;<{C}*>&quot; are not supported,
but the same result can be obtained using <i>seqpattern</i> combined with
a negated expression, e.g <tt>!C</tt>.
 
<p><b>Precedence</b>.
When a term in a general expression is attached on both left and right to
symbols for two operations, an ambiguity arises in the interpretation of the
expression:

<span class="nobr">... <i>op<sub>1</sub> term op<sub>2</sub></i> ...</span>
can be taken to mean
<span class="nobr">Case A: (... <i>op<sub>1</sub> term</i>)<i> op<sub>2</sub></i> ...</span>
or
<span class="nobr">Case B: ... <i>op<sub>1</sub></i> (<i>term op<sub>2</sub></i> ...)</span>.
This ambiguity is resolved by rules of precedence.
Each operator belongs to one precedence class.

<ul>
<li>
    If <i>op</i><sub>1</sub> is of higher precedence
    than <i>op</i><sub>2</sub>, Case <i>A</i> applies.
</li><li>
    If <i>op</i><sub>2</sub> is of higher precedence
    than <i>op</i><sub>1</sub>, Case <i>B</i> applies.
</li>
</ul>

<P>
The binding of operators can be modified from default precedence rules
by explicit use of parentheses <tt>(&nbsp;)</tt> in the expression.
The following table shows the precedence classes of operators;
with the highest precedence class at the top of the table
and the lowest at the bottom:


<p><center><table class="titlebar" border="1" cellpadding="3">
<tr>
    <th>Class</th>
    <th>Operators</th>
</tr><tr> 
    <td>comparative</td>
    <td><tt> == &lt;&gt; &lt; &lt;=  &gt;  &gt;= </tt></td>
</tr><tr>
   <td>unary</td>
    <td><tt> not </tt></td>
</tr><tr>
    <td>extend</td>
    <td><tt> &gt;&gt; &ndash;&gt;&gt; </tt></td>
</tr><tr>
    <td>boolean</td>
    <td><tt> &amp; </tt></td>
</tr>
</tr><tr>
    <td>boolean</td>
    <td><tt> + &ndash; </tt></td>
</tr>
</tr><tr>
    <td>extend assignment</td>
    <td><tt> &gt;&gt;= -&gt;&gt;= </tt></td>
</tr>
</tr><tr>
    <td>assignment</td>
    <td><tt> = &amp;= *= |= += &ndash;= </tt></td>
</tr>
</tr><tr>
    <td>split</td>
    <td><tt> bytag bychain byres bymol bydomain </tt></td>
</tr>
</tr><tr>
    <td>sequence</td>
    <td><tt> , </tt></td>
</tr>
</table></center></p>
For example,
<pre>
	$a = receptor &amp; ligand &gt;&gt; 3
</pre>
will perform extension first then intersect the result with
<tt>receptor</tt> and in the end assign value to set <tt>a</tt>.

<a name="See_Also"></a><h2>See Also</h2>

<a href="../gui/sel_ui.htm">Selection Prompter</a><br />
<a href="../gui/mainwin.htm#SelectionPrompter">Selecting Atoms Using the Selection Prompter</a><br />

<noscript>
	<hr noshade="noshade" />
	<font size="2"> Copyright &copy; 1997&ndash;2015
	<a href="http://www.chemcomp.com">Chemical Computing Group Inc.</a> </font>
</noscript>
<div id="MoeFooter"></div>
</body>
</html>
